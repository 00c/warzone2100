-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for
TILE = 128
NONE = (-1)

-- These are final rules of the lexical parser
R_REQUEST_HELP = "help me"
R_REQUEST_BEACON = "drop a beacon"
R_REPORT_SAFETY = "i'm ok"
R_REQUEST_ALLY = "ally me"

-- These are our own messages - lexical parser should be able to handle them
M_REQUEST_HELP = "help me!!"
M_REQUEST_BEACON = "drop a beacon"
M_AFFIRMATIVE_OK = "ok"
M_AFFIRMATIVE_ROGER = "roger"
M_ANNOYED = "bug off"
M_HELPERS_KILLED = "that was all I had.."
M_HELP_NO_UNITS = "I don't have anything"

MAX_PROBABILITY = 100

-- Base threat range in world units
W_BASE_THREAT_RANGE = function () return ((17 + (C.mapWidth + C.mapHeight) / 2 / 35) * TILE) end
ALL_ALLIES = -1

BASE_DEFEND_DURATION = (3 * 60)
BASE_DEFEND_RADIUS = function () return (15 * TILE) end

-- Delay before we repeat our request, in seconds
HELP_REQUEST_INTERVAL = (3 * 60)

-- in secs
BEACON_TIMEOUT = 30

MAX_DROIDS = 150

-- don't try to build on oil if there's threat within this range
OIL_THREAT_RANGE = function () return (9 * TILE) end

MAX_TRUCKS = 9
MIN_TRUCKS = 5

-- Enter power saving mode when lower than this
LOW_POWER = 250

-- Start spending spree when above this
HIGH_POWER = 1250

-- Target type values
NO_TARGET_VALUE = 0
DROID_TARGET_VALUE = 1
OTHER_TARGET_VALUE = 2
DEFENSE_TARGET_VALUE = 3
RESEARCH_TARGET_VALUE = 4
HQ_TARGET_VALUE = 5
OIL_TARGET_VALUE = 6
FACTORY_TARGET_VALUE = 7

UNLIMITED = (-1)

AA_THREAT_RANGE = function () return (TILE * 12) end

MAX_DEFENDERS_RADIUS = function () return (TILE * 40) end

MAX_VTOL_DEFEND_RADIUS = function () return (TILE * 25) end

-- AI will remember max this number of structures
MAX_REBUILD_STRUCT = 100

-- Total number of technology branches
TECHS = 2

-- How many best templates to choose from when deciding what template to build
MAX_RANDOM_TEMPLATES = 4

-- player for this instance.
me = 0
-- rate of exploration

-- aim for...


-- technology for different research branches

-- structures
baseX = 0
baseY = 0
minx = 0
miny = 0
maxx = 0
maxy = 0
structChoice = Array(5)
vtolModule = nil
extraStruct = 0

-- unit templates
tmplChoice = Array(5)



numRepairUnits = 0

-- defend
defendGroup = Group()
defendbusy = false
defendObj = nil

research = nil

-- build
buildGroup = Group()
rushGroup = Group()
buildX = 0
buildY = 0

-- scout
scoutGroup = Group()
scoutX = 0
scoutY = 0
scoutTLX = 0
scoutTLY = 0
scoutW = 0
scoutH = 0

-- attack
attackGroup = Group()
attackObj = nil
allOutAttack = nil
vtolGrAttackObj = Array(10)

-- vtols
vtolDefendGr = Group()
vtolAttackGr = Array(10)

-- generic
structure = nil
rebuildObj = Array(100)
droid = nil
feature = nil
baseobj = nil
baseobj2 = nil
count = 0
count2 = 0
result = 0

powerSave = false
_DEBUG = false
bRunning = false
-- Hopefully this will be at least as large as MAX_PLAYERS... Why can't I just use MAX_PLAYERS as the array size?!
-- P.S. And why can't I put a comment on the same line as a #define??!! Gah, who cares if the lua2 branch works, lets switch to it, anyway.
MAX_PLAYERS_HACK = 17
allianceTime = Array(MAX_PLAYERS_HACK)
sender = 0
x = 0
y = 0
beaconX = Array(MAX_PLAYERS_HACK)
beaconY = Array(MAX_PLAYERS_HACK)
tBeacon = Array(MAX_PLAYERS_HACK)
tLastHelpRequest = 0
lastHelpPlayer = 0
tHelp = 0
tHelpTimeout = 0
helpX = 0
helpY = 0
message = nil

defendX = 0
defendY = 0
defendRadius = 0
tDefendStart = 0
tDefendTimeout = 0
defendMoveType = 0
baseRange = 0
curTech = 0
numVtolAttackGroups = 0
numAttackVtols = 0
numDefendVtols = 0
rebuildStructX = Array(MAX_REBUILD_STRUCT)
rebuildStructY = Array(MAX_REBUILD_STRUCT)
countRebuildStruct = 0
rebuildStructStat = Array(MAX_REBUILD_STRUCT)

-- callback global
order = 0
seenAnyAA = false

---------------------------------------------------------------------
-- HouseKeeping
function initialisedEvent()
	local player = 0
	-- initialise
	me = getPlayer("Semperfi")
	_DEBUG = false
	dbgMsgOn(me, _DEBUG)
	
	extraStruct = 0
	numRepairUnits = 0
	allOutAttack = nil
	
	-- when we requested help for the last time
	tLastHelpRequest = -1
	-- we are not currently helping anyone
	lastHelpPlayer = -1
	-- when we started helping last time
	tHelp = -1
	-- time when help times out
	tHelpTimeout = -1
	helpX = -1
	helpY = -1
	defendX = -1
	defendY = -1
	defendRadius = -1
	tDefendStart = -1
	tDefendTimeout = -1
	-- move or scout
	defendMoveType = -1
	seenAnyAA = false
	
	baseRange = 4 * TILE
	
	-- set current research branch
	setTechBranch(-1)
	
	numVtolAttackGroups = 10
	-- num vtols in an attack group
	numAttackVtols = 10
	-- num vtols in an attack group
	numDefendVtols = 5
	
	-- setup build group - all initial droids are in buildgroup!
	groupAddArea(buildGroup, me, 0, 0, (C.mapWidth * 128), (C.mapHeight * 128))
	
	-- note where our base is.
	baseX, baseY = getPlayerStartPosition(me)
	
	-- defence.
	defendbusy = false
	
	-- setup scouts
	structure = getStructure(factory, me)
	if structure ~= nil then
		scoutTLX = structure.x
		scoutTLY = structure.y
	else
		scoutTLX = baseX
		scoutTLY = baseY
	end
	scoutW = 256
	scoutH = 256
	scoutX = scoutTLX
	scoutY = scoutTLY
	
	-- clear the alliance array...
	player = 0
	while player ~= MAX_PLAYERS do
		allianceTime[player] = 0
		player = player + 1
	end
	
	if aiResponsibleForPlayer(me) then
		bRunning = true
	else
		bRunning = false
		shutDownAI()
	end
end
callbackEvent(initialisedEvent, CALL_GAMEINIT)

function dbgPlr(message)
	if me == C.selectedPlayer then
		console(message)
	end
end

function dbgObj(obj, message)
	if obj.selected then
		console(message)
	end
end

function retargetVtol(_me, _droid)
	droid = _droid -- wz2lua: probably these can be used as function arguments directly
	local _obj = nil
	
	if droid ~= nil then
		_obj = getClosestEnemy(droid.x, droid.y, MAX_VTOL_DEFEND_RADIUS(), false, false, me)
		if _obj ~= nil then
			orderDroidObj(droid, DORDER_ATTACK, _obj)
		end
	end
end
callbackEvent(retargetVtol, CALL_VTOL_RETARGET)

-- for debugging
function selectedDroid(_droid)
	droid = _droid -- wz2lua: probably these can be used as function arguments directly
	local groupcount = 0
	
	if not bRunning or me ~= C.selectedPlayer then
		return
	end
	if not hasGroup(droid) then
		console("Not in any group")
	end
	if groupMember(buildGroup, droid) then
		console("In build group")
	end
	if groupMember(rushGroup, droid) then
		console("In rush (forward defense construction) group")
	end
	if groupMember(defendGroup, droid) then
		console("In defend group")
	end
	if groupMember(attackGroup, droid) then
		console("In attack group")
	end
	if groupMember(scoutGroup, droid) then
		console("In scout group")
	end
	if groupMember(vtolDefendGr, droid) then
		console("In VTOL defend group")
	end
	groupcount = 0
	while groupcount < 10 do
		if groupMember(vtolAttackGr[groupcount], droid) then
			console("In VTOL attack group " .. groupcount)
		end
		groupcount = groupcount + 1
	end
end
callbackEvent(selectedDroid, CALL_DROID_SELECTED)

function conCanHelp(mydroid, bx, by)
	return (mydroid.order ~= DORDER_HELPBUILD and mydroid.order ~= DORDER_BUILD and mydroid.order ~= DORDER_LINEBUILD and droidCanReach(mydroid, bx, by))
end

-- I am not sure why we need this hack, but the AI can still end up not researching anything at times
-- Also add hack in case trucks get idle
function checkActivities()
	delayedEvent(doResearch, 0.1)
	delayedEvent(buildFundamentals, 1.3)
end
repeatingEvent(checkActivities, 40.0)

-- Count factories. TODO: Cache this value.
function numFactories()
	initEnumStruct(false, factory, me, me)
	structure = enumStruct()
	count = 0
	while structure ~= nil do
		count = count + 1
		structure = enumStruct()
	end
	return count
end

-- Count VTOL factories. TODO: Cache this value.
function numVtolFactories()
	initEnumStruct(false, vtolFactory, me, me)
	structure = enumStruct()
	count = 0
	while structure ~= nil do
		count = count + 1
		structure = enumStruct()
	end
	return count
end

-- Count cyborg factories. TODO: Cache this value.
function numCyborgFactories()
	initEnumStruct(false, cybFactory, me, me)
	structure = enumStruct()
	count = 0
	while structure ~= nil do
		count = count + 1
		structure = enumStruct()
	end
	return count
end

-- Count research labs. TODO: Cache this value.
function numResearchLabs()
	initEnumStruct(false, resLab, me, me)
	structure = enumStruct()
	count = 0
	while structure ~= nil do
		count = count + 1
		structure = enumStruct()
	end
	return count
end

-- Build something on specific position, grab trucks to do it within tiles range
function grabTrucksAndBuildAt(bx, by, range, bstats)
	local mydroid = nil
	local closestDroid = nil
	local closestDist = 0
	local currDist = 0
	local numHelpDroids = 0
	local tilerange = 0
	
	-- find idle droids in build group.
	initIterateGroup(buildGroup)
	mydroid = iterateGroup(buildGroup)
	closestDist = 99999
	closestDroid = nil
	numHelpDroids = 0
	tilerange = range * TILE
	while mydroid ~= nil do
		currDist = distBetweenTwoPoints(bx, by, mydroid.x, mydroid.y)
		if conCanHelp(mydroid, bx, by) then
			if currDist < tilerange then
				orderDroidStatsLoc(mydroid, DORDER_BUILD, bstats, bx, by)
				numHelpDroids = numHelpDroids + 1
				dbgObj(mydroid, "Asked to do short distance construction at (" .. bx .. ", " .. by .. ")")
			else
				if currDist < closestDist then
					closestDroid = mydroid
					closestDist = currDist
				end
			end
		end
		mydroid = iterateGroup(buildGroup)
	end
	-- found none within help radius, so force someone to go long distance traveling
	if numHelpDroids == 0 and closestDroid ~= nil then
		dbgObj(closestDroid, "Asked to do long distance construction work at (" .. bx .. ", " .. by .. ")")
		-- you, book a plane ticket and go!
		orderDroidStatsLoc(closestDroid, DORDER_BUILD, bstats, bx, by)
		return true
	end
	return (numHelpDroids > 0)
end

-- Build something in main base, grab trucks to do it within tiles range
function grabTrucksAndBuild(range, bstats, maxBlockingTiles)
	local mydroid = nil
	local closestDroid = nil
	local closestDist = 0
	local currDist = 0
	local numHelpDroids = 0
	local tilerange = 0
	local bx = 0
	local by = 0
	
	-- find idle droids in build group.
	initIterateGroup(buildGroup)
	mydroid = iterateGroup(buildGroup)
	closestDist = 99999
	closestDroid = nil
	numHelpDroids = 0
	tilerange = range * TILE
	while mydroid ~= nil do
		if conCanHelp(mydroid, baseX, baseY) then
			bx = baseX
			by = baseY
			__result, bx, by = pickDroidStructLocation(mydroid, bstats, bx, by, me, maxBlockingTiles)
			if __result then
				currDist = distBetweenTwoPoints(bx, by, mydroid.x, mydroid.y)
				if currDist < tilerange then
					orderDroidStatsLoc(mydroid, DORDER_BUILD, bstats, bx, by)
					numHelpDroids = numHelpDroids + 1
					dbgObj(mydroid, "Asked to do short distance construction at (" .. bx .. ", " .. by .. ")")
				else
					if currDist < closestDist then
						closestDroid = mydroid
						closestDist = currDist
					end
				end
			end
		end
		mydroid = iterateGroup(buildGroup)
	end
	-- found none within help radius, so force someone to go long distance traveling
	if numHelpDroids == 0 and closestDroid ~= nil then
		dbgObj(closestDroid, "Asked to do long distance construction work at (" .. bx .. ", " .. by .. ")")
		-- you, book a plane ticket and go!
		orderDroidStatsLoc(closestDroid, DORDER_BUILD, bstats, bx, by)
		return true
	end
	return (numHelpDroids > 0)
end

function arrived(_droid, _order)
	if _droid.player ~= me then return end
	droid, order = _droid, _order -- wz2lua: probably these can be used as function arguments directly
	local found = false
	local myChoice = nil
	
	if groupMember(rushGroup, droid) then
		dbgObj(droid, "Failed to build where we should - (re)start wall building")
		delayedEvent(manicWalls, 0.1)
		return
	end
	
	if droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT and getDifficulty(me) > EASY then
		dbgObj(droid, "Failed to build where we should - attempt to screw up enemy oil derrick")
		
		-- Check if at oil well, and it was taken by enemy
		structure = structureBuiltInRange(derrick, droid.x, droid.y, (5 * 128), -1)
		if structure ~= nil then
			if not friendlyPlayer(structure.player) and droid.health == 100 then
				count = 0
				found = false
				-- find simplest/cheapest one available to build
				while count < numDefStructs and not found do
					if isStructureAvailable(defStructs[count], me) then
						found = true
					else
						count = count + 1
					end
				end
				if found then
					buildX = droid.x
					buildY = droid.y
					if pickDroidStructLocation(droid, defStructs[count], buildX, buildY, me, -1) then
						dbgObj(droid, "Building defense at enemy oil derrick - just to be nasty")
						orderDroidStatsLoc(droid, DORDER_BUILD, defStructs[count], buildX, buildY)
					else
						dbgObj(droid, "Wanted to be nasty, but found nowhere to build defense")
						-- nothing more to do here.
						orderDroid(droid, DORDER_RTB)
					end
				else
					dbgObj(droid, "Wanted to be nasty, but had nothing nasty to build - returning to base")
					-- oh, well. nothing more to do here.
					orderDroid(droid, DORDER_RTB)
				end
				return
			else
				if droid.health < 100 and not insideBase(droid.x, droid.y) then
					dbgObj(droid, "Under fire - bolting back to repair!")
					-- bolt back to base now!
					orderDroid(droid, DORDER_RTR)
					return
				end
			end
		end
	end
end
callbackEvent(arrived, CALL_DROID_REACH_LOCATION)

function tryUpgrade()
	local struct = nil
	
	if isStructureAvailable(powModule, me) then
		initEnumStruct(false, powGen, me, me)
		struct = enumStruct()
		while struct ~= nil do
			if not testStructureModule(me, struct, 0) then
				return grabTrucksAndBuildAt(struct.x, struct.y, 8, powModule)
			end
			struct = enumStruct()
		end
	end
	if isStructureAvailable(facModule, me) then
		initEnumStruct(false, factory, me, me)
		struct = enumStruct()
		while struct ~= nil do
			if not testStructureModule(me, struct, 0) then
				return grabTrucksAndBuildAt(struct.x, struct.y, 10, facModule)
			end
			struct = enumStruct()
		end
		
		initEnumStruct(false, vtolFactory, me, me)
		struct = enumStruct()
		while struct ~= nil do
			if not testStructureModule(me, struct, 0) then
				return grabTrucksAndBuildAt(struct.x, struct.y, 10, facModule)
			end
			struct = enumStruct()
		end
	end
	if isStructureAvailable(resModule, me) then
		initEnumStruct(false, resLab, me, me)
		struct = enumStruct()
		while struct ~= nil do
			if not testStructureModule(me, struct, 0) then
				return grabTrucksAndBuildAt(struct.x, struct.y, 6, resModule)
			end
			struct = enumStruct()
		end
	end
	-- did not succeed in getting ANY droids busy!
	return false
end

-- Manage trucks and other constructors
function buildFundamentals()
	local _oil = nil
	local needPwGen = false
	local iterstruct = nil
	local closeststruct = nil
	local closest = 0
	local proximity = 0
	
	needPwGen = false
	deactivateEvent(buildFundamentals)
	
	-- Do we need power generators?
	if (playerPower(me) < HIGH_POWER * 2 or numFactories() > 1) and numUnusedDerricks() > 0 then
		needPwGen = true
		dbgPlr("More power generators needed")
	end
	
	-- Do we need to get oil?
	if not needPwGen and playerPower(me) < LOW_POWER then
		initGetFeature(oilRes, -1, me)
		_oil = getFeatureB(me)
		if _oil ~= nil then
			dbgPlr("More oil needed - candidate found")
			delayedEvent(buildDerrick, 0.1)
			return
		end
	end
	
	-- Help build unfinished buildings
	-- find idle droids in build group.
	initIterateGroup(buildGroup)
	droid = iterateGroup(buildGroup)
	while droid ~= nil do
		initEnumUnbuilt(me)
		iterstruct = enumUnbuilt()
		closeststruct = nil
		closest = 99999
		while iterstruct ~= nil do
			proximity = distBetweenTwoPoints(droid.x, droid.y, iterstruct.x, iterstruct.y)
			if conCanHelp(droid, iterstruct.x, iterstruct.y) and (not needPwGen or iterstruct.stattype == REF_POWER_GEN or iterstruct.stattype == REF_POWER_MODULE) and (proximity < 50 * TILE) and (proximity < closest) then
				closeststruct = iterstruct
				closest = proximity
			end
			iterstruct = enumUnbuilt()
		end
		if closeststruct ~= nil then
			orderDroidObj(droid, DORDER_HELPBUILD, closeststruct)
			dbgObj(droid, "Aid construction at (" .. closeststruct.x .. ", " .. closeststruct.y .. ")")
			if closeststruct.stattype == REF_POWER_GEN or closeststruct.stattype == REF_POWER_MODULE then
				needPwGen = false
			end
		end
		droid = iterateGroup(buildGroup)
	end
	
	if idleGroup(buildGroup) == 0 then
		return
	end
	
	if needPwGen then
		delayedEvent(buildPowerGenerators, 0.1)
		return
	end
	
	-- If we have power, build up base basics
	if playerPower(me) >= LOW_POWER then
		count = 0
		while count < numFundamental do
			structure = getStructure(structs[count], me)
			-- if missing build it.
			if structure == nil then
				if isStructureAvailable(structs[count], me) then
					if grabTrucksAndBuild(100, structs[count], 0) then
						return
					end
				end
			end
			count = count + 1
		end
	end
	
	if playerPower(me) < LOW_POWER then
		return
	else
		if playerPower(me) < HIGH_POWER or numFactories() > 1 then
			delayedEvent(buildDerrick, 0.1)
			return
		else
			dbgPlr("Too much power - EXPAND!")
			delayedEvent(buildExpand, 0.1)
			return
		end
	end
end

function truckRush()
	local plr = 0
	local target = 0
	local curdist = 0
	local mindist = 0
	local checkX = 0
	local checkY = 0
	local startX = 0
	local startY = 0
	local _oil = nil
	local _closestOil = nil
	local found = false
	
	deactivateEvent(truckRush)
	
	-- Find closest enemy
	plr = 0
	target = -1
	mindist = 999999
	while plr < MAX_PLAYERS do
		if not friendlyPlayer(plr) then
			__result, checkX, checkY = getPlayerStartPosition(plr)
			if __result then
				curdist = distBetweenTwoPoints(baseX, baseY, checkX, checkY)
				if curdist < mindist then
					startX = checkX
					startY = checkY
					mindist = curdist
					target = plr
				end
			end
		end
		plr = plr + 1
	end
	if target == -1 then
		dbgPlr("Failed to find an enemy!")
		-- oops.
		return
	end
	dbgPlr("Rushing player " .. target)
	
	-- Reserve droids
	groupAddGroup(rushGroup, buildGroup)
	
	-- Find oil well closest to closest enemy
	mindist = 999999
	_closestOil = nil
	initIterateGroup(rushGroup)
	droid = iterateGroup(rushGroup)
	initGetFeature(oilRes, -1, me)
	_oil = getFeatureB(me)
	while droid ~= nil and _oil ~= nil do
		curdist = distBetweenTwoPoints(startX, startY, _oil.x, _oil.y)
		-- Find the closest oil to target player that we can reach safely, and that he can reach safely as well
		if curdist < mindist and droidCanReach(droid, _oil.x, _oil.y) and safeDest(me, _oil.x, _oil.y) and safeDest(target, _oil.x, _oil.y) then
			mindist = curdist
			_closestOil = _oil
		end
		_oil = getFeatureB(me)
	end
	if _closestOil == nil then
		dbgPlr("No hostile oil found to rush (or no trucks available)")
		-- reverse
		groupAddGroup(buildGroup, rushGroup)
		return
	end
	
	-- Pick best defense
	-- reusing this var to find best def
	mindist = numDefStructs - 1
	found = false
	while mindist > 0 and not found do
		if isStructureAvailable(defStructs[mindist], me) then
			found = true
		else
			mindist = mindist - 1
		end
	end
	
	-- Pick location for defensive building near for our trucks
	buildX = _closestOil.x
	buildY = _closestOil.y
	if not found or not pickDroidStructLocation(droid, defStructs[mindist], buildX, buildY, me, -1) then
		dbgPlr("Failed to find defense, or failed to find placement for it")
		-- reverse
		groupAddGroup(buildGroup, rushGroup)
		return
	end
	
	-- Build hostilities
	while droid ~= nil do
		orderDroidStatsLoc(droid, DORDER_BUILD, defStructs[mindist], buildX, buildY)
		droid = iterateGroup(rushGroup)
	end
end

-- Try to wall in the enemy with wall defenses at random gateways
function manicWalls()
	local weap = 0
	local tempx = 0
	local tempy = 0
	local found = false
	
	deactivateEvent(manicWalls)
	
	-- choose best hardpoint type
	weap = numWallWeaps - 1
	found = false
	while weap > 0 and not found do
		if isStructureAvailable(wallWeaps[weap], me) then
			found = true
		else
			weap = weap - 1
		end
	end
	if not found then
		dbgPlr("Had no wall weapons to build to wall in enemy")
		-- reverse
		groupAddGroup(buildGroup, rushGroup)
		return
	end
	
	-- Go build on gateways near enemy base
	initIterateGroup(rushGroup)
	droid = iterateGroup(rushGroup)
	while droid ~= nil do
		tempx = droid.x
		tempy = droid.y
		if not skDefenseLocationB(tempx, tempy, wall, wallWeaps[weap], droid, me) then
			dbgPlr("Manic wall building ran into an error - stopped")
			-- reverse
			groupAddGroup(buildGroup, rushGroup)
			return
		end
		droid = iterateGroup(rushGroup)
	end
end

function startLevel()
	delayedEvent(conDroids, 0.1)
	delayedEvent(doResearch, 0.1)
	if numFactories() > 1 and isStructureAvailable(defStructs[0], me) and getDifficulty(me) > MEDIUM then
		dbgPlr("TRUCK RUSH!")
		delayedEvent(truckRush, 0.1)
	else
		delayedEvent(buildFundamentals, 0.1)
	end
	deactivateEvent(startLevel)
end
callbackEvent(startLevel, CALL_START_NEXT_LEVEL)

-- decide what technology branch we will use
function setTechBranch(_tech)
	local _y2 = 0
	local _y1 = 0
	local _x2 = 0
	local _x1 = 0
	local _a = 0
	local _y = 0
	local _m = 0
	local _rnd = 0
	local _mapSize = 0
	
	_mapSize = ((C.mapWidth + C.mapHeight) / 2)
	
	if _tech ~= -1 then
		curTech = _tech
	else
		_x1 = 90.0
		_y1 = 0.0
		_x2 = 200.0
		_y2 = 45.0
		_m = ((_y2 - _y1) / (_x2 - _x1))
		_a = -(_m * _x1)
		
		-- calculate probability for the current map
		_y = _m * _mapSize + _a
		
		dbg("_m = " .. _m .. ", a = " .. _a, me)
		
		_rnd = random(100)
		if _rnd < _y then
			curTech = branchVTOL
			dbgPlr("going air (" .. _y .. "/" .. _rnd .. ")")
		else
			curTech = branchDefault
			dbgPlr("going land (" .. _y .. "/" .. _rnd .. ")")
		end
	end
end

-- returns TRUE if AI is responsible for the _player
function aiResponsibleForPlayer(_player)
	if not _DEBUG and ((_player == C.selectedPlayer) or not myResponsibility(_player)) then
		return false
	end
	
	return true
end

---------------------------------------------------------------------
-- keep details about the size and postion of the ai players base
function basedetails()
	local result = 0
	
	-- clear old extremities.
	maxy = 0
	maxx = 0
	miny = (C.mapHeight * 128)
	minx = (C.mapWidth * 128)
	
	baseRange = 4 * TILE
	
	-- now find the extremities of our vital structures.
	count = 0
	while count < numBaseStruct do
		initEnumStruct(false, baseStruct[count], me, me)
		structure = enumStruct()
		while structure ~= nil do
			if structure.x < minx then
				minx = structure.x
			end
			if structure.x > maxx then
				maxx = structure.x
			end
			if structure.y < miny then
				miny = structure.y
			end
			if structure.y > maxy then
				maxy = structure.y
			end
			
			result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y)
			
			if result > baseRange then
				baseRange = result
			end
			
			structure = enumStruct()
		end
		
		count = count + 1
	end
	
	result = 3 * 128
	minx = minx - result
	maxx = maxx + result
	miny = miny - result
	maxy = maxy + result
	
	baseRange = baseRange + (4 * 128)
end
repeatingEvent(basedetails, 60.0)

-- If positive, there are oil derricks that unused due to lack of power generators.
-- If negative, we have too many power generator (usually not a problem in itself).
function numUnusedDerricks()
	initEnumStruct(false, derrick, me, me)
	structure = enumStruct()
	count = 0
	while structure ~= nil do
		count = count + 1
		structure = enumStruct()
	end
	-- count2 = numpowgens
	initEnumStruct(false, powGen, me, me)
	structure = enumStruct()
	count2 = 0
	while structure ~= nil do
		count2 = count2 + 1
		structure = enumStruct()
	end
	return (count - (count2 * 4))
end

---------------------------------------------------------------------
-- structure building rules

-- build derricks on oil.
function buildDerrick()
	local foundOne = false
	local _same = false
	local _oil = nil
	local _closestOil = nil
	local _bestDist = 0
	local _newDist = 0
	local _search = nil
	
	_bestDist = 99999
	_closestOil = nil
	foundOne = false
	-- find all units in build group
	initIterateGroup(buildGroup)
	droid = iterateGroup(buildGroup)
	while droid ~= nil and not foundOne do
		if droid.order ~= DORDER_BUILD and droid.order ~= DORDER_LINEBUILD and droid.order ~= DORDER_HELPBUILD then
			foundOne = true
		else
			droid = iterateGroup(buildGroup)
		end
	end
	if droid ~= nil then
		initGetFeature(oilRes, -1, me)
		_oil = getFeatureB(me)
		while _oil ~= nil do
			_newDist = distBetweenTwoPoints(droid.x, droid.y, _oil.x, _oil.y)
			_same = false
			
			-- this one is closer
			if _newDist < _bestDist and droidCanReach(droid, _oil.x, _oil.y) and safeDest(me, _oil.x, _oil.y) then
				initIterateGroup(buildGroup)
				_search = iterateGroup(buildGroup)
				foundOne = false
				while _search ~= nil and not foundOne do
					if _search.orderx == _oil.x and _search.ordery == _oil.y and _search ~= droid then
						_same = true
						foundOne = true
					end
					_search = iterateGroup(buildGroup)
				end
				-- do not go to same spot as another droid
				if not _same then
					_bestDist = _newDist
					_closestOil = _oil
				end
			end
			_oil = getFeatureB(me)
		end
		if _closestOil ~= nil then
			orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _closestOil.x, _closestOil.y)
			dbgObj(droid, "Off to build derrick at (" .. _closestOil.x .. ", " .. _closestOil.y .. ")")
			if idleGroup(buildGroup) > 0 then
				delayedEvent(buildDerrick, 1.3)
				return
			end
		else
			if not tryUpgrade() then
				delayedEvent(buildOilDefenseOrRetreat, 0.1)
			end
		end
	end
	deactivateEvent(buildDerrick)
end

---------------------------------------------------------------------
-- if idle and derrick in range and no defense then build defense, else ret to base .
function buildOilDefenseOrRetreat()
	local _numBuilders = 0
	local _maxBuilders = 0
	
	_maxBuilders = 1
	
	-- check idle.
	-- find idle droids in build group.
	initIterateGroup(buildGroup)
	droid = iterateGroup(buildGroup)
	while droid ~= nil do
		if droid.order ~= DORDER_BUILD and droid.order ~= DORDER_LINEBUILD and droid.order ~= DORDER_HELPBUILD then
			structure = structureBuiltInRange(derrick, droid.x, droid.y, (5 * 128), me)
			
			-- if inside base limits then presume ok..
			if structure ~= nil then
				if (structure.x > minx) and (structure.y > miny) and (structure.x < maxx) and (structure.y < maxy) then
					structure = nil
				end
			end
			
			if structure ~= nil then
				buildX = structure.x
				buildY = structure.y
				
				-- not many defenses nearby
				if numFriendlyWeapStructsInRange(me, buildX, buildY, (3 * 128), false) < 2 then
					count = numDefStructs - 1
					count2 = 0
					while (count2 < 5) and (count >= 0) do
						if isStructureAvailable(defStructs[count], me) then
							structChoice[count2] = defStructs[count]
							count2 = count2 + 1
						end
						count = count - 1
					end
					count = 0
					if count2 > 0 then
						count = random(count2)
						
						-- pick a location
						__result, buildX, buildY = pickDroidStructLocation(droid, structChoice[count], buildX, buildY, me, 1)
						if __result then
							_numBuilders = numBuildSameBuilding(NULLSTRUCTURESTAT, buildX, buildY)
							
							if _numBuilders < _maxBuilders then
								orderDroidStatsLoc(droid, DORDER_BUILD, structChoice[count], buildX, buildY)
								_numBuilders = _numBuilders + 1
							end
						end
					end
				else
					structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5 * 128), me)
					if structure == nil then
						if not insideBase(droid.x, droid.y) then
							orderDroid(droid, DORDER_RTB)
						end
					end
				end
			else
				structure = structureBuiltInRange(playerHQ, droid.x, droid.y, (5 * 128), me)
				if structure == nil then
					if not insideBase(droid.x, droid.y) then
						orderDroid(droid, DORDER_RTB)
					end
				end
			end
		end
		droid = iterateGroup(buildGroup)
	end
	if idleGroup(buildGroup) > 0 then
		delayedEvent(buildExpand, 0.1)
	end
	deactivateEvent(buildOilDefenseOrRetreat)
end

---------------------------------------------------------------------
-- mortar etc.. rules. build sensor towers and emplacements.
function incendry()
	local result = 0
	local boolResult = false
	local structure2 = nil
	
	initEnumStruct(false, sensorTower, me, me)
	
	count = 0
	structure = enumStruct()
	while structure ~= nil do
		count = count + 1
		structure = enumStruct()
	end
	
	-- every 7 mins
	if count < (C.gameTime / 4200) then
		buildX = 0
		buildY = 0
		initEnumStruct(false, derrick, me, me)
		structure = enumStruct()
		while structure ~= nil do
			count = 0
			result = 0
			while count < numDefStructs do
				structure2 = structureBuiltInRange(defStructs[count], structure.x, structure.y, (4 * 128), me)
				if structure2 ~= nil then
					result = result + 1
				end
				count = count + 1
			end
			
			-- check for sensor nearby,
			structure2 = structureBuiltInRange(sensorTower, structure.x, structure.y, (5 * 128), me)
			if structure2 ~= nil then
				result = 4
			end
			
			if result < 3 then
				buildX = structure.x
				buildY = structure.y
				structure = nil
			else
				structure = enumStruct()
			end
		end
		
		if buildX ~= 0 then
			boolResult, buildX, buildY = pickStructLocation(sensorTower, buildX, buildY, me)
			if boolResult == true then
				initIterateGroup(buildGroup)
				droid = iterateGroup(buildGroup)
				while droid ~= nil do
					if (droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY) then
						orderDroidStatsLoc(droid, DORDER_BUILD, sensorTower, buildX, buildY)
						droid = nil
					else
						droid = iterateGroup(buildGroup)
					end
				end
			end
		end
	else
		buildX = 0
		buildY = 0
		
		initEnumStruct(false, sensorTower, me, me)
		structure = enumStruct()
		count = 999
		while structure ~= nil do
			result = 0
			count2 = 0
			while count2 < numIncendrys do
				structure2 = structureBuiltInRange(incendrys[count2], structure.x, structure.y, (4 * 128), me)
				if structure2 ~= nil then
					result = result + 1
				end
				count2 = count2 + 1
			end
			
			-- lowest found yet. only sites with <6 too.
			if (result < 6) and (result < count) then
				buildX = structure.x
				buildY = structure.y
				count = result
			end
			structure = enumStruct()
		end
		
		if buildX ~= 0 then
			count = numIncendrys - 1
			result = 99
			while count >= 0 do
				if isStructureAvailable(incendrys[count], me) then
					result = count
					count = -1
				else
					count = count - 1
				end
			end
			
			-- find a unit and build an incendry device.
			if result ~= 99 then
				boolResult, buildX, buildY = pickStructLocation(incendrys[result], buildX, buildY, me)
				if boolResult == true then
					initIterateGroup(buildGroup)
					droid = iterateGroup(buildGroup)
					
					-- anyone building there already?
					boolResult = (numBuildSameBuilding(incendrys[result], buildX, buildY) > 0)
					
					while droid ~= nil and (not boolResult) do
						if (droid.order == DORDER_NONE or droid.order == DORDER_RTB) and droidCanReach(droid, buildX, buildY) then
							orderDroidStatsLoc(droid, DORDER_BUILD, incendrys[result], buildX, buildY)
							-- only 1 truck
							boolResult = true
						end
						droid = iterateGroup(buildGroup)
					end
				end
			end
		end
	end
	deactivateEvent(incendry)
end

---------------------------------------------------------------------
-- build a power gen for every 4 derricks. VITAL!
function buildPowerGenerators()
	if isStructureAvailable(powGen, me) then
		if not grabTrucksAndBuild(20, powGen, 1) then
			dbgPlr("Needed power generator but could not build one")
		end
	end
	deactivateEvent(buildPowerGenerators)
end

---------------------------------------------------------------------
-- build other stuff, grow the base slowly...
function buildExpand()
	local factories = 0
	local reslabs = 0
	local vtolfacs = 0
	local cybfacs = 0
	local total = 0
	
	deactivateEvent(buildExpand)
	
	if playerPower(me) < LOW_POWER then
		return
	end
	
	-- Try to keep some balance to the madness
	factories = numFactories()
	reslabs = numResearchLabs()
	vtolfacs = numVtolFactories()
	cybfacs = numCyborgFactories()
	total = factories + reslabs + vtolfacs + cybfacs
	
	if playerPower(me) > LOW_POWER * total then
		dbgPlr("EXPAND! factories=" .. factories .. " vtolfacs=" .. vtolfacs .. " cybfacs=" .. cybfacs .. " reslabs=" .. reslabs)
		buildX = baseX
		buildY = baseY
		if isStructureAvailable(cybFactory, me) and (cybfacs < factories) then
			if grabTrucksAndBuild(10, cybFactory, 0) then
				dbgPlr("Building more cyborg factories")
			end
			return
		end
		if isStructureAvailable(resLab, me) and (reslabs < factories) then
			if grabTrucksAndBuild(10, resLab, 0) then
				dbgPlr("Building more research labs")
			end
			return
		end
		if isStructureAvailable(vtolFactory, me) and (vtolfacs < factories) then
			if grabTrucksAndBuild(10, vtolFactory, 0) then
				dbgPlr("Building more VTOL factories")
			end
			return
		end
		if isStructureAvailable(factory, me) and (factories < vtolfacs + cybfacs + reslabs + 1) then
			if grabTrucksAndBuild(25, factory, 0) then
				dbgPlr("Building more factories")
			end
			return
		end
	end
	
	if idleGroup(buildGroup) > 0 then
		delayedEvent(newfortify, 1.3)
	end
	
	extraStruct = extraStruct + 1
end

---------------------------------------------------------------------
-- fortify base by builiding defensive structs on the edge of the base.
-- rewrote fortify to use scrSkDefenseLocation(baseX,baseY,me);
function newfortify()
	local _numBuilders = 0
	local _maxBuilders = 0
	local tempx = 0
	local tempy = 0
	local boolResult = false
	
	_maxBuilders = 1
	deactivateEvent(newfortify)
	
	-- only gateway fortifications use line build
	if numGroupSameOrder(buildGroup, DORDER_LINEBUILD) < _maxBuilders then
		boolResult = false
		-- find idle an idle veh.in build group.
		initIterateGroup(buildGroup)
		droid = iterateGroup(buildGroup)
		while (boolResult == false) and (droid ~= nil) do
			if droid.order ~= DORDER_BUILD and droid.order ~= DORDER_LINEBUILD and droid.order ~= DORDER_HELPBUILD then
				boolResult = true
				
				tempx = baseX
				tempy = baseY
				
				-- choose a suitable turret.
				count = numWallWeaps - 1
				count2 = 0
				while (count2 < 3) and (count >= 0) do
					if isStructureAvailable(wallWeaps[count], me) then
						structChoice[count2] = wallWeaps[count]
						count2 = count2 + 1
					end
					count = count - 1
				end
				count = 0
				if (count2 > 0) and (_numBuilders < _maxBuilders) then
					count = random(count2)
					UNUSED, tempx, tempy = skDefenseLocationB(tempx, tempy, wall, structChoice[count], droid, me)
					_numBuilders = _numBuilders + 1
				end
			end
			
			droid = iterateGroup(buildGroup)
		end
	end
	if idleGroup(buildGroup) > 0 and not tryUpgrade() then
		dbgPlr("No more base defenses to build - trying to build incedry")
		delayedEvent(incendry, 1.3)
	end
end

---------------------------------------------------------------------
-- droid building rules
---------------------------------------------------------------------
-- deal with a droid being built
function droidBuiltAssign(_droid, _structure)
	if _droid.player ~= me then return end
	droid, structure = _droid, _structure -- wz2lua: probably these can be used as function arguments directly
	if isVtol(droid) then
		if groupCountMembers(vtolDefendGr) < numDefendVtols then
			groupAddDroid(vtolDefendGr, droid)
		else
			count = 0
			while count < numVtolAttackGroups do
				if groupCountMembers(vtolAttackGr[count]) < numAttackVtols then
					dbg("added new vtol to group " .. count, me)
					groupAddDroid(vtolAttackGr[count], droid)
					count = numVtolAttackGroups
				end
				count = count + 1
			end
		end
	else
		if (droid.droidType ~= DROID_TRANSPORTER) and (droid.droidType ~= DROID_COMMAND) then
			if (droid.droidType == DROID_REPAIR) or (droid.droidType == DROID_CYBORG_REPAIR) then
				numRepairUnits = numRepairUnits + 1
			end
			
			if (droid.droidType == DROID_CONSTRUCT) or (droid.droidType == DROID_CYBORG_CONSTRUCT) then
				groupAddDroid(buildGroup, droid)
			else
				if droid.droidType == DROID_CYBORG then
					groupAddDroid(defendGroup, droid)
				else
					if groupCountMembers(scoutGroup) < numScouts then
						groupAddDroid(scoutGroup, droid)
					else
						if groupCountMembers(attackGroup) < numAttackers[curTech] then
							groupAddDroid(attackGroup, droid)
						else
							if groupCountMembers(defendGroup) < numDefenders[curTech] then
								groupAddDroid(defendGroup, droid)
							else
								if groupCountMembers(scoutGroup) < maxScouts then
									groupAddDroid(scoutGroup, droid)
								else
									if groupCountMembers(attackGroup) < maxAttackers[curTech] then
										groupAddDroid(attackGroup, droid)
									else
										if groupCountMembers(defendGroup) < maxDefenders[curTech] then
											groupAddDroid(defendGroup, droid)
										else
											groupAddDroid(attackGroup, droid)
										end
									end
								end
							end
						end
					end
				end
			end
		end
	end
end
callbackEvent(droidBuiltAssign, CALL_NEWDROID)

-- When droid built: check emergency jobs, start building next droid
function droidBuilt(_droid, _structure)
	if _droid.player ~= me then return end
	droid, structure = _droid, _structure -- wz2lua: probably these can be used as function arguments directly
	local _fundie = nil
	
	if droid.droidType == DROID_CONSTRUCT then
		delayedEvent(buildFundamentals, 0.1)
	end
	
	-- Start building next droid
	if structure ~= nil then
		if droid.droidType == DROID_CONSTRUCT and structure.stattype == REF_FACTORY then
			delayedEvent(conDroids, 0.1)
		else
			-- Continue building new droids right away
			if structure.stattype == REF_FACTORY then
				factoryBuildDroid(structure)
			else
				if structure.stattype == REF_CYBORG_FACTORY then
					cybFactorBuildCyborg(structure)
				else
					if structure.stattype == REF_VTOL_FACTORY then
						vtolFactoryBuildVtol(structure)
					end
				end
			end
		end
	end
end
callbackEvent(droidBuilt, CALL_NEWDROID)

-- Gets triggered when structure was built
function structBuilt(_droid, _structure)
	if _droid.player ~= me then return end
	droid, structure = _droid, _structure -- wz2lua: probably these can be used as function arguments directly
	local _oilResource = nil
	local _count = 0
	local _count2 = 0
	
	if structure == nil or droid == nil then
		return
	end
	
	-- Try to do more nasty things with rush group
	if groupMember(rushGroup, droid) then
		if isStructureAvailable(wallWeaps[0], me) then
			dbgPlr("Manic wall code triggered")
			-- try to wall in enemy
			delayedEvent(manicWalls, 0.1)
			return
		else
			dbgPlr("Nothing more to do for rush group - disbanding it!")
			groupAddGroup(buildGroup, rushGroup)
			delayedEvent(buildFundamentals, 0.1)
			return
		end
	end
	
	-- factory or factory module
	if structure.stattype == REF_FACTORY then
		if isStructureAvailable(facModule, me) and (skGetFactoryCapacity(structure) < 2) and (getDroidCount(me) > 4) then
			orderDroidStatsLoc(droid, DORDER_BUILD, facModule, structure.x, structure.y)
		else
			delayedEvent(conDroids, 0.1)
		end
	else
		-- vtol factory or vtol factory module
		if structure.stattype == REF_VTOL_FACTORY then
			if isStructureAvailable(facModule, me) and (skGetFactoryCapacity(structure) < 2) then
				orderDroidStatsLoc(droid, DORDER_BUILD, facModule, structure.x, structure.y)
			end
		else
			if structure.stattype == REF_RESOURCE_EXTRACTOR then
				delayedEvent(buildDerrick, 0.1)
				return
			else
				if structure.stattype == REF_RESEARCH then
					if isStructureAvailable(resModule, me) then
						orderDroidStatsLoc(droid, DORDER_BUILD, resModule, structure.x, structure.y)
					else
						delayedEvent(doResearch, 0.1)
					end
				else
					if structure.stattype == REF_POWER_GEN then
						if isStructureAvailable(powModule, me) then
							orderDroidStatsLoc(droid, DORDER_BUILD, powModule, structure.x, structure.y)
						end
					end
				end
			end
		end
	end
	
	-- Check if available trucks need to build more absolute necessities right away. We need a trigger here because
	-- droids involved in building have not yet come out of their build orders.
	delayedEvent(buildFundamentals, 0.1)
	
	-- see if we have just rebuilt a destroyed structure
	_count = 0
	while _count < countRebuildStruct do
		if structure.x == rebuildStructX[_count] and structure.y == rebuildStructY[_count] and ((structure.stat == rebuildStructStat[_count]) or ((structure.stat == wall or structure.stat == cornerWall) and (rebuildStructStat[_count] == wall or rebuildStructStat[_count] == cornerWall))) then
			dbg("finished rebuilding destroyed structure - " .. _count, me)
			
			-- resort destroyed structures
			_count2 = _count
			while _count2 < (countRebuildStruct - 1) do
				rebuildStructX[_count2] = rebuildStructX[_count2 + 1]
				rebuildStructY[_count2] = rebuildStructY[_count2 + 1]
				rebuildStructStat[_count2] = rebuildStructStat[_count2 + 1]
				
				_count2 = _count2 + 1
			end
			
			-- clear last entry
			rebuildStructX[countRebuildStruct - 1] = 0
			rebuildStructY[countRebuildStruct - 1] = 0
			rebuildStructStat[countRebuildStruct - 1] = NULLSTRUCTURESTAT
			
			-- we just built one structure
			countRebuildStruct = countRebuildStruct - 1
		end
		
		-- _count = countRebuildStruct;	//exit outer loop
		_count = _count + 1
	end
end
callbackEvent(structBuilt, CALL_STRUCTBUILT)

---------------------------------------------------------------------
-- deal with attacks.
function droidDestroyed(_droid)
	if _droid.player ~= me then return end
	droid = _droid -- wz2lua: probably these can be used as function arguments directly
	if droid.droidType == DROID_REPAIR then
		numRepairUnits = numRepairUnits - 1
	end
	
	-- if constructor droid
	if droid.droidType == DROID_CONSTRUCT then
		initEnumStruct(false, factory, me, me)
		-- find factory.
		structure = enumStruct()
		
		if (structure ~= nil) and (getDroidCount(me) < MAX_DROIDS) then
			buildDroid(constructor, structure, me, 1)
		end
	end
end
callbackEvent(droidDestroyed, CALL_DROID_DESTROYED)


---------------------------------------------------------------------
-- build more con droids.
function conDroids()
	local _maxTrucks = 0
	local _factory = nil
	local _numBuilding = 0
	local _haveTrucks = 0
	local _maxTruckFactories = 0
	local _totalTrucks = 0
	local _bStartedBuilding = false
	
	_maxTrucks = MAX_TRUCKS
	if playerPower(me) < LOW_POWER then
		_maxTrucks = MIN_TRUCKS
	end
	
	-- max factories to use for truck production
	_maxTruckFactories = 3
	
	_haveTrucks = groupCountMembers(buildGroup)
	
	-- Find out how many trucks and combat engineers are already in production
	-- trucks
	_numBuilding = numTemplatesInProduction(constructor, me)
	-- engineers
	_numBuilding = _numBuilding + numTemplatesInProduction(cybEngineer, me)
	
	_totalTrucks = _numBuilding + _haveTrucks
	
	initEnumStruct(false, factory, me, me)
	_factory = enumStruct()
	
	while (_factory ~= nil) and (_numBuilding < _maxTruckFactories) and (_totalTrucks < _maxTrucks) do
		if skCanBuildTemplate(me, _factory, hovertruck) then
			_bStartedBuilding = buildUnit(hovertruck, _factory, factory, false)
		else
			_bStartedBuilding = buildUnit(constructor, _factory, factory, false)
		end
		
		-- Update statistics if started building a truck
		if _bStartedBuilding then
			_numBuilding = _numBuilding + 1
			_totalTrucks = _totalTrucks + 1
		end
		
		_factory = enumStruct()
	end
	
	-- build cyborg engineers if needed, no building structure limit here
	initEnumStruct(false, cybFactory, me, me)
	_factory = enumStruct()
	while (_factory ~= nil) and (_totalTrucks < _maxTrucks) do
		if skCanBuildTemplate(me, _factory, cybEngineer) then
			_bStartedBuilding = buildUnit(cybEngineer, _factory, cybFactory, false)
			
			-- Update statistics if started building a cyborg engineer
			if _bStartedBuilding then
				_numBuilding = _numBuilding + 1
				_totalTrucks = _totalTrucks + 1
			end
		end
		
		_factory = enumStruct()
	end
	repeatingEvent(conDroids, 90.0)
end
repeatingEvent(conDroids, 90.0)

-- Build a droid
function buildUnit(_tankTemplate, _factory, _factoryType, _bIdleOnly)
	if _factory == nil then
		_factory = findIdleStructure(_factoryType, _bIdleOnly)
	end
	
	-- Build if got a factory
	if _factory ~= nil then
		if structureComplete(_factory) and (getDroidCount(me) < MAX_DROIDS) then
			if not (_bIdleOnly and not structureIdle(_factory)) then
				buildDroid(_tankTemplate, _factory, me, 1)
				-- success
				return true
			end
		end
	end
	
	-- failed
	return false
end

-- Returns an idle structure of the provided type or NULLOBJECT if none found
function findIdleStructure(_structType, _bIdleOnly)
	local _structure = nil
	
	initEnumStruct(false, _structType, me, me)
	_structure = enumStruct()
	while _structure ~= nil do
		if structureComplete(_structure) then
			if not (_bIdleOnly and not structureIdle(_structure)) then
				return _structure
			end
		end
		
		_structure = enumStruct()
	end
	
	-- none found
	return nil
end

---------------------------------------------------------------------
-- build repair droids.
function repairDroids()
	if numRepairUnits < 3 then
		initEnumStruct(false, factory, me, me)
		-- find factory.
		structure = enumStruct()
		if (structure ~= nil) and (getDroidCount(me) < MAX_DROIDS) then
			buildDroid(repairUnit, structure, me, 1)
		end
	end
end
repeatingEvent(repairDroids, 260.0)


---------------------------------------------------------------------
function factoryEvent()
	initEnumStruct(false, factory, me, me)
	-- find factory.
	structure = enumStruct()
	if getDroidCount(me) < MAX_DROIDS then
		while structure ~= nil do
			if structureIdle(structure) then
				factoryBuildDroid(structure)
			end
			
			structure = enumStruct()
		end
	end
end
repeatingEvent(factoryEvent, 17.0)

function needTank()
	if (groupCountMembers(defendGroup) < maxDefenders[curTech]) or (maxDefenders[curTech] == UNLIMITED) then
		return true
	end
	
	if (groupCountMembers(scoutGroup) < maxScouts) or (maxScouts == UNLIMITED) then
		return true
	end
	
	if (groupCountMembers(attackGroup) < maxAttackers[curTech]) or (maxAttackers[curTech] == UNLIMITED) then
		return true
	end
	
	return false
end

function factoryBuildDroid(_factory)
	local _count = 0
	local _count2 = 0
	
	if _factory == nil then
		dbgPlr("factoryBuildDroid: factory is NULLOBJECT")
		return
	end
	
	if not needTank() then
		dbgPlr("factoryBuildDroid: NEED NO TANKS!! limit=" .. maxDefenders[curTech])
		return
	end
	
	if structureIdle(_factory) then
		_count = numTemplates - 1
		_count2 = 0
		while (_count2 < MAX_RANDOM_TEMPLATES) and (_count >= 0) do
			if skCanBuildTemplate(me, _factory, tmpl[_count]) then
				tmplChoice[_count2] = tmpl[_count]
				_count2 = _count2 + 1
			end
			_count = _count - 1
		end
		
		if _count2 > 0 then
			buildDroid(tmplChoice[random(_count2)], _factory, me, 1)
		end
	else
		dbgPlr("factoryBuildDroid: Factory is busy!")
	end
end

---------------------------------------------------------------------
-- put cyborg factories to work
function cyborgFactoryEvent()
	if not ((groupCountMembers(defendGroup) < maxCyborgs) or (maxCyborgs == UNLIMITED)) then
		return
	end
	
	initEnumStruct(false, cybFactory, me, me)
	-- find factory.
	structure = enumStruct()
	
	while structure ~= nil do
		if structureIdle(structure) == true then
			cybFactorBuildCyborg(structure)
		end
		-- find factory.
		structure = enumStruct()
	end
end
repeatingEvent(cyborgFactoryEvent, 17.0)

function cybFactorBuildCyborg(_factory)
	if _factory == nil then
		dbg("cybFactorBuildCyborg: factory is NULLOBJECT", me)
		return
	end
	
	if structureIdle(_factory) then
		if (groupCountMembers(defendGroup) < maxCyborgs) and (getDroidCount(me) < MAX_DROIDS) then
			if random(5) == 1 then
				buildDroid(cybMechanic, _factory, me, 1)
			else
				count = 3
				count2 = 0
				while count >= 0 do
					if skCanBuildTemplate(me, _factory, superCyb[count]) then
						tmplChoice[count2] = superCyb[count]
						count2 = count2 + 1
					end
					count = count - 1
				end
				
				if count2 > 0 then
					buildDroid(tmplChoice[random(count2)], _factory, me, 1)
				else
					count = numLightCyborgs - 1
					count2 = 0
					while (count >= 0) and (count2 < 2) do
						if skCanBuildTemplate(me, _factory, cybTempl[count]) then
							tmplChoice[count2] = cybTempl[count]
							count2 = count2 + 1
						end
						count = count - 1
					end
					if count2 > 0 then
						buildDroid(tmplChoice[random(count2)], _factory, me, 1)
					end
				end
			end
		end
	end
end



---------------------------------------------------------------------
---------------------------------------------------------------------
-- scouting rules

-- scout an area
function chooseScoutArea()
	scoutX = scoutTLX + random(scoutW)
	scoutY = scoutTLY + random(scoutH)
end
repeatingEvent(chooseScoutArea, 20.0)

---------------------------------------------------------------------
-- visit new places

function expandScoutArea()
	scoutTLX = scoutTLX - ((C.mapWidth * 128) / tileExpand)
	scoutTLY = scoutTLY - ((C.mapHeight * 128) / tileExpand)
	scoutW = scoutW + (2 * ((C.mapWidth * 128) / tileExpand))
	scoutH = scoutH + (2 * ((C.mapHeight * 128) / tileExpand))
	
	-- check & restrain.
	if scoutTLX < 1 then
		scoutTLX = 1
	end
	if scoutTLY < 1 then
		scoutTLY = 1
	end
	
	if scoutTLX > (C.mapWidth * 128) then
		scoutTLX = (C.mapWidth * 128) - 128
	end
	if scoutTLY > (C.mapHeight * 128) then
		scoutTLY = (128 * C.mapHeight) - 128
	end
	
	if (scoutTLX + scoutW) > (128 * C.mapWidth) then
		scoutW = ((128 * C.mapWidth) - scoutTLX) - 128
	end
	if (scoutTLY + scoutH) > (128 * C.mapHeight) then
		scoutH = ((128 * C.mapHeight) - scoutTLY) - 128
	end
end
repeatingEvent(expandScoutArea, 60.0)

---------------------------------------------------------------------
-- order scouts

function scoutMain()
	if idleGroup(scoutGroup) >= (groupCountMembers(scoutGroup) / 2) then
		orderGroupLoc(scoutGroup, DORDER_MOVE, scoutX, scoutY)
	end
end
repeatingEvent(scoutMain, 15.0)

---------------------------------------------------------------------
-- process new visibility reports
function newObjectReport(_baseobj, _baseobj2)
	if _baseobj2.player ~= me then return end
	baseobj, baseobj2 = _baseobj, _baseobj2 -- wz2lua: probably these can be used as function arguments directly
	if not friendlyPlayer(baseobj.player) then
		if targetTypeValue(baseobj) > targetTypeValue(attackObj) then
			attackObj = baseobj
			
			if attackObj.type == OBJ_STRUCTURE then
				if not allianceExistsBetween(attackObj.player, me) then
					structure = objToStructure(attackObj)
					if structure.stat == factory then
						allOutAttack = attackObj
					end
				end
			end
		end
	end
end
callbackEvent(newObjectReport, CALL_OBJ_SEEN)

function targetTypeValue(_target)
	local _strTarget = nil
	
	if _target == nil then
		return NO_TARGET_VALUE
	end
	
	if _target.type == OBJ_DROID then
		return DROID_TARGET_VALUE
	else
		if _target.type == OBJ_STRUCTURE then
			_strTarget = objToStructure(_target)
			
			if _strTarget.stattype == REF_DEFENSE then
				return DEFENSE_TARGET_VALUE
			else
				if _strTarget.stattype == REF_RESEARCH or _strTarget.stattype == REF_POWER_GEN then
					return RESEARCH_TARGET_VALUE
				else
					if _strTarget.stattype == REF_HQ or _strTarget.stattype == REF_COMMAND_CONTROL then
						return HQ_TARGET_VALUE
					else
						if _strTarget.stattype == REF_RESOURCE_EXTRACTOR then
							return OIL_TARGET_VALUE
						else
							if _strTarget.stattype == REF_FACTORY or _strTarget.stattype == REF_CYBORG_FACTORY or _strTarget.stattype == REF_VTOL_FACTORY then
								return FACTORY_TARGET_VALUE
							else
								return OTHER_TARGET_VALUE
							end
						end
					end
				end
			end
		end
	end
	
	return NO_TARGET_VALUE
end

---------------------------------------------------------------------
---------------------------------------------------------------------
-- spy technologies
-- event takeover( CALL_UNITTAKEOVER , ref droid  )

function takeover(_droid)
	droid = _droid -- wz2lua: probably these can be used as function arguments directly
	if droid.player == me then
		if droid.droidType == DROID_CONSTRUCT or droid.droidType == DROID_CYBORG_CONSTRUCT then
			groupAddDroid(buildGroup, droid)
		else
			if droid.droidType ~= DROID_TRANSPORTER and droid.droidType ~= DROID_COMMAND then
				groupAddDroid(attackGroup, droid)
			end
		end
	end
end
callbackEvent(takeover, CALL_UNITTAKEOVER)

function takeoverDefend(_droid)
	droid = _droid -- wz2lua: probably these can be used as function arguments directly
	if droid.player ~= me then
		completeResearch(nexusDefence, me)
		deactivateEvent(takeoverDefend)
	end
end
callbackEvent(takeoverDefend, CALL_UNITTAKEOVER)

function useLassat()
	if allOutAttack ~= nil then
		initEnumStruct(false, lassat, me, me)
		structure = enumStruct()
		while structure ~= nil do
			if structureComplete(structure) == true then
				skFireLassat(me, allOutAttack)
			end
			structure = enumStruct()
		end
	end
end
repeatingEvent(useLassat, 300.0)

---------------------------------------------------------------------
---------------------------------------------------------------------
-- attack rules

function findEnemy()
	if attackObj == nil then
		count = random(8)
		count2 = 100
		while friendlyPlayer(count) and (count2 > 0) do
			count = random(8)
			count2 = count2 - 1
		end
		
		if not friendlyPlayer(count) then
			baseobj = skLocateEnemy(count)
			if baseobj ~= nil then
				attackObj = baseobj
				
				-- set allOutAttack to attackObj only if attackObj is a more valuable target than allOutAttack
				if targetTypeValue(attackObj) > targetTypeValue(allOutAttack) then
					allOutAttack = attackObj
				end
			end
		end
	end
end
repeatingEvent(findEnemy, 30.0)

---------------------------------------------------------------------
-- send attack team out to cause trouble near things scout found.
function attackStuff()
	if idleGroup(attackGroup) >= (groupCountMembers(attackGroup) / 2) then
		if (attackObj ~= nil) and (not helpingAlly()) then
			if not allianceExistsBetween(me, attackObj.player) then
				if groupCountMembers(attackGroup) > (6 + random(6)) then
					orderGroupLoc(attackGroup, DORDER_SCOUT, attackObj.x, attackObj.y)
				end
				
				-- make scouts attack too
				if idleGroup(scoutGroup) >= (groupCountMembers(scoutGroup) / 2) then
					orderGroupLoc(scoutGroup, DORDER_SCOUT, attackObj.x, attackObj.y)
				end
			end
		end
	end
end
repeatingEvent(attackStuff, 30.0)

---------------------------------------------------------------------
function doAllOutAttack()
	if idleGroup(attackGroup) >= (groupCountMembers(attackGroup) / 3) then
		if (allOutAttack ~= nil) and (not helpingAlly()) then
			if not friendlyPlayer(allOutAttack.player) then
				if getDroidCount(me) > 40 then
					orderGroupObj(attackGroup, DORDER_ATTACK, allOutAttack)
					orderGroupLoc(scoutGroup, DORDER_SCOUT, allOutAttack.x, allOutAttack.y)
				end
			else
				allOutAttack = nil
			end
		end
	end
end
repeatingEvent(doAllOutAttack, 400.0)

---------------------------------------------------------------------
---------------------------------------------------------------------
-- defending rules

-- defend attacked objects.
function defendWatch(_structure, _baseobj)
	if _structure.player ~= me then return end
	structure, baseobj = _structure, _baseobj -- wz2lua: probably these can be used as function arguments directly
	if baseobj ~= nil then
		if baseobj.type == OBJ_DROID then
			if isVtol(objToDroid(baseobj)) then
				return
			end
		end
		if not friendlyPlayer(baseobj.player) then
			if distBetweenTwoPoints(baseobj.x, baseobj.y, baseX, baseY) <= MAX_DEFENDERS_RADIUS() then
				defendObj = baseobj
				defendbusy = true
				-- if not too busy, attack.
				if idleGroup(defendGroup) >= (groupCountMembers(defendGroup) / 2) then
					orderGroupLoc(defendGroup, DORDER_MOVE, defendObj.x, defendObj.y)
				end
				
				if idleGroup(scoutGroup) >= (groupCountMembers(scoutGroup) / 2) then
					orderGroupLoc(scoutGroup, DORDER_MOVE, scoutX, scoutY)
				end
			end
		end
	end
end
callbackEvent(defendWatch, CALL_STRUCT_ATTACKED)

---------------------------------------------------------------------
-- defenders  return after they are finished.
function defendReturn()
	if defendbusy and (idleGroup(defendGroup) == (groupCountMembers(defendGroup) - groupCountMembers(defendGroup) / 12)) then
		buildX = baseX
		buildY = baseY
		UNUSED, buildX, buildY = pickStructLocationB(powGen, buildX, buildY, me, 0)
		
		orderGroupLoc(defendGroup, DORDER_MOVE, buildX, buildY)
		defendbusy = false
	end
end
repeatingEvent(defendReturn, 50.0)

-- returns number of non-idle structures of a certain type
function numStructBusyByType(_busyStructType)
	local _result = 0
	
	initEnumStruct(false, _busyStructType, me, me)
	structure = enumStruct()
	_result = 0
	while structure ~= nil do
		if structureComplete(structure) then
			if not structureIdle(structure) then
				_result = _result + 1
			end
		end
		structure = enumStruct()
	end
	
	return _result
end

---------------------------------------------------------------------
---------------------------------------------------------------------
-- Research Rules Now does true research.
-- do research

function doResearch(_research, _structure, _player)
	if _player ~= me then return end
	research, structure = _research, _structure -- wz2lua: probably these can be used as function arguments directly
	local _techIndex = 0
	local _numResearching = 0
	local boolResult = false
	
	-- research start
	_techIndex = 0
	_numResearching = numStructBusyByType(resLab)
	
	-- for every research lab do this..
	initEnumStruct(false, resLab, me, me)
	structure = enumStruct()
	count = 0
	while structure ~= nil do
		boolResult = false
		
		if structureIdle(structure) then
			if structureComplete(structure) then
				while not boolResult and _techIndex ~= NONE do
					_techIndex = findResearch(_techIndex, curTech)
					if _techIndex > NONE then
						boolResult = pursueResearch(structure, me, tech[curTech][_techIndex])
						
						-- try nect research next time if needed
						_techIndex = _techIndex + 1
						_numResearching = _numResearching + 1
					end
				end
				
				-- do common research
				-- didn't start branch research
				if not boolResult then
					if (maxIdleRes == UNLIMITED) or (_numResearching < maxIdleRes) then
						skDoResearch(structure, me, 0)
						_numResearching = _numResearching + 1
					end
				end
			end
		end
		
		structure = enumStruct()
	end
	callbackEvent(doResearch, CALL_RESEARCHCOMPLETED)
end
callbackEvent(doResearch, CALL_RESEARCHCOMPLETED)

-- find next available research of our research branch
function findResearch(_searchStart, _techTree)
	local _result = 0
	
	ASSERT(_searchStart >= 0, "findResearch: _searchStart < 0", me)
	ASSERT(_techTree >= 0, "findResearch: _techTree < 0", me)
	
	_result = _searchStart
	while _result < techCount[_techTree] do
		if (not researchFinished(tech[_techTree][_result], me)) and (not researchStarted(tech[_techTree][_result], me)) then
			return _result
		end
		_result = _result + 1
	end
	
	-- not found
	return NONE
end

---------------------------------------------------------------------
---------------------------------------------------------------------
-- Alliance Rules

-- form alliances
function formAllianceEvent()
	count = 0
	while count < MAX_PLAYERS do
		if count ~= me then
			if (getDroidCount(me) > 1) and (getDroidCount(count) > 1) then
				if random(28) == 1 then
					if not isHumanPlayer(count) then
						createAlliance(me, count)
						allianceTime[count] = C.gameTime
					end
				end
			end
		end
		count = count + 1
	end
end
repeatingEvent(formAllianceEvent, 17.0)

---------------------------------------------------------------------
-- break the alliance too.
function breakAllianceEvent()
	count = 0
	while count < C.multiPlayerMaxPlayers do
		if count ~= me then
			if (getDroidCount(me) > 1) and (getDroidCount(count) > 1) then
				if allianceExistsBetween(me, count) then
					if (random(30) == 1) and ((C.gameTime - allianceTime[count]) > 6000) then
						allianceTime[count] = C.gameTime
						breakAlliance(me, count)
					end
					
					-- rules for breaking alliances with humans.
					-- built within my base
					if numStructsInArea(count, minx, miny, maxx, maxy) > 1 then
						allianceTime[count] = C.gameTime
						breakAlliance(me, count)
					end
					
					-- you've got lots of units in my area.
					if numDroidsInArea(count, minx, miny, maxx, maxy) > 3 then
						allianceTime[count] = C.gameTime
						breakAlliance(me, count)
					end
				end
			end
		end
		
		-- you've wiped out one of my allies ??.
		count = count + 1
	end
end
repeatingEvent(breakAllianceEvent, 300.0)

---------------------------------------------------------------------
function formHumanAlliances(_count, _count2)
	count, count2 = _count, _count2 -- wz2lua: probably these can be used as function arguments directly
	local result = 0
	local result2 = 0
	
	-- offered to me.
	if count2 == me then
		result = 0
		result2 = 0
		while result < C.multiPlayerMaxPlayers do
			if allianceExistsBetween(count, result) then
				result2 = result2 + 1
			end
			result = result + 1
		end
		-- not too many already
		if result2 < ((C.multiPlayerMaxPlayers / 2) - 1) then
			if (allianceTime[count] == 0) or (C.gameTime - allianceTime[count] > 1200) then
				result = 0
				result2 = 0
				while result < C.multiPlayerMaxPlayers do
					while result2 < C.multiPlayerMaxPlayers do
						if (not allianceExistsBetween(result, result2)) and (getDroidCount(result) > 0) and (getDroidCount(result2) > 0) and (result ~= result2) then
							if ((result == count and result2 == count2) or (result2 == count2 and result == count)) then
								createAlliance(me, count)
								allianceTime[count] = C.gameTime
							end
						end
						result2 = result2 + 1
					end
					result = result + 1
				end
			end
		end
	end
end
callbackEvent(formHumanAlliances, CALL_ALLIANCEOFFER)



---------------------------------------------------------------------
---------------------------------------------------------------------
-- Consolidate Rules

-- bring forces back together to consolidate attacks
function consolidateEvent()
	if not helpingAlly() then
		if random(3) == 1 then
			buildX = baseX
			buildY = baseY
			UNUSED, buildX, buildY = pickStructLocationB(powGen, buildX, buildY, me, 0)
			
			orderGroupLoc(scoutGroup, DORDER_MOVE, buildX, buildY)
			orderGroupLoc(defendGroup, DORDER_MOVE, buildX, buildY)
		end
	end
end
repeatingEvent(consolidateEvent, 310.0)

---------------------------------------------------------------------
-- vtols.
---------------------------------------------------------------------
-- build vtol strucutures.
function vtolStructs()
	local _numVtolFacs = 0
	local _numRearmPads = 0
	
	-- got any idle trucks?
	if idleGroup(buildGroup) < 1 then
		return
	end
	
	-- see how many vtol factories we already have
	_numVtolFacs = getNumStructures(vtolFactory, me)
	_numRearmPads = getNumStructures(vtolPad, me)
	
	-- see if we have enough rearm pads
	if _numRearmPads * 4 / 3 <= totalVtols() then
		dbg("NEED REARM PADS", me)
		buildRearmPads()
	end
	
	if _numVtolFacs > 0 and playerPower(me) < LOW_POWER then
		return
	end
	
	-- if not enough
	if isStructureAvailable(vtolFactory, me) and _numVtolFacs < maxVtolFacs[curTech] then
		if not grabTrucksAndBuild(8, vtolFactory, 1) then
			dbgPlr("Wanted to build VTOL Factory but could not")
		end
	end
end

-- counts vtols
function totalVtols()
	local _vtolGroup = 0
	local _totalVtols = 0
	
	_totalVtols = 0
	_vtolGroup = 0
	while _vtolGroup < numVtolAttackGroups do
		_totalVtols = _totalVtols + groupCountMembers(vtolAttackGr[_vtolGroup])
		_vtolGroup = _vtolGroup + 1
	end
	
	_totalVtols = _totalVtols + groupCountMembers(vtolDefendGr)
	
	return _totalVtols
end

function buildRearmPads()
	if isStructureAvailable(vtolPad, me) then
		if not grabTrucksAndBuild(4, vtolPad, -1) then
			dbgPlr("Wanted to build VTOL rearm pad, but could not")
		end
	end
end

---------------------------------------------------------------------
-- build vtols.

function buildVtols()
	if (groupCountMembers(vtolDefendGr) >= maxVTOLs[curTech]) or (getDroidCount(me) >= MAX_DROIDS) then
		dbg("CAN'T BUILD VTOLS - TOO MANY UNITS", me)
		return
	end
	
	-- build vtols
	initEnumStruct(false, vtolFactory, me, me)
	structure = enumStruct()
	while structure ~= nil do
		if structureIdle(structure) then
			vtolFactoryBuildVtol(structure)
		end
		
		structure = enumStruct()
	end
end

function vtolFactoryBuildVtol(_factory)
	local _newTemplate = nil
	local _bestBody = nil
	local _bestWeapon = nil
	local _rand = 0
	local _idx = 0
	
	if _factory == nil or not structureIdle(_factory) then
		return
	end
	
	-- choose branch: AT, AS or splash
	_rand = random(3)
	_idx = 0
	_bestWeapon = nil
	-- anti-tank
	if _rand == 0 then
		_idx = numAtWeapons - 1
		while _idx >= 0 and _bestWeapon == nil do
			if isComponentAvailable(me, atWeapon[_idx]) then
				_bestWeapon = atWeapon[_idx]
			end
			_idx = _idx - 1
		end
	end
	-- anti-structure
	if _rand == 1 then
		_idx = numAsWeapons - 1
		while _idx >= 0 and _bestWeapon == nil do
			if isComponentAvailable(me, asWeapon[_idx]) then
				_bestWeapon = asWeapon[_idx]
			end
			_idx = _idx - 1
		end
	end
	if _rand < 2 and _bestWeapon == nil then
		_rand = 2
	end
	-- indiscriminate mass destruction
	if _rand == 2 then
		_idx = numMdWeapons - 1
		while _idx >= 0 and _bestWeapon == nil do
			if isComponentAvailable(me, mdWeapon[_idx]) then
				_bestWeapon = mdWeapon[_idx]
			end
			_idx = _idx - 1
		end
	end
	if _bestWeapon == nil then
		dbgPlr("Failed to find a weapon for VTOL design")
		return
	end
	_bestBody = nil
	if not seenAnyAA then
		if isComponentAvailable(me, bugBody) then
			_bestBody = bugBody
		else
			if isComponentAvailable(me, viperBody) then
				_bestBody = viperBody
			end
		end
	else
		if isComponentAvailable(me, retributionBody) then
			_bestBody = retributionBody
		else
			if isComponentAvailable(me, scorpionBody) then
				_bestBody = scorpionBody
			else
				if isComponentAvailable(me, cobraBody) then
					_bestBody = cobraBody
				end
			end
		end
	end
	if _bestBody == nil or getBodySize(_bestBody) > skGetFactoryCapacity(_factory) then
		dbgPlr("Failed to find a viable body for VTOL design")
		return
	end
	
	_newTemplate = assembleWeaponTemplate(me, _bestBody, vtolPropulsion, _bestWeapon)
	
	if _newTemplate == nil or not skCanBuildTemplate(me, _factory, _newTemplate) then
		dbgPlr("Failed to construct viable VTOL template")
		return
	end
	buildDroid(_newTemplate, _factory, me, 1)
end

---------------------------------------------------------------------
-- attack with vtols.

function vtolAttack()
	local _groupIndex = 0
	local _newTargetWeight = 0
	local _oldTargetWeight = 0
	local _newTarget = nil
	local _bHaveDefendTarget = false
	local _droid = nil
	
	-- if vtol group is not busy..
	if (idleGroup(vtolDefendGr) >= (groupCountMembers(vtolDefendGr) / 2)) and (groupCountMembers(vtolDefendGr) >= 2) then
		if attackObj ~= nil then
			if not friendlyPlayer(attackObj.player) then
				orderGroupObj(vtolDefendGr, DORDER_ATTACK, attackObj)
			else
				attackObj = nil
			end
		else
			if defendObj ~= nil then
				if not isHumanPlayer(defendObj.player) then
					orderGroupObj(vtolDefendGr, DORDER_ATTACK, defendObj)
				end
			end
		end
	end
	
	-- make sure attack vtol groups are not cluttered
	rearrangeAttackVtols()
	
	-- attack vtols
	_groupIndex = 0
	while _groupIndex < numVtolAttackGroups do
		if groupCountMembers(vtolAttackGr[_groupIndex]) > 0 then
			_bHaveDefendTarget = false
			if (vtolGrAttackObj[_groupIndex] ~= nil) then
				if defendingOwnBase() and (distBetweenTwoPoints(baseX, baseY, vtolGrAttackObj[_groupIndex].x, vtolGrAttackObj[_groupIndex].y) <= MAX_VTOL_DEFEND_RADIUS()) then
					_bHaveDefendTarget = true
				else
					if vtolGrAttackObj[_groupIndex].type == OBJ_DROID then
						_droid = objToDroid(vtolGrAttackObj[_groupIndex])
						if _droid.droidType ~= DROID_CONSTRUCT then
							vtolGrAttackObj[_groupIndex] = nil
							_bHaveDefendTarget = false
						end
					end
				end
			end
			
			-- find target in our base if our base is in trouble
			if not _bHaveDefendTarget and defendingOwnBase() then
				vtolGrAttackObj[_groupIndex] = chooseVtolDefenceTarget(baseX, baseY, MAX_VTOL_DEFEND_RADIUS(), false)
				
				if vtolGrAttackObj[_groupIndex] ~= nil then
					dbg("assigned new defence target for group " .. _groupIndex, me)
					_bHaveDefendTarget = true
				end
			end
			
			-- attack rules
			if not _bHaveDefendTarget and (idleGroup(vtolAttackGr[_groupIndex]) >= (groupCountMembers(vtolAttackGr[_groupIndex]) / 2)) and (groupCountMembers(vtolAttackGr[_groupIndex]) >= (numAttackVtols * 2 / 3)) then
				_newTarget = nil
				
				-- reset attack targets once in a while
				if vtolGrAttackObj[_groupIndex] ~= nil then
					if random(10) > 7 then
						vtolGrAttackObj[_groupIndex] = nil
					end
				end
				
				-- now try to find an attack target if we have no defence target
				-- find best attack target
				-- search for an exclusive target
				_newTarget = chooseVtolTarget(true)
				if _newTarget == nil then
					_newTarget = chooseVtolTarget(false)
				end
				
				_newTargetWeight = getVtolTargetWeight(_newTarget)
				_oldTargetWeight = getVtolTargetWeight(vtolGrAttackObj[_groupIndex])
				
				-- new one or a much better one
				if (_newTargetWeight >= (_oldTargetWeight + 20)) or (vtolGrAttackObj[_groupIndex] == nil) then
					dbg("choosing new attack object for " .. _groupIndex, me)
					vtolGrAttackObj[_groupIndex] = _newTarget
				end
			end
			
			-- see if this group has something to attack
			if vtolGrAttackObj[_groupIndex] ~= nil then
				if not friendlyPlayer(vtolGrAttackObj[_groupIndex].player) then
					dbg("VTOL Group " .. _groupIndex .. " attacking", me)
					
					if _DEBUG and (_groupIndex == 0) then
						dropBeacon(getPlayerName(me), me, me, vtolGrAttackObj[_groupIndex].x, vtolGrAttackObj[_groupIndex].y, 0)
					end
					
					orderGroupObj(vtolAttackGr[_groupIndex], DORDER_ATTACK, vtolGrAttackObj[_groupIndex])
				else
					vtolGrAttackObj[_groupIndex] = nil
				end
			end
		end
		
		_groupIndex = _groupIndex + 1
	end
end

-- make sure vtol groups are not cluttered
function rearrangeAttackVtols()
	local _emptyGr = 0
	local _fillGr = 0
	local _droid = nil
	
	_emptyGr = 0
	while _emptyGr < numVtolAttackGroups do
		if (groupCountMembers(vtolAttackGr[_emptyGr]) < numAttackVtols) and (groupCountMembers(vtolAttackGr[_emptyGr]) > 0) then
			_fillGr = _emptyGr + 1
			while (_fillGr < numVtolAttackGroups) and (groupCountMembers(vtolAttackGr[_emptyGr]) < numAttackVtols) do
				initIterateGroup(vtolAttackGr[_fillGr])
				_droid = iterateGroup(vtolAttackGr[_fillGr])
				while (_droid ~= nil) and (groupCountMembers(vtolAttackGr[_emptyGr]) < numAttackVtols) do
					groupAddDroid(vtolAttackGr[_emptyGr], _droid)
					_droid = iterateGroup(vtolAttackGr[_fillGr])
				end
				
				_fillGr = _fillGr + 1
			end
		end
		_emptyGr = _emptyGr + 1
	end
end

function chooseVtolDefenceTarget(_x, _y, _range, bExclusiveTarget)
	local _target = nil
	
	_target = getClosestEnemy(_x, _y, _range, false, false, me)
	
	-- make sure no one else is targeting it already if we want exclusive targets
	if bExclusiveTarget and vtolTargetAssigned(_target) then
		_target = nil
	end
	
	return _target
end

function chooseVtolTarget(bExclusiveTarget)
	local _structTypeIndex = 0
	local _enemy = 0
	local _bestScore = 0
	local _tempScore = 0
	local _bestTarget = nil
	local _structure = nil
	
	_bestScore = 0
	_bestTarget = nil
	
	_enemy = 0
	while _enemy < MAX_PLAYERS do
		if not friendlyPlayer(_enemy) then
			_structTypeIndex = 0
			while _structTypeIndex < numVtolTargets do
				initEnumStruct(false, vtolTarget[_structTypeIndex], _enemy, me)
				_structure = enumStruct()
				while _structure ~= nil do
					if not (bExclusiveTarget and vtolTargetAssigned(_structure)) then
						_tempScore = getVtolTargetWeight(_structure)
						
						-- see if this one is better
						if _tempScore > _bestScore then
							_bestScore = _tempScore
							_bestTarget = _structure
						end
					end
					
					_structure = enumStruct()
				end
				
				_structTypeIndex = _structTypeIndex + 1
			end
		end
		_enemy = _enemy + 1
	end
	
	return _bestTarget
end

function getVtolTargetWeight(_target)
	local _AAPenalty = 0
	local _numAA = 0
	local _range = 0
	local _targetWeight = 0
	local _targetType = 0
	local _structTarget = nil
	
	if _target == nil then
		return 0
	end
	
	if _target.type ~= OBJ_STRUCTURE then
		return 0
	end
	
	_structTarget = objToStructure(_target)
	
	_targetWeight = 0
	
	-- penalty per aa defense
	_AAPenalty = 9
	_range = AA_THREAT_RANGE()
	
	-- count enemy AA
	_numAA = numEnemyAAInRange(_structTarget.x, _structTarget.y, _range)
	
	-- find tyrget type from stats
	_targetType = 0
	while _targetType < numVtolTargets do
		if _structTarget.stat == vtolTarget[_targetType] then
			_targetWeight = vtolTargetWeight[_targetType] - (_numAA * _AAPenalty)
			
			-- exit loop
			_targetType = numVtolTargets
		end
		_targetType = _targetType + 1
	end
	
	-- incomplete structures get lower weight
	if not structureComplete(_structTarget) then
		_targetWeight = _targetWeight / 10
	end
	
	return _targetWeight
end

function checkForHostileAA()
	local _enemy = 0
	local _numAA = 0
	
	_numAA = 0
	_enemy = 0
	while _enemy < MAX_PLAYERS do
		if not friendlyPlayer(_enemy) then
			_numAA = _numAA + numAAinRange(_enemy, me, baseX, baseY, -1)
			if _numAA > 0 then
				seenAnyAA = true
				return
			end
		end
		_enemy = _enemy + 1
	end
	if _numAA == 0 then
		seenAnyAA = false
	end
end
repeatingEvent(checkForHostileAA, 60.0)

function numEnemyAAInRange(_x, _y, _range)
	local _enemy = 0
	local _numAA = 0
	
	_numAA = 0
	_enemy = 0
	while _enemy < MAX_PLAYERS do
		if not friendlyPlayer(_enemy) then
			_numAA = _numAA + numAAinRange(_enemy, me, _x, _y, _range)
		end
		_enemy = _enemy + 1
	end
	
	return _numAA
end

-- see if a particular target is already assigned to one of the VTOL attack groups
function vtolTargetAssigned(_target)
	local _groupIndex = 0
	
	if _target == nil then
		return false
	end
	
	_groupIndex = 0
	while _groupIndex < numVtolAttackGroups do
		if _target == vtolGrAttackObj[_groupIndex] then
			return true
		end
		
		_groupIndex = _groupIndex + 1
	end
	
	return false
end

---------------------------------------------------------------------
-- watch for incoming vtols
function vtolDefend(_structure, _baseobj)
	if _structure.player ~= me then return end
	structure, baseobj = _structure, _baseobj -- wz2lua: probably these can be used as function arguments directly
	local _numBuilders = 0
	local _maxBuilders = 0
	local boolResult = false
	
	if baseobj ~= nil then
		if baseobj.type == OBJ_DROID then
			if isVtol(objToDroid(baseobj)) then
				_numBuilders = 0
				_maxBuilders = 2
				
				-- build defenses.
				-- find idle droids in build group.
				initIterateGroup(buildGroup)
				droid = iterateGroup(buildGroup)
				while droid ~= nil do
					if (structure ~= nil) and (droid.order ~= DORDER_BUILD) then
						buildX = structure.x
						buildY = structure.y
						-- if ! vtol defense already built...
						
						-- find best defense we can build.
						count = 0
						count2 = -1
						while count < 5 do
							if isStructureAvailable(vtolDefStruct[count], me) then
								count2 = count
							end
							count = count + 1
						end
						if count2 ~= (-1) then
							boolResult, buildX, buildY = pickDroidStructLocation(droid, vtolDefStruct[count2], buildX, buildY, me, 1)
							-- build a vtol defense near the attacked struct...
							if boolResult == true and (_numBuilders < _maxBuilders) then
								orderDroidStatsLoc(droid, DORDER_BUILD, vtolDefStruct[count2], buildX, buildY)
								_numBuilders = _numBuilders + 1
							end
						end
					end
					
					droid = iterateGroup(buildGroup)
				end
			end
		end
	end
end
callbackEvent(vtolDefend, CALL_STRUCT_ATTACKED)

---------------------------------------------------------------------
function vtolEnabler()
	if skVtolEnableCheck(me) then
		deactivateEvent(vtolEnabler)
		-- activate other vtol functions..
		repeatingEvent(vtolStructs, 29.0)
		repeatingEvent(buildVtols, 36.0)
		repeatingEvent(vtolAttack, 15.0)
		dbg("----I CAN USE VTOLS----", me)
	end
end
repeatingEvent(vtolEnabler, 70.0)

---------------------------------------------------------------------
-- HouseKeeping

function shutDownAI()
	bRunning = false
	
	deactivateEvent(basedetails)
	deactivateEvent(buildDerrick)
	deactivateEvent(buildOilDefenseOrRetreat)
	deactivateEvent(incendry)
	deactivateEvent(buildPowerGenerators)
	deactivateEvent(buildExpand)
	deactivateEvent(newfortify)
	deactivateEvent(droidBuiltAssign)
	deactivateEvent(droidBuilt)
	deactivateEvent(structBuilt)
	deactivateEvent(droidDestroyed)
	deactivateEvent(conDroids)
	deactivateEvent(repairDroids)
	deactivateEvent(factoryEvent)
	deactivateEvent(cyborgFactoryEvent)
	deactivateEvent(chooseScoutArea)
	deactivateEvent(expandScoutArea)
	deactivateEvent(scoutMain)
	deactivateEvent(newObjectReport)
	deactivateEvent(takeover)
	deactivateEvent(takeoverDefend)
	deactivateEvent(useLassat)
	deactivateEvent(findEnemy)
	deactivateEvent(attackStuff)
	deactivateEvent(defendWatch)
	deactivateEvent(defendReturn)
	deactivateEvent(doResearch)
	deactivateEvent(formAllianceEvent)
	deactivateEvent(breakAllianceEvent)
	deactivateEvent(formHumanAlliances)
	deactivateEvent(consolidateEvent)
	deactivateEvent(vtolStructs)
	deactivateEvent(buildVtols)
	deactivateEvent(vtolAttack)
	deactivateEvent(vtolDefend)
	deactivateEvent(vtolEnabler)
	deactivateEvent(beaconEv)
	deactivateEvent(multiMsgEv)
	deactivateEvent(manageAllyHelp)
	deactivateEvent(everySecEv)
	deactivateEvent(watchBaseThreat)
	deactivateEvent(manageDefendLocationEv)
	deactivateEvent(structureDestroyed)
	deactivateEvent(rebuildStructureEv)
	deactivateEvent(startLevel)
	deactivateEvent(arrived)
	deactivateEvent(checkActivities)
end

function reassignAI()
	bRunning = true
	
	repeatingEvent(basedetails, 60.0)
	deactivateEvent(buildDerrick)
	deactivateEvent(buildOilDefenseOrRetreat)
	deactivateEvent(incendry)
	deactivateEvent(buildPowerGenerators)
	deactivateEvent(buildExpand)
	deactivateEvent(newfortify)
	callbackEvent(droidBuiltAssign, CALL_NEWDROID)
	callbackEvent(droidBuilt, CALL_NEWDROID)
	callbackEvent(droidDestroyed, CALL_DROID_DESTROYED)
	repeatingEvent(conDroids, 90.0)
	repeatingEvent(repairDroids, 260.0)
	repeatingEvent(factoryEvent, 17.0)
	repeatingEvent(cyborgFactoryEvent, 17.0)
	repeatingEvent(chooseScoutArea, 20.0)
	repeatingEvent(expandScoutArea, 60.0)
	repeatingEvent(scoutMain, 15.0)
	callbackEvent(newObjectReport, CALL_OBJ_SEEN)
	callbackEvent(takeover, CALL_UNITTAKEOVER)
	repeatingEvent(useLassat, 300.0)
	repeatingEvent(findEnemy, 30.0)
	repeatingEvent(attackStuff, 30.0)
	repeatingEvent(doAllOutAttack, 400.0)
	callbackEvent(defendWatch, CALL_STRUCT_ATTACKED)
	repeatingEvent(defendReturn, 50.0)
	callbackEvent(doResearch, CALL_RESEARCHCOMPLETED)
	repeatingEvent(formAllianceEvent, 17.0)
	repeatingEvent(breakAllianceEvent, 300.0)
	repeatingEvent(consolidateEvent, 310.0)
	deactivateEvent(vtolStructs)
	deactivateEvent(buildVtols)
	-- setEventTrigger(vtolAttack,inactive);
	repeatingEvent(vtolAttack, 15.0)
	callbackEvent(vtolDefend, CALL_STRUCT_ATTACKED)
	repeatingEvent(vtolEnabler, 70.0)
	callbackEvent(formHumanAlliances, CALL_ALLIANCEOFFER)
	callbackEvent(multiMsgEv, CALL_AI_MSG)
	callbackEvent(beaconEv, CALL_BEACON)
	repeatingEvent(watchBaseThreat, 12.0)
	repeatingEvent(manageAllyHelp, 8.0)
	repeatingEvent(everySecEv, 1.0)
	-- setEventTrigger(manageDefendLocationEv, manageDefendLocationTr);
	callbackEvent(structBuilt, CALL_STRUCTBUILT)
	callbackEvent(structureDestroyed, CALL_STRUCT_DESTROYED)
	repeatingEvent(rebuildStructureEv, 5.0)
	callbackEvent(startLevel, CALL_START_NEXT_LEVEL)
	callbackEvent(arrived, CALL_DROID_REACH_LOCATION)
	repeatingEvent(checkActivities, 40.0)
end

-- Returns true if we just received a beacon from a certain player
function haveBeacon(_player)
	if (tBeacon[_player] > 0) and (not beaconTimeout(_player)) then
		return true
	end
	
	return false
end

-- See if last beacon was placed long ago
function beaconTimeout(_player)
	if (tBeacon[_player] > 0) and ((tBeacon[_player] + BEACON_TIMEOUT) < (C.gameTime / 10)) then
		return true
	end
	
	return false
end

-- Deal with beacons
function beaconEv(_player, _sender, _x, _y, _message)
	if _player ~= me then return end
	sender, x, y, message = _sender, _x, _y, _message -- wz2lua: probably these can be used as function arguments directly
	local _players = 0
	local _processedString = nil
	
	if _DEBUG then
		debugFile(me .. ") beaconEv: from " .. sender)
	end
	
	ASSERT(sender >= 0 and sender < MAX_PLAYERS, "beaconEv: sender out of bounds: " .. sender, me)
	
	beaconX[sender] = x
	beaconY[sender] = y
	tBeacon[sender] = C.gameTime / 10
	
	processCommand(message, sender, true)
end
callbackEvent(beaconEv, CALL_BEACON)

-- Deal with a chat message
function multiMsgEv(_player, _sender, _message)
	if _player ~= me then return end
	sender, message = _sender, _message -- wz2lua: probably these can be used as function arguments directly
	if _DEBUG then
		debugFile(me .. ") multiMsgEv: from " .. sender)
	end
	
	if not allianceExistsBetween(me, sender) then
		return
	end
	
	if sender == me then
		return
	end
	
	processCommand(message, sender, false)
end
callbackEvent(multiMsgEv, CALL_AI_MSG)

-- Process multiplayer messages
function processCommand(_message, _sender, _bBlipMessage)
	local _numMsgs = 0
	local _curMsg = 0
	local _addressedPlayers = 0
	local _x = 0
	local _y = 0
	local _msg = nil
	local _processedString = nil
	
	-- Extract semantic information
	_curMsg = 0
	_numMsgs = processChatMsg(_message)
	
	debugFile(me .. ") processCommand: '" .. _message .. "' from " .. _sender)
	dbg("processCommand: '" .. _message .. "' from " .. _sender, me)
	dbg("got " .. _numMsgs .. " commands", me)
	
	-- Process all messages
	while _curMsg < _numMsgs do
		if chatCmdIsPlayerAddressed(_curMsg, me) then
			dbg("i'm addressed", me)
			_msg = getChatCmdDescription(_curMsg)
			
			-- Someone requested help
			if _msg == R_REQUEST_HELP then
				dbg("'help' command", me)
				
				if haveBeacon(_sender) then
					dbg("got beacon", me)
					
					_x = beaconX[_sender]
					_y = beaconY[_sender]
					
					if attemptToHelp(_sender, _x, _y) then
						messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY)
					end
				else
					_addressedPlayers = setBit(0, _sender, true)
					messagePlayerAddressed(ALL_ALLIES, _addressedPlayers, R_REQUEST_BEACON)
				end
			else
				--[[Someone requested a beacon from us -
							 * did we request help and our beacon timed out??]]--
				if _msg == M_REQUEST_BEACON then
					if baseInTrouble() then
						dropBeacon(getPlayerName(me), _sender, me, baseX, baseY, 0)
					end
				else
					if _msg == R_REPORT_SAFETY then
						dbg("helping " .. lastHelpPlayer, me)
						
						-- Make sure we were helping him
						if helpingAlly() and (lastHelpPlayer == _sender) then
							stopHelpingAlly()
							messagePlayer(ALL_ALLIES, m_affirmative(), MAX_PROBABILITY)
						else
							-- if we are in trouble re-request help
							if defendingOwnBase() then
								requestHelp(baseX, baseY)
							end
						end
					else
						dbg("unknown message", me)
					end
				end
			end
		else
			dbg("i'm not addressed", me)
		end
		
		_curMsg = _curMsg + 1
	end
end

function attemptToHelp(_playerToHelp, _x, _y)
	local _bHelpingMyself = false
	
	if _playerToHelp < 0 or _playerToHelp >= MAX_PLAYERS then
		return false
	end
	
	if _x <= 0 or _y <= 0 then
		return false
	end
	
	dbg("attemptToHelp - checking", me)
	
	_bHelpingMyself = (_playerToHelp == me)
	
	-- Can only help allies and myself
	if not friendlyPlayer(_playerToHelp) then
		return false
	end
	
	-- if not helping any other ally or it's me who needs help
	if _bHelpingMyself or not helpingAlly() or (lastHelpPlayer == _playerToHelp) then
		dbg("not busy helping", me)
		
		if haveHelpers() or _DEBUG then
			dbg("got attackers", me)
			-- is he just trying to misuse us?
			if allyBaseAtLoc(_playerToHelp, _x, _y) then
				helpPlayer(_playerToHelp, _x, _y)
				return true
			else
				dbg("ally needs no help", me)
				messagePlayer(ALL_ALLIES, M_ANNOYED, MAX_PROBABILITY / 2)
			end
		else
			messagePlayer(ALL_ALLIES, M_HELP_NO_UNITS, MAX_PROBABILITY)
		end
	else
		if (lastHelpPlayer >= 0) and (lastHelpPlayer < MAX_PLAYERS) then
			if not _bHelpingMyself then
				messagePlayer(ALL_ALLIES, "helping " .. getPlayerName(lastHelpPlayer) .. " already", MAX_PROBABILITY)
			end
		end
	end
	
	return false
end

-- Start helping player
function helpPlayer(_playerToHelp, _helpX, _helpY)
	local _tTravelTime = 0
	
	dbg("helping " .. _playerToHelp, me)
	
	if _DEBUG then
		debugFile(me .. ") helpPlayer: '" .. _playerToHelp)
	end
	
	-- Move scoutes to attackers
	groupAddGroup(attackGroup, scoutGroup)
	
	-- Calculate travel time, assume ~ 150 tiles in 4 minutes
	if groupCountMembers(attackGroup) == 0 then
		_tTravelTime = ((distBetweenTwoPoints(baseX, baseY, _helpX, _helpY) / 128) * 1.7)
	else
		_tTravelTime = ((distBetweenTwoPoints(attackGroup.x, attackGroup.y, _helpX, _helpY) / 128) * 1.7)
	end
	
	tHelp = C.gameTime / 10
	tHelpTimeout = (C.gameTime / 10) + BASE_DEFEND_DURATION + _tTravelTime
	lastHelpPlayer = _playerToHelp
	helpX = _helpX
	helpY = _helpY
	
	-- Scouts and attackers go to help
	defendLocation(_helpX, _helpY, tHelpTimeout, BASE_DEFEND_RADIUS(), (_playerToHelp == me))
end

-- Returns a random affirmative responce
function m_affirmative()
	local _rnd = 0
	
	_rnd = random(4)
	if _rnd == 3 then
		return M_AFFIRMATIVE_ROGER
	end
	
	return M_AFFIRMATIVE_OK
end

-- See if there are any base structures belonging to ally at a certain location
function allyBaseAtLoc(_ally, _x, _y)
	local _structIndex = 0
	
	if _x <= 0 or _y <= 0 then
		return false
	end
	
	if _ally < 0 or _ally >= MAX_PLAYERS then
		return false
	end
	
	_structIndex = 0
	while _structIndex < numBaseStruct do
		if numStructsByStatInRange(baseStruct[_structIndex], _x, _y, (7 * 128), me, _ally) > 0 then
			return true
		end
		
		_structIndex = _structIndex + 1
	end
	
	return false
end

function manageAllyHelp()
	if helpingAlly() then
		if canStopHelpingAlly() then
			stopHelpingAlly()
		end
	end
end
repeatingEvent(manageAllyHelp, 8.0)

function everySecEv()
	if helpingAlly() then
		if helpAllyTimeout() then
			stopHelpingAlly()
		end
	end
	
	if defendingLocation() then
		if defendLocationTimeout() then
			stopDefendingLocation()
		end
	end
end
repeatingEvent(everySecEv, 1.0)

-- Do we have any units we can send to help ally ?
function haveHelpers()
	if groupCountMembers(attackGroup) == 0 then
		return false
	end
	
	return true
end

function helpingAlly()
	if lastHelpPlayer >= 0 then
		return true
	end
	
	return false
end

-- Returns true if we were helping long enough
function helpAllyTimeout()
	if tHelpTimeout < (C.gameTime / 10) then
		return true
	end
	
	return false
end

function canStopHelpingAlly()
	if lastHelpPlayer < 0 then
		ASSERT(false, "canStopHelpingAlly: lastHelpPlayer < 0", me)
		return true
	end
	
	-- Were helping long enough or someone's backstabbing
	if not friendlyPlayer(lastHelpPlayer) then
		return true
	end
	
	-- Nothing to defend anymore
	if not allyBaseAtLoc(lastHelpPlayer, helpX, helpY) then
		return true
	end
	
	return false
end

function stopHelpingAlly()
	dbg("stopped helping", me)
	
	tHelp = -1
	tHelpTimeout = -1
	lastHelpPlayer = -1
	helpX = -1
	helpY = -1
	
	stopDefendingLocation()
end

-- Send a multiplayer message to an ally
function messagePlayer(_playerToMessage, _message, _probability)
	local _player = 0
	
	ASSERT(_playerToMessage >= -1 and _playerToMessage < MAX_PLAYERS, "messagePlayer: player out of bounds: " .. _playerToMessage, me)
	
	-- throw the dice
	if random(MAX_PROBABILITY) >= _probability then
		return
	end
	
	_player = 0
	-- everyone
	if _playerToMessage == ALL_ALLIES then
		while _player < MAX_PLAYERS do
			if allianceExistsBetween(me, _player) then
				msg(_message, me, _player)
			end
			
			_player = _player + 1
		end
	else
		if allianceExistsBetween(me, _playerToMessage) then
			msg(_message, me, _playerToMessage)
		end
	end
end

function numBitsSet(_integer)
	local _position = 0
	local _result = 0
	
	_position = 0
	_result = 0
	while _position < 8 do
		if getBit(_integer, _position) then
			_result = _result + 1
		end
		_position = _position + 1
	end
	
	return _result
end

-- Send a multiplayer message, addressing some player(s)
function messagePlayerAddressed(_playerToMessage, _playersToAddress, _message)
	local _player = 0
	local _totalAddressed = 0
	local _curAddressed = 0
	local _adrMessage = nil
	
	_totalAddressed = numBitsSet(_playersToAddress)
	
	ASSERT(_totalAddressed > 0, "messagePlayerAddressed: no players addressed", me)
	
	_adrMessage = " "
	
	_player = 0
	_curAddressed = 0
	while _player < MAX_PLAYERS do
		if getBit(_playersToAddress, _player) then
			_curAddressed = _curAddressed + 1
			
			_adrMessage = _adrMessage .. getPlayerName(_player)
			
			-- if(_totalAddressed == 1){	//one only
			-- _adrMessage = getPlayerName(_player);
			-- }else
			
			if _totalAddressed > 1 then
				if _curAddressed == _totalAddressed then
					_adrMessage = _adrMessage .. " and " .. getPlayerName(_player)
				else
					_adrMessage = _adrMessage .. ", " .. getPlayerName(_player)
				end
			end
		end
		
		_player = _player + 1
	end
	
	_message = _adrMessage .. " " .. _message
	
	-- Now send the message to all players addressed
	messagePlayer(_playerToMessage, _message, MAX_PROBABILITY)
end

-- Returns true if we can see our allies on the map
function canSeeAllies()
	local _uplink = nil
	
	-- Can see allies when team mode is on
	if C.multiPlayerAlliancesType == ALLIANCES_TEAMS then
		return true
	end
	
	-- Can see whole map if we have uplink
	_uplink = getStructure(uplink, me)
	if _uplink ~= nil then
		if structureComplete(_uplink) then
			return true
		end
	end
	
	return false
end

function defendingOwnBase()
	if helpingAlly() and lastHelpPlayer == me then
		return true
	end
	
	return false
end

-- Call for help when our base is in danger
function watchBaseThreat()
	if defendingOwnBase() then
		if numEnemiesInBase(false) == 0 then
			stopHelpingAlly()
			
			-- Let allies know we don't need their help anymore
			messagePlayer(ALL_ALLIES, R_REPORT_SAFETY, MAX_PROBABILITY)
			return
		end
	end
	
	-- See if our base is in trouble and we need help
	if baseInTrouble() then
		if not defendingOwnBase() then
			dbgPlr("Our base is in trouble!")
			
			-- Bring our forces back if needed
			if helpingAlly() then
				stopHelpingAlly()
			end
			
			-- Defend my own base
			helpPlayer(me, baseX, baseY)
		end
		
		-- Request help once in a while
		requestHelp(baseX, baseY)
		return
	end
end
repeatingEvent(watchBaseThreat, 12.0)

function numAlliesInBase(_bVtols)
	local _numAllies = 0
	
	_numAllies = numFriendlyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE(), _bVtols)
	_numAllies = _numAllies + numFriendlyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE(), true) / 3
	
	return _numAllies
end

function numEnemiesInBase(_bVtols)
	local _numEnemies = 0
	
	_numEnemies = numEnemyWeapDroidsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE(), _bVtols)
	_numEnemies = _numEnemies + numEnemyWeapStructsInRange(me, baseX, baseY, W_BASE_THREAT_RANGE(), true) / 4
	
	return _numEnemies
end

-- Returns true if our base is in trouble
function baseInTrouble()
	local _enemyForce = 0
	local _friendlyForce = 0
	
	_friendlyForce = numAlliesInBase(false)
	_enemyForce = numEnemiesInBase(false)
	
	-- See if we are in trouble
	if (_enemyForce > 0) and (_enemyForce >= _friendlyForce) then
		dbg("baseInTrouble: " .. _enemyForce .. " >= " .. _friendlyForce, me)
		return true
	end
	
	return false
end

-- Request help from allies
function requestHelp(_helpX, _helpY)
	if tLastHelpRequest + HELP_REQUEST_INTERVAL > (C.gameTime / 10) then
		return
	end
	
	doRequestHelp(_helpX, _helpY)
end

function doRequestHelp(_helpX, _helpY)
	local _ally = 0
	
	-- Remember when we requested help last time
	tLastHelpRequest = C.gameTime / 10
	
	-- Drop beacon for all allies so they would know where to help
	_ally = 0
	while _ally < MAX_PLAYERS do
		if allianceExistsBetween(me, _ally) then
			if _DEBUG then
				debugFile(me .. ") requestHelp: " .. _ally)
			end
			
			dropBeacon(getPlayerName(me), _ally, me, _helpX, _helpY, 0)
		end
		_ally = _ally + 1
	end
	
	-- Now send message with help request
	messagePlayer(ALL_ALLIES, M_REQUEST_HELP, MAX_PROBABILITY)
end

function defendLocation(_defendX, _defendY, _tDefendTimeout, _defendRadius, _bMove)
	dbg("starting defending for " .. _tDefendTimeout - (C.gameTime / 10) .. " secs, with defend radius " .. _defendRadius, me)
	
	ASSERT(_defendRadius >= TILE, "defendLocation: defendRadius too low:" .. _defendRadius, me)
	
	defendX = _defendX
	defendY = _defendY
	
	defendRadius = _defendRadius
	tDefendStart = C.gameTime / 10
	
	-- Should already include travel time
	tDefendTimeout = _tDefendTimeout
	
	-- See if we have to move or scout
	defendMoveType = DORDER_SCOUT
	if _bMove then
		defendMoveType = DORDER_MOVE
	end
	
	-- Send attackers
	if groupCountMembers(attackGroup) > 0 then
		if distBetweenTwoPoints(attackGroup.x, attackGroup.y, _defendX, _defendY) > _defendRadius then
			orderGroupLoc(attackGroup, defendMoveType, _defendX, _defendY)
		end
	end
	
	repeatingEvent(manageDefendLocationEv, 7.0)
end

function stopDefendingLocation()
	dbg("stopped defending location", me)
	
	defendX = -1
	defendY = -1
	
	defendRadius = -1
	
	tDefendStart = -1
	tDefendTimeout = -1
	
	defendMoveType = -1
	
	deactivateEvent(manageDefendLocationEv)
	
	orderGroupLoc(attackGroup, DORDER_SCOUT, baseX, baseY)
end

function defendingLocation()
	if defendX > 0 and defendY > 0 then
		return true
	end
	
	return false
end

function manageDefendLocationEv()
	local _droid = nil
	
	dbg("manageDefendLocationEv", me)
	
	ASSERT(defendRadius >= TILE, "manageDefendLocationEv: defendRadius too low:" .. defendRadius, me)
	
	ASSERT(defendMoveType == DORDER_MOVE or defendMoveType == DORDER_SCOUT, "manageDefendLocationEv: wrong move order:" .. defendMoveType, me)
	
	ASSERT(defendX > 0 and defendY > 0, "manageDefendLocationEv: x/y coordinates:" .. defendX .. "/" .. defendY, me)
	
	if not (defendX > 0 and defendY > 0) then
		dbg("not defending???????", me)
		-- not defending?
		return
	end
	
	-- Collect attackers
	initIterateGroup(attackGroup)
	_droid = iterateGroup(attackGroup)
	while _droid ~= nil do
		if distBetweenTwoPoints(_droid.x, _droid.y, defendX, defendY) > defendRadius then
			if distBetweenTwoPoints(_droid.orderx, _droid.ordery, defendX, defendY) > defendRadius then
				orderDroidLoc(_droid, defendMoveType, defendX, defendY)
			end
		end
		_droid = iterateGroup(attackGroup)
	end
end

function defendLocationTimeout()
	if tDefendTimeout < (C.gameTime / 10) then
		return true
	end
	
	return false
end

-- Returns true if player in question is my ally or if it's me
function friendlyPlayer(_playerToCheck)
	if allianceExistsBetween(_playerToCheck, me) or (_playerToCheck == me) then
		return true
	end
	
	return false
end

function insideBase(_x, _y)
	if _x < minx then
		return false
	end
	
	if _x > maxx then
		return false
	end
	
	if _y < miny then
		return false
	end
	
	if _y > maxy then
		return false
	end
	
	return true
end

function keyPressed(_count, _count2)
	count, count2 = _count, _count2 -- wz2lua: probably these can be used as function arguments directly
	if count == KEY_P and (count2 == KEY_RCTRL or count2 == KEY_LCTRL) then
		if _DEBUG then
			console("The old cheat code has been removed.")
		end
	end
end
callbackEvent(keyPressed, CALL_KEY_PRESSED)

-- ---------------------------------------------------------------
-- Returns how many droids are already on the way to build the
-- same structure on the same spot (like helpbuild)
-- ---------------------------------------------------------------
function numBuildSameBuilding(_checkStat, _x, _y)
	local _numSameBuilding = 0
	local _truck = nil
	
	_numSameBuilding = 0
	
	initIterateGroup(buildGroup)
	_truck = iterateGroup(buildGroup)
	while _truck ~= nil do
		if (_truck.order == DORDER_BUILD) or (_truck.order == DORDER_HELPBUILD) or (_truck.order == DORDER_LINEBUILD) then
			if (_checkStat == NULLSTRUCTURESTAT) or (_truck.stat == _checkStat) then
				if (_x < 0) or (distBetweenTwoPoints(_x, _y, _truck.orderx, _truck.ordery) <= TILE) then
					_numSameBuilding = _numSameBuilding + 1
				end
			end
		end
		_truck = iterateGroup(buildGroup)
	end
	
	return _numSameBuilding
end

-- returns number of droids in a certain group with the same order
function numGroupSameOrder(_group, _orderIndex)
	local _numDroids = 0
	local _droid = nil
	
	_numDroids = 0
	
	initIterateGroup(_group)
	_droid = iterateGroup(_group)
	while _droid ~= nil do
		if _droid.order == _orderIndex then
			_numDroids = _numDroids + 1
		end
		_droid = iterateGroup(_group)
	end
	
	return _numDroids
end

-- Remember certain destroyed structures so we can rebuild them later
function structureDestroyed(_structure)
	if _structure.player ~= me then return end
	structure = _structure -- wz2lua: probably these can be used as function arguments directly
	local _count = 0
	
	-- add certain structures to the rebuild list
	_count = 0
	while _count < numRebuildStat do
		if structure.stat == rebuildStat[_count] then
			if countRebuildStruct < MAX_REBUILD_STRUCT then
				rebuildStructX[countRebuildStruct] = structure.x
				rebuildStructY[countRebuildStruct] = structure.y
				rebuildStructStat[countRebuildStruct] = structure.stat
				countRebuildStruct = countRebuildStruct + 1
				
				dbg("remembered structure (" .. countRebuildStruct .. ") - " .. structure.x .. "/" .. structure.y, me)
				
				return
			end
		end
		_count = _count + 1
	end
end
callbackEvent(structureDestroyed, CALL_STRUCT_DESTROYED)

-- Rebuild structures that were destroyed
function rebuildStructureEv()
	rebuildStructures()
end
repeatingEvent(rebuildStructureEv, 5.0)

function rebuildStructures()
	local _count = 0
	local _threatRange = 0
	local _x = 0
	local _y = 0
	local _truck = nil
	local _stat = nil
	
	_threatRange = (TILE * 8)
	
	_count = 0
	while _count < countRebuildStruct do
		if not threatInRange(me, rebuildStructX[_count], rebuildStructY[_count], _threatRange, false) then
			if getTileStructure(_x / TILE, _y / TILE) == nil then
				_stat = rebuildStructStat[_count]
				_x = rebuildStructX[_count]
				_y = rebuildStructY[_count]
				
				_truck = closestIdleTruck(_x, _y)
				
				if _truck ~= nil then
					if numBuildSameBuilding(_stat, _x, _y) == 0 then
						buildOnExactLocation(_truck, _x, _y, _stat)
					end
				end
			end
		end
		_count = _count + 1
	end
end

function buildOnExactLocation(_truck, _x, _y, _stat)
	local _newX = 0
	local _newY = 0
	
	if _truck == nil then
		return
	end
	
	_newX = _x
	_newY = _y
	
	__result, _newX, _newY = pickDroidStructLocation(_truck, _stat, _newX, _newY, me, -1)
	if __result then
		dbg("trying to rebuild on (" .. _newX .. "/" .. _newY .. ")", me)
		
		if (_x ~= _newX) or (_y ~= _newY) then
			return
		end
		
		orderDroidStatsLoc(_truck, DORDER_BUILD, _stat, _x, _y)
	end
end

-- Get idle truck closest to some location
function closestIdleTruck(_x, _y)
	local _closestTruck = nil
	local _tempTruck = nil
	local _closestDist = 0
	local _tempDist = 0
	
	_closestTruck = nil
	_closestDist = 99999
	
	initIterateGroup(buildGroup)
	_tempTruck = iterateGroup(buildGroup)
	while _tempTruck ~= nil do
		if (_tempTruck.order == DORDER_NONE) or (_tempTruck.order == DORDER_RTB) then
			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y)
			if _tempDist < _closestDist then
				_closestDist = _tempDist
				_closestTruck = _tempTruck
			end
		end
		_tempTruck = iterateGroup(buildGroup)
	end
	
	return _closestTruck
end

function consoleEv(_sender, _message)
	sender, message = _sender, _message -- wz2lua: probably these can be used as function arguments directly
	if message == "autogame on" and (sender == me) then
		if debugModeEnabled() then
			if myResponsibility(me) then
				if not bRunning then
					console(getPlayerName(me) .. " is active")
					reassignAI()
					delayedEvent(startLevel, 0.1)
				end
			end
		end
	end
	
	-- turn off 'autogames'
	if message == "autogame off" and debugModeEnabled() and (sender == me) then
		if bRunning then
			console(getPlayerName(me) .. " is deactivated")
			
			shutDownAI()
		end
	end
	
	if message == "aidebug on" then
		console(getPlayerName(me) .. " ai debug is on")
		_DEBUG = true
		dbgMsgOn(me, _DEBUG)
	else
		if message == "aidebug off" then
			console(getPlayerName(me) .. " ai debug is off")
			_DEBUG = false
			dbgMsgOn(me, _DEBUG)
		end
	end
end
callbackEvent(consoleEv, CALL_CONSOLE)


---------- stubs ----------

if orderDroidStatsLoc == nil then orderDroidStatsLoc = function() print("stub: orderDroidStatsLoc"); return 0 end end
if getVtolTargetWeight == nil then getVtolTargetWeight = function() print("stub: getVtolTargetWeight"); return 0 end end
if threatInRange == nil then threatInRange = function() print("stub: threatInRange"); return 0 end end
if skFireLassat == nil then skFireLassat = function() print("stub: skFireLassat"); return 0 end end
if random == nil then random = function() print("stub: random"); return 0 end end
if dbg == nil then dbg = function() print("stub: dbg"); return 0 end end
if messagePlayer == nil then messagePlayer = function() print("stub: messagePlayer"); return 0 end end
if numBitsSet == nil then numBitsSet = function() print("stub: numBitsSet"); return 0 end end
if isStructureAvailable == nil then isStructureAvailable = function() print("stub: isStructureAvailable"); return 0 end end
if findIdleStructure == nil then findIdleStructure = function() print("stub: findIdleStructure"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if pickStructLocation == nil then pickStructLocation = function() print("stub: pickStructLocation"); return 0 end end
if initGetFeature == nil then initGetFeature = function() print("stub: initGetFeature"); return 0 end end
if numEnemyWeapDroidsInRange == nil then numEnemyWeapDroidsInRange = function() print("stub: numEnemyWeapDroidsInRange"); return 0 end end
if console == nil then console = function() print("stub: console"); return 0 end end
if initIterateGroup == nil then initIterateGroup = function() print("stub: initIterateGroup"); return 0 end end
if stopDefendingLocation == nil then stopDefendingLocation = function() print("stub: stopDefendingLocation"); return 0 end end
if droidCanReach == nil then droidCanReach = function() print("stub: droidCanReach"); return 0 end end
if hasGroup == nil then hasGroup = function() print("stub: hasGroup"); return 0 end end
if attemptToHelp == nil then attemptToHelp = function() print("stub: attemptToHelp"); return 0 end end
if groupAddArea == nil then groupAddArea = function() print("stub: groupAddArea"); return 0 end end
if getStructure == nil then getStructure = function() print("stub: getStructure"); return 0 end end
if numStructBusyByType == nil then numStructBusyByType = function() print("stub: numStructBusyByType"); return 0 end end
if dbgMsgOn == nil then dbgMsgOn = function() print("stub: dbgMsgOn"); return 0 end end
if orderGroupObj == nil then orderGroupObj = function() print("stub: orderGroupObj"); return 0 end end
if insideBase == nil then insideBase = function() print("stub: insideBase"); return 0 end end
if conCanHelp == nil then conCanHelp = function() print("stub: conCanHelp"); return 0 end end
if tryUpgrade == nil then tryUpgrade = function() print("stub: tryUpgrade"); return 0 end end
if allianceExistsBetween == nil then allianceExistsBetween = function() print("stub: allianceExistsBetween"); return 0 end end
if playerPower == nil then playerPower = function() print("stub: playerPower"); return 0 end end
if skDoResearch == nil then skDoResearch = function() print("stub: skDoResearch"); return 0 end end
if chatCmdIsPlayerAddressed == nil then chatCmdIsPlayerAddressed = function() print("stub: chatCmdIsPlayerAddressed"); return 0 end end
if getPlayer == nil then getPlayer = function() print("stub: getPlayer"); return 0 end end
if chooseVtolTarget == nil then chooseVtolTarget = function() print("stub: chooseVtolTarget"); return 0 end end
if targetTypeValue == nil then targetTypeValue = function() print("stub: targetTypeValue"); return 0 end end
if doRequestHelp == nil then doRequestHelp = function() print("stub: doRequestHelp"); return 0 end end
if haveHelpers == nil then haveHelpers = function() print("stub: haveHelpers"); return 0 end end
if debugFile == nil then debugFile = function() print("stub: debugFile"); return 0 end end
if rebuildStructures == nil then rebuildStructures = function() print("stub: rebuildStructures"); return 0 end end
if processCommand == nil then processCommand = function() print("stub: processCommand"); return 0 end end
if structureBuiltInRange == nil then structureBuiltInRange = function() print("stub: structureBuiltInRange"); return 0 end end
if numGroupSameOrder == nil then numGroupSameOrder = function() print("stub: numGroupSameOrder"); return 0 end end
if messagePlayerAddressed == nil then messagePlayerAddressed = function() print("stub: messagePlayerAddressed"); return 0 end end
if buildOnExactLocation == nil then buildOnExactLocation = function() print("stub: buildOnExactLocation"); return 0 end end
if chooseVtolDefenceTarget == nil then chooseVtolDefenceTarget = function() print("stub: chooseVtolDefenceTarget"); return 0 end end
if pickStructLocationB == nil then pickStructLocationB = function() print("stub: pickStructLocationB"); return 0 end end
if factoryBuildDroid == nil then factoryBuildDroid = function() print("stub: factoryBuildDroid"); return 0 end end
if helpingAlly == nil then helpingAlly = function() print("stub: helpingAlly"); return 0 end end
if numVtolFactories == nil then numVtolFactories = function() print("stub: numVtolFactories"); return 0 end end
if distBetweenTwoPoints == nil then distBetweenTwoPoints = function() print("stub: distBetweenTwoPoints"); return 0 end end
if closestIdleTruck == nil then closestIdleTruck = function() print("stub: closestIdleTruck"); return 0 end end
if numUnusedDerricks == nil then numUnusedDerricks = function() print("stub: numUnusedDerricks"); return 0 end end
if isHumanPlayer == nil then isHumanPlayer = function() print("stub: isHumanPlayer"); return 0 end end
if numBuildSameBuilding == nil then numBuildSameBuilding = function() print("stub: numBuildSameBuilding"); return 0 end end
if skDefenseLocationB == nil then skDefenseLocationB = function() print("stub: skDefenseLocationB"); return 0 end end
if groupAddGroup == nil then groupAddGroup = function() print("stub: groupAddGroup"); return 0 end end
if numResearchLabs == nil then numResearchLabs = function() print("stub: numResearchLabs"); return 0 end end
if defendingOwnBase == nil then defendingOwnBase = function() print("stub: defendingOwnBase"); return 0 end end
if setBit == nil then setBit = function() print("stub: setBit"); return 0 end end
if dropBeacon == nil then dropBeacon = function() print("stub: dropBeacon"); return 0 end end
if getPlayerName == nil then getPlayerName = function() print("stub: getPlayerName"); return 0 end end
if numCyborgFactories == nil then numCyborgFactories = function() print("stub: numCyborgFactories"); return 0 end end
if researchStarted == nil then researchStarted = function() print("stub: researchStarted"); return 0 end end
if testStructureModule == nil then testStructureModule = function() print("stub: testStructureModule"); return 0 end end
if assembleWeaponTemplate == nil then assembleWeaponTemplate = function() print("stub: assembleWeaponTemplate"); return 0 end end
if completeResearch == nil then completeResearch = function() print("stub: completeResearch"); return 0 end end
if numFactories == nil then numFactories = function() print("stub: numFactories"); return 0 end end
if numEnemyAAInRange == nil then numEnemyAAInRange = function() print("stub: numEnemyAAInRange"); return 0 end end
if initEnumStruct == nil then initEnumStruct = function() print("stub: initEnumStruct"); return 0 end end
if numEnemiesInBase == nil then numEnemiesInBase = function() print("stub: numEnemiesInBase"); return 0 end end
if getDifficulty == nil then getDifficulty = function() print("stub: getDifficulty"); return 0 end end
if createAlliance == nil then createAlliance = function() print("stub: createAlliance"); return 0 end end
if defendLocation == nil then defendLocation = function() print("stub: defendLocation"); return 0 end end
if numFriendlyWeapDroidsInRange == nil then numFriendlyWeapDroidsInRange = function() print("stub: numFriendlyWeapDroidsInRange"); return 0 end end
if buildUnit == nil then buildUnit = function() print("stub: buildUnit"); return 0 end end
if numStructsByStatInRange == nil then numStructsByStatInRange = function() print("stub: numStructsByStatInRange"); return 0 end end
if numAAinRange == nil then numAAinRange = function() print("stub: numAAinRange"); return 0 end end
if beaconTimeout == nil then beaconTimeout = function() print("stub: beaconTimeout"); return 0 end end
if initEnumUnbuilt == nil then initEnumUnbuilt = function() print("stub: initEnumUnbuilt"); return 0 end end
if cybFactorBuildCyborg == nil then cybFactorBuildCyborg = function() print("stub: cybFactorBuildCyborg"); return 0 end end
if numTemplatesInProduction == nil then numTemplatesInProduction = function() print("stub: numTemplatesInProduction"); return 0 end end
if grabTrucksAndBuild == nil then grabTrucksAndBuild = function() print("stub: grabTrucksAndBuild"); return 0 end end
if enumStruct == nil then enumStruct = function() print("stub: enumStruct"); return 0 end end
if objToDroid == nil then objToDroid = function() print("stub: objToDroid"); return 0 end end
if setTechBranch == nil then setTechBranch = function() print("stub: setTechBranch"); return 0 end end
if groupMember == nil then groupMember = function() print("stub: groupMember"); return 0 end end
if pursueResearch == nil then pursueResearch = function() print("stub: pursueResearch"); return 0 end end
if helpAllyTimeout == nil then helpAllyTimeout = function() print("stub: helpAllyTimeout"); return 0 end end
if needTank == nil then needTank = function() print("stub: needTank"); return 0 end end
if defendLocationTimeout == nil then defendLocationTimeout = function() print("stub: defendLocationTimeout"); return 0 end end
if orderGroupLoc == nil then orderGroupLoc = function() print("stub: orderGroupLoc"); return 0 end end
if skVtolEnableCheck == nil then skVtolEnableCheck = function() print("stub: skVtolEnableCheck"); return 0 end end
if myResponsibility == nil then myResponsibility = function() print("stub: myResponsibility"); return 0 end end
if skLocateEnemy == nil then skLocateEnemy = function() print("stub: skLocateEnemy"); return 0 end end
if baseInTrouble == nil then baseInTrouble = function() print("stub: baseInTrouble"); return 0 end end
if breakAlliance == nil then breakAlliance = function() print("stub: breakAlliance"); return 0 end end
if dbgPlr == nil then dbgPlr = function() print("stub: dbgPlr"); return 0 end end
if reassignAI == nil then reassignAI = function() print("stub: reassignAI"); return 0 end end
if getDroidCount == nil then getDroidCount = function() print("stub: getDroidCount"); return 0 end end
if msg == nil then msg = function() print("stub: msg"); return 0 end end
if allyBaseAtLoc == nil then allyBaseAtLoc = function() print("stub: allyBaseAtLoc"); return 0 end end
if getFeatureB == nil then getFeatureB = function() print("stub: getFeatureB"); return 0 end end
if orderDroid == nil then orderDroid = function() print("stub: orderDroid"); return 0 end end
if enumUnbuilt == nil then enumUnbuilt = function() print("stub: enumUnbuilt"); return 0 end end
if grabTrucksAndBuildAt == nil then grabTrucksAndBuildAt = function() print("stub: grabTrucksAndBuildAt"); return 0 end end
if getClosestEnemy == nil then getClosestEnemy = function() print("stub: getClosestEnemy"); return 0 end end
if vtolTargetAssigned == nil then vtolTargetAssigned = function() print("stub: vtolTargetAssigned"); return 0 end end
if structureIdle == nil then structureIdle = function() print("stub: structureIdle"); return 0 end end
if objToStructure == nil then objToStructure = function() print("stub: objToStructure"); return 0 end end
if pickDroidStructLocation == nil then pickDroidStructLocation = function() print("stub: pickDroidStructLocation"); return 0 end end
if getBodySize == nil then getBodySize = function() print("stub: getBodySize"); return 0 end end
if orderDroidLoc == nil then orderDroidLoc = function() print("stub: orderDroidLoc"); return 0 end end
if defendingLocation == nil then defendingLocation = function() print("stub: defendingLocation"); return 0 end end
if numAlliesInBase == nil then numAlliesInBase = function() print("stub: numAlliesInBase"); return 0 end end
if getPlayerStartPosition == nil then getPlayerStartPosition = function() print("stub: getPlayerStartPosition"); return 0 end end
if numEnemyWeapStructsInRange == nil then numEnemyWeapStructsInRange = function() print("stub: numEnemyWeapStructsInRange"); return 0 end end
if ASSERT == nil then ASSERT = function() print("stub: ASSERT"); return 0 end end
if buildRearmPads == nil then buildRearmPads = function() print("stub: buildRearmPads"); return 0 end end
if friendlyPlayer == nil then friendlyPlayer = function() print("stub: friendlyPlayer"); return 0 end end
if helpPlayer == nil then helpPlayer = function() print("stub: helpPlayer"); return 0 end end
if rearrangeAttackVtols == nil then rearrangeAttackVtols = function() print("stub: rearrangeAttackVtols"); return 0 end end
if dbgObj == nil then dbgObj = function() print("stub: dbgObj"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if getChatCmdDescription == nil then getChatCmdDescription = function() print("stub: getChatCmdDescription"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if m_affirmative == nil then m_affirmative = function() print("stub: m_affirmative"); return 0 end end
if shutDownAI == nil then shutDownAI = function() print("stub: shutDownAI"); return 0 end end
if isVtol == nil then isVtol = function() print("stub: isVtol"); return 0 end end
if vtolFactoryBuildVtol == nil then vtolFactoryBuildVtol = function() print("stub: vtolFactoryBuildVtol"); return 0 end end
if requestHelp == nil then requestHelp = function() print("stub: requestHelp"); return 0 end end
if orderDroidObj == nil then orderDroidObj = function() print("stub: orderDroidObj"); return 0 end end
if processChatMsg == nil then processChatMsg = function() print("stub: processChatMsg"); return 0 end end
if safeDest == nil then safeDest = function() print("stub: safeDest"); return 0 end end
if numStructsInArea == nil then numStructsInArea = function() print("stub: numStructsInArea"); return 0 end end
if stopHelpingAlly == nil then stopHelpingAlly = function() print("stub: stopHelpingAlly"); return 0 end end
if numDroidsInArea == nil then numDroidsInArea = function() print("stub: numDroidsInArea"); return 0 end end
if skCanBuildTemplate == nil then skCanBuildTemplate = function() print("stub: skCanBuildTemplate"); return 0 end end
if numFriendlyWeapStructsInRange == nil then numFriendlyWeapStructsInRange = function() print("stub: numFriendlyWeapStructsInRange"); return 0 end end
if getNumStructures == nil then getNumStructures = function() print("stub: getNumStructures"); return 0 end end
if iterateGroup == nil then iterateGroup = function() print("stub: iterateGroup"); return 0 end end
if buildDroid == nil then buildDroid = function() print("stub: buildDroid"); return 0 end end
if getTileStructure == nil then getTileStructure = function() print("stub: getTileStructure"); return 0 end end
if researchFinished == nil then researchFinished = function() print("stub: researchFinished"); return 0 end end
if isComponentAvailable == nil then isComponentAvailable = function() print("stub: isComponentAvailable"); return 0 end end
if totalVtols == nil then totalVtols = function() print("stub: totalVtols"); return 0 end end
if debugModeEnabled == nil then debugModeEnabled = function() print("stub: debugModeEnabled"); return 0 end end
if haveBeacon == nil then haveBeacon = function() print("stub: haveBeacon"); return 0 end end
if canStopHelpingAlly == nil then canStopHelpingAlly = function() print("stub: canStopHelpingAlly"); return 0 end end
if skGetFactoryCapacity == nil then skGetFactoryCapacity = function() print("stub: skGetFactoryCapacity"); return 0 end end
if structureComplete == nil then structureComplete = function() print("stub: structureComplete"); return 0 end end
if aiResponsibleForPlayer == nil then aiResponsibleForPlayer = function() print("stub: aiResponsibleForPlayer"); return 0 end end
if getBit == nil then getBit = function() print("stub: getBit"); return 0 end end
if findResearch == nil then findResearch = function() print("stub: findResearch"); return 0 end end
