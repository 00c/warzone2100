-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for
DYDOBP_RELEASE = "DyDo-AI ver 2.0.8"

GAME_TIME_IN_SECS = function () return (C.gameTime / 10) end
GAME_TIME_IN_MIN = function () return (C.gameTime / 10 / 60) end
TIME_MINUTE = 600
MAX_WHILE_LOOPS = 99
BIG_MAP = 120
PLAYER_NUMBER = 0
TEAM_NUMBER = 1

-- gametype
GT_2PLAYERS_1HP = 0
GT_4PLAYERS_1HP_2T = 1
GT_4PLAYERS_1HP_34T = 2
GT_8PLAYERS_1HP_23T = 3
GT_8PLAYERS_1HP_4567T = 4
GT_4PLAYERS_2HP_2T = 5
GT_4PLAYERS_2HP_34T = 6
GT_8PLAYERS_2HP_23T = 7
GT_8PLAYERS_2HP_4567T = 8
GT_8PLAYERS_3HP_23T = 9
GT_STANDARD = 10

-- stats
OC_WEAPON_COST = 0
OC_RESLABS = 1
OC_PHYTON = 2
OC_MANTIS = 3
OC_TIGER = 4
OC_CYBORGS = 5
OC_TANKS = 6
OC_VTOLS = 7
OC_DERRICKS = 8
OC_DEF_STRUCT = 9
OC_CYB_POWER = 10
OC_TK_POWER = 11
OC_VTOL_POWER = 12
OC_CYB_HP = 13
OC_TK_HP = 14
OC_VTOL_HP = 15

WUI_TOTUNITS = 0
WUI_POWER = 1
WUI_HP = 2

-- used with AIPersonality
AI_STANDARD = 1
AI_VTOL = 2
AI_TURTLE = 3
AI_CYBORG = 4

-- select tank template
BODY_HEAVY = 0
BODY_MEDIUM = 1
BODY_LIGHT = 2
WEAPON_AR = 0
WEAPON_AT = 1
WEAPON_AP = 2

-- used with minDefDroids[][x]
MINDEF_TANKS = 0
MINDEF_CYBORGS = 1
MINDEF_VTOLS = 2

EVENT_CHECK_NUMBER = 23

NUM_AI_PERSONALITIES = 4
TILE = 128
MAX_DROIDS = 150

STR_TANK_FACTORY = 0
STR_RESLAB = 1
STR_CYB_FACTORY = 2
STR_VTOL_FACTORY = 3

MAX_DEFSTR_DERRICKS = 3
MAX_DEFSTR_SPOT = 3
MAX_REPAIRFAC = 5

VERY_LOW_POWER_MAP = 0
LOW_POWER_MAP = 1
NORMAL_POWER_MAP = 2
HIGH_POWER_MAP = 3

-- harvTrucks+buildTrucks+defTrucks
MIN_BUILDING_TANKS = 6
MIN_CYB_CONSTENG = 4

TIME_MOVE_TOGATEWAYS = 70
THREAT_RANGE_TILES = 8
-- used for repairing and building derricks
THREAT_RANGE_TILES_SHORT = 7
THREAT_RANGE_TILES_LONG = 10

BUILDDEF_GRP = 0
CYBENG_GRP = 1
BUILD_GRP = 2
HARVEST_GRP = 3

STRUCT_REPAIR_DAMAGE = 25

RED_ALERT = 3
YELLOW_ALERT = 2
GREEN_ALERT = 1
ALERT_INACTIVE = 0

-- used to compare combat strenghts
COMBAT_RANGE = function () return (TILE * 12) end

-- repairing untis
MAX_REPAIR_UNITS = 2
MIN_HEALT_REPAIR_BASE = 80
MIN_HEALT_SWITCH_TO_TANK = 95
MIN_HEALT_SWITCH_TO_CYBORG = 95
DAMAGE_REPAIR_LEVEL = 50
DAMAGE_REPAIR_LEVEL_LOW = 20
VTOL_DAMAGE_REPAIR_LEVEL = 75
STRUCT_REPAIR_DAMAGE = 25

-- tanks
MIN_ATTACKING_TANKS = 10
MAX_ATTACK_TANKS_ADD = 12
MIN_DEFUNIT_DEFEND = 2
MIN_SURVIVOR_TANKS = 3

MIN_HELPING_UNITS = 5
-- this is for both cybDefGRP and tkDefGRP, therefore the max helping is 10!
MAX_HELPING_UNITS = 5
-- attack enemy and defend with defGrp only if we have at least these number of units
MIN_DEFUNIT_ATTACK = 5

-- cyborgs
MIN_DEFCYB_DEFEND = 2
MIN_ATT_CYBORGS = 10
MAX_ATTACK_CYBORG_ADD = 12
MIN_SURVIVOR_CYBORGS = 3

-- VTOLs   - code cleaning stopped here
MAX_VTOLS = 15
MAX_VTOLS_PERS2 = 25
-- attack only if this number of VTOLs has been reached
MIN_VTOLS_ATTACK_DERRICK = 2
MIN_VTOLS_ATTACK_BASE = 7
MIN_VTOLS_DEFEND_BASE = 1
-- Personality 2 aims for a quick buoild of these VTOLs
MIN_VTOLS = 3
MIN_VTOLS_PERS2 = 5
AA_THREAT_RANGE = function () return (TILE * 18) end

-- defend
MAX_DEFEND_RANGETILES = 45
MIN_BASE_DEF_STRUCTS = 12
MAX_BASE_DEF_STRUCTS = 20

-- AA
RANGE_BUILD_AADEF = function () return 7 * TILE end
MAX_AADEF_INRANGE = 3
MIN_AA_INBASERANGE = 7
-- add to nRangeBase
RANGETILES_DEFSTR_AROUNDBASE = 10

-- if after TIME_HARVESTING_PHASE units are lower then this we cannot perfom building new structs, researches, upgrades
MIN_TOT_UNITS = 8
-- build derrick defences only after this time
VALID_TIME_DERRICK_DEF = 3600
-- change the units to add to build up the attacking group every this interval time
TIME_CHANGE_TANKSTOADD = 3000

-- build more then 2 repair centres aonly after this time
VALID_TIME_REPAIRFAC = 4200
-- build 4-5 Research and Cyborg Factory after this time
VALID_TIME_EXTRABUILD = 4800
-- build oilDef only after this time
VALID_TIME_CYBATTACK = 6000
-- after 4 min all oil should be got
TIME_HARVESTING_PHASE = 3000
-- after this time alert is set to DEACTIVATED anyway
TIME_TO_RESET_ALERT = 100
-- build gateway def only after this time
VALID_TIME_GATEWAYDEF = 3600
-- start researching VTOL stuff only after this time
TIME_START_VTOLRESEARCH = 3000
-- force the building of a defence every x min
TIME_TOFORCE_BUILDDEF = 1200
-- turtle AI
TIME_TOFORCE_BUILDDEF_2 = 900

-- power
VERY_LOW_POWER = 0
LOW_POWER = 1
HIGH_POWER = 2
TIME_SWITCH_WORKSTRUCT = 600

BEST_VTOL_TEMPLATES = 3

-- player for this instance.
-- public BOOL LIFE;        // feature switch
-- rate of exploration
numMaxDerricks = 0

-- structures
baseX = 0
baseY = 0
minx = 0
miny = 0
maxx = 0
maxy = 0
defSpotX = 0
defSpotY = 0
structChoice = Array(30)
nStat = 0
aStat = Array(20, 17)
structsBuildLimits = Array(4, 4)

-- keep even if not used

pickStrQueue = Array(15)
pickStrQueueDepth = 0
pickDefQueue = Array(50)
pickDefQueueDepth = 0
pickWallDefQueue = Array(60)
pickWallDefQueueDepth = 0
pickFortQueue = Array(4)
pickFortQueueDepth = 0

pickStructureQueue = Array(80)
pickStructureQueueDepth = 0

nAI_Pers = 0

-- unit templates
tmpl1 = Array(5)
VTOLconstr = nil

-- special - template recognizer

-- build
buildX = 0
buildY = 0

-- GROUPS
vtolHunterGr = Group()
vtolDefendGr = Group()
vtolAttGr = Group()
tankGroup = Group()
buildGroup = Group()
harvesterGroup = Group()
toBeRepairedTankGroup = Group()
repairGroup = Group()
toBeRepairedCyborgGroup = Group()
cyborgDefGroup = Group()
cyborgAttGroup = Group()
xGroup = Group()

-- generic
structure = nil
structure2 = nil
structure3 = nil
droid = nil
droid2 = nil
feature = nil
feature2 = nil
baseobj = nil
count = 0
count1 = 0
count2 = 0
count3 = 0
count4 = 0
boolResult = false
boolResult2 = false
boolResult3 = false

aPlayers = Array(17, 17)

lassatTarget = nil
myBaseObject = nil
enemyBaseObject = nil

-- Shielding systems (2:45 hours after game begins) (KICK)
SHIELDS = nil

-- +*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
---------------------------------------------

-- // DEBUG-MODE
-- DylanDog

-- // T1 cyborgs problem

oilX = 0
oilY = 0

-- +*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
-- +*+*+*+*+*+*+*+*+*+*+*+ DylanDog - VARIABLES DECLARATION *+*+*+*+*+*+*++*+*+*
-- +*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
RcketBB = nil



-- ========================= PRIVATE =====================================
buildDefGroup = Group()
cyborgConstructGroup = Group()
tankDefGroup = Group()
helpGroup = Group()
attackCybObj = nil
attackTankObj = nil
objTargetHelpTeam = nil
objTargetCybDefGRP = nil
objTargetTankDefGRP = nil
_oilRes = nil
_droid = nil
_droid1 = nil
_droid2 = nil
_idleTruck = nil
_notIdleTruck = nil
mydroid = nil
_derrick = nil
_struct = nil

bPowerNormalized = false
bAttackedHumanDerrick = false
debugCenterView = false
bAttackedByMortars = false
bAttackedByLongRangeWeap = false
sentToGateway = false
isBackinBase = false
alertIsOn = false
bCybAttIsOn = false
lCybSentToGatheringPoint = false
bCybAlreadyGathered = false
bOilResLeft = false
lStopVTOLProduction = false
lStopVTOLFactBuilding = false
lStopResLabUpgrade = false
lMinBaseStructBuilt = false
lStopBuildingStructures = false
lStopBuildRepFacility = false
lStopCybEngProd = false
lStopBuildTankProd = false
lStopTankProduction = false
lStopCybProduction = false
lStopResearch = false
lStopCheapResearch = false
lStopFactUpgrade = false
lStopBuildDefDerricks = false
lStopBuildDefGateway = false
lStopBuildDef = false
lStopFactUpgrade2 = false
bVTOLTargetIsDerrick = false
_bVTOLTarget = false
_mustBeHuman = false
lTankSentToGatheringPoint = false
bTankAttIsOn = false
bTankAlreadyGathered = false
bForceResPowUp = false
bFinalAttack_1vs1 = false
bAttackTeamAttacked = false
_bNoTrucks = false
bNeedDerrick = false
bDroidSelected = false
bAttackedByVTOL = false

oilResTargetId = Array(11)
oilResTargetX = Array(11)
oilResTargetY = Array(11)
aGatewayPosX = Array(4)
aGatewayPosY = Array(4)
nTotGateways = 0
lastTimeRepairBuilt = 0
numDefStrAtGateway = 0
numGatewaysFound = 0
defTruckSentTime = 0
lastBuildDefX = 0
lastBuildDefY = 0
nRealGatewaysFound = 0
nMidX = 0
nMidY = 0
nTotOilInAtStart = 0
nLastTimeBuiltRepFac = 0
lastTruckBuilt = 0
lastCybEngBuilt = 0
lastDisplayAI = 0
lastDisplayAIcheck = 0
nDefendRange = 0
gatewaysRangeTiles = 0
nBaseRange = 0
aaRange = 0
gatherDefCybX = 0
gatherDefCybY = 0
gatherDefTankX = 0
gatherDefTankY = 0
lastResIndex = 0
nAttackingUnitsToAdd = 0
nCybAttUnitsToAdd = 0
nArtilleryPos = 0
nTime = 0
nAttackTime = 0
nFrWeapStructs = 0
nFrWeapDroids = 0
nFrWeapDrStr = 0
nTanksDefGrp = 0
nMapPower = 0
nEnWeapStructs = 0
nEnWeapDroids = 0
nEnWeapDrStr = 0
tTargetTime = 0
tFinishOilHack = 0
alertX = 0
alertY = 0
alertTime = 0
alertLevel = 0
nX = 0
nY = 0
tLastRRBuilt = 0
tLastArtilleryBuilt = 0
tLastPowerGen = 0
tChangeTimeTankToAdd = 0
nHelpX = 0
nHelpY = 0
tLastHelp = 0
tTotalAttack = 0
tLastTankAttack = 0
tLastCyborgAttack = 0
tTanksReSentToGathering = 0
tTanksSentToGathering = 0
nTankGatheringX = 0
nTankGatheringY = 0
tankAttackX = 0
tankAttackY = 0
targetPlayerTank = 0
targetPlayerVTOL = 0
tCybReSentToGathering = 0
tCybSentToGathering = 0
tCybAttackAction = 0
tHelpAction = 0
tTankAttackAction = 0
nCybGatheringX = 0
nCybGatheringY = 0
cybAlertX = 0
cybAlertY = 0
cybAttackX = 0
cybAttackY = 0
targetPlayerCyb = 0
tEveryMin = 0
tEvery3Min = 0
playerLeft = 0
nVTOLFactories = 0
nWorkingVTOLFac = 0
nTotTanks = 0
nTotCyborgs = 0
nMyDerricks = 0
nPower = 0
nFactories = 0
nResLabs = 0
nCybFact = 0
nWorkingFact = 0
nWorkingCybFac = 0
nKineticX = 0
nKineticY = 0
nWorkingLab = 0
nTotDefences = 0
nFreeOilRes = 0
nTotBaseDefences = 0
_targetPlayer = 0
nLastDefSpotUpdate = 0
_nOilRes = 0
_t = 0
_pos = 0
nTotCybAR = 0
nTotCybAP = 0
nTotCybAT = 0
nTotCybKK = 0
nTotCybErr = 0

nTotEnemyDroids = 0
nCybMechanic = 0
nStructToBeBuilt = 0
nAllyBeingHelped = 0
nPODMRLTank = 0
nWeakTank = 0
nTotCyborgBuilt = 0
nTotTankBuilt = 0
tLastCybMech = 0
tLastFinalAttack = 0
nFinalAttacks = 0
nDamageLevelRepair = 0
nProdSelect = 0
tLastPowerSwitch = 0
tLastbuildBaseDef = 0
nEnemyPlayers = 0
nLastEnemyPlayer = 0
nTeam = 0
nHumanPlayers = 0
nPlayersInGame = 0
nDerricksAtStart = 0
tDefVtolAction = 0
tDefTankAction = 0
tDefCybAction = 0
tLastResearch = 0

num_aDroid = 0
aDroid_Id = Array(50)
aDroid_X = Array(50)
aDroid_Y = Array(50)
aDroid_counter = Array(50)
nAttHumanPlayer = 0
nAttAIPlayer = 0

_nWeapon = 0
_nBody = 0

numAAinBase = 0
tLastAAbuilt = 0
tLastVTOLFactBuild = 0
defTargetVTOL = nil
attTargetVTOL = nil

aPower = Array(3)
nAAPos = 0
nAIcheck = 0
tAIbrain = 0
eventCheckReport = Array(EVENT_CHECK_NUMBER)
eventCheckTime = Array(EVENT_CHECK_NUMBER)
eventCheckTrigger = Array(EVENT_CHECK_NUMBER)
eventCheckCounter = Array(EVENT_CHECK_NUMBER)


-- communication
_sender = 0
sender = 0
x = 0
y = 0
tBeaconTimeout = 0
beaconX = Array(17)
beaconY = Array(17)
tBeacon = Array(17)
lastHelpPlayer = 0
_fromPlayer = 0
_choice = 0
message = nil
_message = nil
_cstr = nil
_bBlipMessage = false
_bToHuman = false

tBeaconSent = 0

_DEBUG = false
_DEBUG1 = false
_dbg = false
bRunning = false

-- ===================================================================
-- USED FOR PRODUCTION ONLY

nProd1 = 0
nProd2 = 0
nProd3 = 0
nProd4 = 0
nProd5 = 0
fProd1 = 0
fProd2 = 0
fProd3 = 0
fProd4 = 0
fProd5 = 0
tProd1 = 0
tProd2 = 0
tProd3 = 0
tProd4 = 0
tProd5 = 0
bProd1 = false
bProd2 = false
bProd3 = false
bProd4 = false
bProd5 = false
sProd1 = nil
sProd2 = nil
sProd3 = nil
sProd4 = nil
sProd5 = nil



-- +*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*
-- +*+*+*+*+*+*+*+*+*+*+*+ MAIN SCRIPT *+*+*+*+*+*+*++*+*+*+*+*+*+*+*+*+*+*+*
-- +*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*+*

-- HouseKeeping

function initialisedEvent()
	player = getPlayer("Dydo")
	
	lassatTarget = nil
	defSpotY = 0
	defSpotX = 0
	maxy = 0
	maxx = 0
	miny = 0
	minx = 0
	baseY = 0
	baseX = 0
	
	-- DEBUGMESSAGE
	dbgMsgOn(player, false)
	debugCenterView = false
	-- print off debug messages every 5 min
	_DEBUG = true
	-- print off debug messages
	_DEBUG1 = true
	-- true if AI controls this player
	bRunning = false
	
	count = 0
	while count < 4 do
		aGatewayPosX[count] = -1
		aGatewayPosY[count] = -1
		count = count + 1
	end
	nAI_Pers = 0
	nTotCyborgBuilt = 0
	nTotTankBuilt = 0
	tFinishOilHack = C.gameTime
	nAIcheck = 0
	tAIbrain = 0
	defTruckSentTime = -1
	sentToGateway = false
	isBackinBase = false
	bNeedDerrick = false
	bAttackTeamAttacked = false
	bFinalAttack_1vs1 = false
	nAllyBeingHelped = -1
	nStructToBeBuilt = 0
	tDefVtolAction = 0
	tDefTankAction = 0
	tDefCybAction = 0
	tLastResearch = 0
	tLastHelp = 0
	tLastArtilleryBuilt = 0
	tLastRRBuilt = 0
	nHelpX = -1
	nHelpY = -1
	tLastbuildBaseDef = 0
	nRealGatewaysFound = 0
	lastBuildDefX = -1
	lastBuildDefY = -1
	lastResIndex = -1
	nMidX = -1
	nMidY = -1
	gatherDefTankX = -1
	gatherDefTankY = -1
	gatherDefCybX = -1
	gatherDefCybY = -1
	nTotGateways = 3
	nTotOilInAtStart = 0
	lastDisplayAI = 0
	lastDisplayAIcheck = 0
	lastTruckBuilt = 0
	lastCybEngBuilt = 0
	nPlayersInGame = -1
	nAAPos = 0
	nHumanPlayers = 0
	nTeam = -1
	nEnemyPlayers = -1
	nLastEnemyPlayer = -1
	nLastTimeBuiltRepFac = 0
	numDefStrAtGateway = -1
	lastTimeRepairBuilt = 0
	nLastDefSpotUpdate = -1
	tLastPowerSwitch = 0
	nProdSelect = 0
	nDamageLevelRepair = 0
	nFinalAttacks = 0
	tLastFinalAttack = 0
	alertIsOn = false
	alertX = baseX
	alertY = baseY
	alertTime = C.gameTime
	bCybAttIsOn = false
	lCybSentToGatheringPoint = false
	bCybAlreadyGathered = false
	bAttackedByVTOL = false
	cybAlertX = -1
	cybAlertY = -1
	cybAttackX = 0
	cybAttackY = 0
	nCybGatheringX = -1
	nCybGatheringY = -1
	targetPlayerCyb = -1
	tCybSentToGathering = 0
	tCybReSentToGathering = 0
	tCybAttackAction = 0
	tTankAttackAction = 0
	tHelpAction = 0
	tChangeTimeTankToAdd = 0
	tLastPowerGen = 0
	tLastTankAttack = 0
	tTotalAttack = random(3000)
	tLastCyborgAttack = 0
	tLastVTOLFactBuild = 0
	tLastAAbuilt = 0
	-- tank attack
	bTankAttIsOn = false
	lTankSentToGatheringPoint = false
	bTankAlreadyGathered = false
	nTankGatheringX = -1
	nTankGatheringY = -1
	tankAttackX = -1
	tankAttackY = -1
	targetPlayerTank = -1
	targetPlayerVTOL = -1
	tTanksSentToGathering = 0
	tTanksReSentToGathering = 0
	pickWallDefQueueDepth = 0
	lastHelpPlayer = -1
	nKineticX = -1
	nKineticY = -1
	nAttHumanPlayer = 0
	nAttAIPlayer = 0
	tEveryMin = C.gameTime
	tEvery3Min = C.gameTime
	tBeaconSent = 0
	nTanksDefGrp = 0
	nAttackingUnitsToAdd = random(MAX_ATTACK_TANKS_ADD)
	nCybAttUnitsToAdd = random(MAX_ATTACK_CYBORG_ADD)
	lStopBuildDef = false
	lStopBuildDefDerricks = false
	lStopBuildDefGateway = false
	lStopTankProduction = false
	lStopBuildTankProd = false
	lStopCybEngProd = false
	lStopCybProduction = false
	lStopResearch = false
	lStopCheapResearch = false
	lStopBuildRepFacility = false
	lStopBuildingStructures = false
	lMinBaseStructBuilt = false
	lStopResLabUpgrade = false
	lStopVTOLFactBuilding = false
	lStopVTOLProduction = false
	attackCybObj = nil
	bDroidSelected = false
	-- in secs
	tBeaconTimeout = 45
	-- alternate attacks
	bAttackedHumanDerrick = false
	bAttackedByMortars = false
	bAttackedByLongRangeWeap = false
	bPowerNormalized = false
	nProd1 = 1
	tLastCybMech = C.gameTime
	nCybMechanic = 0
	tTargetTime = C.gameTime
	nArtilleryPos = 0
	
	num_aDroid = 50
	count = 0
	while count < num_aDroid do
		aDroid_Id[count] = -1
		aDroid_X[count] = -1
		aDroid_Y[count] = -1
		aDroid_counter[count] = 0
		count = count + 1
	end
	
	count = 0
	while count < MAX_PLAYERS do
		beaconX[count] = -1
		beaconY[count] = -1
		tBeacon[count] = -1
		count = count + 1
	end
	
	aPower[VERY_LOW_POWER] = 300
	aPower[LOW_POWER] = 600
	aPower[HIGH_POWER] = 1000
	
	count = 0
	while count < 11 do
		oilResTargetId[count] = -1
		oilResTargetX[count] = -1
		oilResTargetY[count] = -1
		count = count + 1
	end
	
	count = 0
	nStat = 20
	while count < nStat do
		count2 = 0
		while count2 < MAX_PLAYERS do
			aStat[count][count2] = -1
			count2 = count2 + 1
		end
		count = count + 1
	end
	
	-- max number of derricks per player
	numMaxDerricks = 40
	
	structure = getStructure(playerHQ, player)
	if structure ~= nil then
		baseX = structure.x
		baseY = structure.y
	else
		groupAddArea(buildGroup, player, 0, 0, (C.mapWidth * 128), (C.mapHeight * 128))
		if groupCountMembers(buildGroup) > 0 then
			baseX = buildGroup.x
			baseY = buildGroup.y
		else
			baseX = (128 * C.mapWidth) / 2
			baseY = (128 * C.mapHeight) / 2
		end
	end
	
	initAssignUnitToGrp()
	-- initialises all the no go areas to 0.
	-- Should be called when a new map is loaded
	initAllNoGoAreas()
	
	-- for all players, avoid attacking themselves
	createAlliance(player, player)
	
	-- makes a research available to a player regardless of its pre-requisites
	enableResearch(CyborgLegs, player)
	completeResearch(CyborgLegs, player)
	
	-- LIFE = true;
	nBaseRange = TILE * 5
	
	-- nDefend range
	updateDefendRange()
	
	-- estimate the range for the gateways and the defend range
	if nDefendRange > 0 then
		gatewaysRangeTiles = nDefendRange
	else
		if math.max(C.mapWidth, C.mapHeight) <= 92 then
			gatewaysRangeTiles = 22
		else
			if math.max(C.mapWidth, C.mapHeight) > 92 and math.max(C.mapWidth, C.mapHeight) <= 105 then
				gatewaysRangeTiles = 28
			else
				if math.max(C.mapWidth, C.mapHeight) > 105 and math.max(C.mapWidth, C.mapHeight) <= 128 then
					gatewaysRangeTiles = 36
				else
					gatewaysRangeTiles = 40
				end
			end
		end
	end
	
	-- time to force droids production. This is the time gone from last attack, if reached
	-- droids production is forced
	nAttackTime = 7000 + random(4000)
	
	-- store the numb of derricks at the beginning
	nDerricksAtStart = getNumDerricks(player)
	
	-- oilRes available in the map
	nFreeOilRes = numRemainingOilRes()
	
	-- player stats, updates nPlayersInGame
	updatePlayersStats()
	
	-- _______ AI PERSONALITY SETTINGS ________________
	SetDyDoPersonality(AIPersonality, player)
	
	-- search if gateways have been added in the map
	nRealGatewaysFound = updateGateways()
	
	-- AIstrength
	if AIstrength <= 0 or AIstrength > 5 then
		AIstrength = 1 + random(5)
	end
	
	-- initialize eventCheckTime[]
	count = 0
	while count < EVENT_CHECK_NUMBER do
		eventCheckTime[count] = C.gameTime
		eventCheckCounter[count] = 0
		count = count + 1
	end
	
	-- set trigger time
	count = 0
	while count < EVENT_CHECK_NUMBER do
		eventCheckTrigger[count] = 250
		eventCheckReport[count] = 0
		count = count + 1
	end
	-- lassat
	eventCheckTrigger[0] = 3050
	
	if aiResponsibleForPlayer(player) then
		bRunning = true
		activateAI()
	else
		shutDownThisAI()
	end
	
	printDebug(DYDOBP_RELEASE .. ", starting power: (" .. playerPower(player) .. ") ")
	displayMsg(DYDOBP_RELEASE .. ", www.obooma.net/dydo/")
end
callbackEvent(initialisedEvent, CALL_GAMEINIT)

-- =============================================
function VTOLhunter()
	if groupCountMembers(vtolHunterGr) < 0 then
		deactivateEvent(VTOLhunter)
		return
	end
end


-- ==============================print stats and debug messages ===============
function evPrintDebug()
	local _sPlPow = nil
	local _sPlInf1 = nil
	local _sPlInf2 = nil
	local _sPlInf3 = nil
	local _sPlInf4 = nil
	local _strTeams = nil
	local _sWallDef = nil
	local _sDef = nil
	local _sRes = nil
	local _sRes2 = nil
	local _str0 = nil
	local _str1 = nil
	local _str2 = nil
	local _str3 = nil
	local _str4 = nil
	local _str5 = nil
	local _sFort = nil
	local _HQx = 0
	local _HQy = 0
	local _count = 0
	
	if C.gameTime - tEveryMin >= 600 then
		printDebug1("Structs not idle: nProdSelect(" .. nProdSelect .. ") (Fac-Cyb-Res-VTOLfac)  (" .. nWorkingFact .. "-" .. nWorkingCybFac .. "-" .. nWorkingLab .. "-" .. nWorkingVTOLFac .. ") power[" .. playerPower(player) .. "] Low Power(" .. aPower[VERY_LOW_POWER] .. ") tot Tank+Cyb(" .. nTotTanks + nTotCyborgs .. ") nAttackTime(" .. C.gameTime - nTime .. "/" .. nAttackTime .. ")")
		tEveryMin = C.gameTime
	end
	
	if C.gameTime - tEvery3Min >= 1800 then
		structure = getStructure(playerHQ, player)
		if structure ~= nil then
			_HQx = structure.x
			_HQy = structure.y
		else
			_HQx = 0
			_HQy = 0
		end
		
		_count = 0
		while _count < numWallWeaps do
			_sWallDef = _sWallDef .. " [" .. _count .. "](" .. isStructureAvailable(wallWeaps[_count], player) .. ") "
			_count = _count + 1
		end
		_count = 0
		while _count < numDefStructs do
			_sDef = _sDef .. " [" .. _count .. "](" .. isStructureAvailable(defStructs[_count], player) .. ") "
			_count = _count + 1
		end
		_count = 0
		while _count < numFortressDef do
			_sFort = _sFort .. " [" .. _count .. "](" .. isStructureAvailable(fortressDef[_count], player) .. ") "
			_count = _count + 1
		end
		
		_count = 0
		while _count < 20 do
			_str0 = _str0 .. " [" .. _count .. "]" .. numResearchLeft(player, research[0][_count]) .. " "
			_count = _count + 1
		end
		while _count < 40 do
			_str1 = _str1 .. " [" .. _count .. "]" .. numResearchLeft(player, research[0][_count]) .. " "
			_count = _count + 1
		end
		while _count < numRes[0] do
			_str2 = _str2 .. " [" .. _count .. "]" .. numResearchLeft(player, research[0][_count]) .. " "
			_count = _count + 1
		end
		
		_count = 0
		while _count < 23 do
			_str3 = _str3 .. " [" .. _count .. "]" .. numResearchLeft(player, research[1][_count]) .. " "
			_count = _count + 1
		end
		while _count < numRes[1] do
			_str4 = _str4 .. " [" .. _count .. "]" .. numResearchLeft(player, research[1][_count]) .. " "
			_count = _count + 1
		end
		
		_count = 0
		while _count < numCheapRes[0] do
			_sRes2 = _sRes2 .. " [" .. _count .. "]" .. numResearchLeft(player, researchCheap[0][_count]) .. " "
			_count = _count + 1
		end
		
		_count = 0
		while _count < numRes[9] do
			_str5 = _str5 .. " [" .. _count .. "]" .. numResearchLeft(player, research[9][_count]) .. " "
			_count = _count + 1
		end
		
		_count = 0
		while _count < MAX_PLAYERS do
			if isPlayerStillLive(_count) then
				_strTeams = _strTeams .. " '" .. getPlayerName(_count) .. "' #" .. _count .. " [" .. aPlayers[TEAM_NUMBER][_count] .. "] "
			end
			_count = _count + 1
		end
		
		_count = 0
		while _count < 2 do
			if isPlayerStillLive(_count) then
				_sPlInf1 = _sPlInf1 .. " *[" .. getPlayerName(_count) .. "] RL(" .. aStat[OC_RESLABS][_count] .. ") Der(" .. aStat[OC_DERRICKS][_count] .. ") Cy-Tk-VTOL(" .. aStat[OC_CYBORGS][_count] .. "-" .. aStat[OC_TANKS][_count] .. "-" .. aStat[OC_VTOLS][_count] .. ") Pow(" .. aStat[OC_CYB_POWER][_count] .. "-" .. aStat[OC_TK_POWER][_count] .. "-" .. aStat[OC_VTOL_POWER][_count] .. ") hp(" .. aStat[OC_CYB_HP][_count] .. "-" .. aStat[OC_TK_HP][_count] .. "-" .. aStat[OC_VTOL_HP][_count] .. ")"
			end
			_count = _count + 1
		end
		while _count < 4 do
			if isPlayerStillLive(_count) then
				_sPlInf2 = _sPlInf2 .. " *[" .. getPlayerName(_count) .. "] RL(" .. aStat[OC_RESLABS][_count] .. ") Der(" .. aStat[OC_DERRICKS][_count] .. ") Cy-Tk-VTOL(" .. aStat[OC_CYBORGS][_count] .. "-" .. aStat[OC_TANKS][_count] .. "-" .. aStat[OC_VTOLS][_count] .. ") Pow(" .. aStat[OC_CYB_POWER][_count] .. "-" .. aStat[OC_TK_POWER][_count] .. "-" .. aStat[OC_VTOL_POWER][_count] .. ") hp(" .. aStat[OC_CYB_HP][_count] .. "-" .. aStat[OC_TK_HP][_count] .. "-" .. aStat[OC_VTOL_HP][_count] .. ")"
			end
			_count = _count + 1
		end
		while _count < 6 do
			if isPlayerStillLive(_count) then
				_sPlInf3 = _sPlInf3 .. " *[" .. getPlayerName(_count) .. "] RL(" .. aStat[OC_RESLABS][_count] .. ") Der(" .. aStat[OC_DERRICKS][_count] .. ") Cy-Tk-VTOL(" .. aStat[OC_CYBORGS][_count] .. "-" .. aStat[OC_TANKS][_count] .. "-" .. aStat[OC_VTOLS][_count] .. ") Pow(" .. aStat[OC_CYB_POWER][_count] .. "-" .. aStat[OC_TK_POWER][_count] .. "-" .. aStat[OC_VTOL_POWER][_count] .. ") hp(" .. aStat[OC_CYB_HP][_count] .. "-" .. aStat[OC_TK_HP][_count] .. "-" .. aStat[OC_VTOL_HP][_count] .. ")"
			end
			_count = _count + 1
		end
		while _count < MAX_PLAYERS do
			if isPlayerStillLive(_count) then
				_sPlInf4 = _sPlInf4 .. " *[" .. getPlayerName(_count) .. "] RL(" .. aStat[OC_RESLABS][_count] .. ") Der(" .. aStat[OC_DERRICKS][_count] .. ") Cy-Tk-VTOL(" .. aStat[OC_CYBORGS][_count] .. "-" .. aStat[OC_TANKS][_count] .. "-" .. aStat[OC_VTOLS][_count] .. ") Pow(" .. aStat[OC_CYB_POWER][_count] .. "-" .. aStat[OC_TK_POWER][_count] .. "-" .. aStat[OC_VTOL_POWER][_count] .. ") hp(" .. aStat[OC_CYB_HP][_count] .. "-" .. aStat[OC_TK_HP][_count] .. "-" .. aStat[OC_VTOL_HP][_count] .. ")"
			end
			_count = _count + 1
		end
		
		printDebug("nAIcheck(" .. nAIcheck .. ") gameType(" .. gameType() .. ") map(" .. C.mapWidth .. "-" .. C.mapHeight .. ") BaseRange(" .. nBaseRange / TILE .. ") gtwRange(" .. gatewaysRangeTiles .. ") DefRange(" .. nDefendRange / TILE .. ") HQ(" .. _HQx / TILE .. "-" .. _HQy / TILE .. ") Base(" .. baseX / TILE .. "-" .. baseY / TILE .. ") lMinBaseStructBuilt(" .. lMinBaseStructBuilt .. ") ")
		printDebug("Cyborgs Built: (AR-AT-AP-KK)(Error) (" .. nTotCybAR .. " - " .. nTotCybAT .. " - " .. nTotCybAP .. " - " .. nTotCybKK .. ")(" .. nTotCybErr .. ") nTotCyborgBuilt(" .. nTotCyborgBuilt .. ") nTotTankBuilt(" .. nTotTankBuilt .. ")")
		printDebug("Stats1:" .. _strTeams .. " Teams(" .. nTeam .. " )")
		printDebug("Stats2: nEnemyPlayers (" .. nEnemyPlayers .. ") nHumanPlayers(" .. nHumanPlayers .. ") nPlayersInGame(" .. nPlayersInGame .. ") Att Human Player(" .. nAttHumanPlayer .. ") Att AI(" .. nAttAIPlayer .. ") anyOilResLeft(" .. bOilResLeft .. ") nTotEnemyDroids(" .. nTotEnemyDroids .. ")")
		printDebug("Stats3:" .. _sPlInf1)
		printDebug("Stats4:" .. _sPlInf2)
		printDebug("Stats5:" .. _sPlInf3)
		printDebug("Stats1:" .. _sPlInf4)
		printDebug("Std Def: Depth(" .. pickDefQueueDepth .. ") - " .. _sDef)
		printDebug("Wall Def: Depth(" .. pickWallDefQueueDepth .. ") - " .. _sWallDef)
		printDebug("Fortresses: Depth(" .. pickFortQueueDepth .. ") - " .. _sFort)
		printDebug("Res 1: " .. _str0)
		printDebug("Res 2: " .. _str1)
		printDebug("Res 3: " .. _str2)
		printDebug("Res 4: " .. _str3)
		printDebug("Res 5: " .. _str4)
		printDebug("Cheap Res: " .. numCheapRes[0] .. " " .. _sRes2)
		printDebug("VTOL Res: " .. _str5)
		count = getTargetEnemy(true)
		printDebug("------------------------------------------------------------------")
		tEvery3Min = C.gameTime
	end
end
-- ==============================event used to fix errors===============
function evDebug()
	if nAllyBeingHelped < 0 and groupCountMembers(helpGroup) > 0 and C.gameTime - tLastHelp > 30 then
		groupAddGroup(tankDefGroup, helpGroup)
		orderGroup(tankDefGroup, DORDER_RTB)
	end
	
	-- if ( nAllyBeingHelped < 0 and helpGroup.members == 0){
	-- dbg("dbg->evDebug: ("& getPlayerName(player) &") has now no more helping units, FIXED!",player);
	-- } else { dbg("dbg->evDebug: ("& getPlayerName(player) &"): is not able to switch helping units back to tankGroup!",player); }
	
	-- Search for stucked droids
	
	cleanDroidCoordArray()
	checkIfDroidIsStuck(buildGroup)
	checkIfDroidIsStuck(buildDefGroup)
	checkIfDroidIsStuck(harvesterGroup)
end

-- -----------------------------------------------------------------
function shutDownAI()
	count = 0
	boolResult = true
	boolResult2 = false
	
	while count < MAX_PLAYERS and boolResult do
		if not friendlyPlayer(count) then
			if isPlayerStillLive(count) then
				boolResult = false
			end
		end
		count = count + 1
	end
	-- then check if this AI is dead
	if not isPlayerStillLive(player) then
		boolResult2 = true
		printDebug(" ________shutting down this AI: game lost______")
	end
	if boolResult then
		printDebug(" _________shutting down this AI: game won_______")
	end
	
	-- check if this player is dead...
	if boolResult or boolResult2 then
		shutDownThisAI()
	end
end

-- else {    displayMsg("__________("&  anyDroidsLeft(player) &")("& _nFact &")("& _nCybFact &")_________"); }


-- ----------------------------------------------------
function activateAI()
	local strMessage = nil
	-- activate all events!!
	callbackEvent(droidBuilt, CALL_NEWDROID)
	callbackEvent(AIattacked, CALL_ATTACKED)
	callbackEvent(vtolDefend, CALL_STRUCT_ATTACKED)
	-- setEventTrigger(consoleEv, inactive);
	callbackEvent(multiMsgEv, CALL_AI_MSG)
	callbackEvent(beaconEv, CALL_BEACON)
	callbackEvent(reassignPlayers, CALL_PLAYERLEFT)
	
	repeatingEvent(evDebug, 10.0)
	repeatingEvent(AIbrain, 1.0)
	repeatingEvent(buildBase, 3.0)
	repeatingEvent(buildPowerGenerators, 1.0)
	repeatingEvent(buildRepFacSuppAttack, 3.0)
	repeatingEvent(buildRepFirst, 1.0)
	repeatingEvent(defendBase, 3.0)
	repeatingEvent(defendDerrick, 3.0)
	repeatingEvent(defendGatewaysPoint, 2.0)
	delayedEvent(difficultyModifier, 0.3)
	repeatingEvent(buildAAdef, 2.5)
	repeatingEvent(doResearch, 3.0)
	repeatingEvent(manageDefCyborgs, 2.0)
	repeatingEvent(manageDefTank, 2.0)
	repeatingEvent(activateAttack, 10.0)
	repeatingEvent(manageIdleTrucks, 3.5)
	repeatingEvent(manageRepairTeam, 3.0)
	repeatingEvent(SelectCyborgTemplate, 3.0)
	repeatingEvent(SelectTankTemplate, 3.0)
	repeatingEvent(sendBackDamagedUnits, 3.0)
	repeatingEvent(showPlayerInfo, 20.0)
	repeatingEvent(truckGroupSlider, 5.0)
	repeatingEvent(unitAssignationCheck, 5.0)
	repeatingEvent(unitRepairSwitch, 2.0)
	repeatingEvent(updateBaseDetails, 20.0)
	repeatingEvent(upgradeStructures, 2.0)
	repeatingEvent(useLassat, 300.0)
	repeatingEvent(vtolEnabler, 20.0)
	callbackEvent(multiMsgEv, CALL_AI_MSG)
	callbackEvent(beaconEv, CALL_BEACON)
	repeatingEvent(shutDownAI, 0.4)
	repeatingEvent(evPrintDebug, 10.0)
	repeatingEvent(harvesterOperate, 1.0)
	repeatingEvent(AIcheck, 1.0)
	repeatingEvent(threatCheck, 3.0)
	repeatingEvent(VTOLhunter, 1.5)
	repeatingEvent(buildArtillery, 3.0)
	repeatingEvent(buildRippleRockets, 2.0)
	tFinishOilHack = C.gameTime
end


-- ================================================================
-- this event checks that most important events are not stucked
-- event 3
function AIcheck()
	local errorMSG = nil
	local errorMSG2 = nil
	local errorMSG3 = nil
	local errorMSG4 = nil
	local tTimeGone = 0
	
	-- harvestoperate would generate an error
	if C.gameTime - tFinishOilHack < 100 then
		return
	end
	
	errorMSG = "An error occurred on the Dydo-AI script player (" .. player .. "), this error message will appear only 4 times"
	errorMSG2 = "Please report the below DEBUG REPORT to http://forums.wz2100.net/ or on the AI webpage http://www.obooma.net/dydo/"
	errorMSG3 = "DEBUG REPORT: "
	
	-- TEST
	
	count = 0
	while count < EVENT_CHECK_NUMBER do
		tTimeGone = (C.gameTime - eventCheckTime[count])
		if tTimeGone > eventCheckTrigger[count] then
			if eventCheckCounter[count] < 4 then
				nAIcheck = nAIcheck + 1
				eventCheckCounter[count] = eventCheckCounter[count] + 1
				eventCheckReport[count] = eventCheckReport[count] + 1
				errorMSG3 = errorMSG3 .. "   event:" .. count .. "[" .. eventCheckTime[count] .. "] time gone:(" .. tTimeGone .. ") should be(" .. eventCheckTrigger[count] .. ") "
			end
		else
			if eventCheckReport[count] > 0 then
				eventCheckReport[count] = 0
				eventCheckCounter[count] = 0
			end
		end
		count = count + 1
	end
	
	count = 0
	while count < EVENT_CHECK_NUMBER do
		if eventCheckReport[count] > 0 and eventCheckCounter[count] < 4 and (C.gameTime - lastDisplayAIcheck) > 50 then
			printDebug1("######## AIcheck: " .. errorMSG3)
			lastDisplayAIcheck = C.gameTime
		end
		-- reactivateEvent
		-- if( count == 7 ){
		-- setEventTrigger(manageIdleTrucks, manageIdleTrucksTr);
		-- displayErrMsg("DyDo will try try to reactivate event # 7 ---- DEBUG: (" & count & ")["& eventCheckReport[count] &"] " );
		-- }
		count = count + 1
	end
	
	-- DEBUG MESSAGE
	if C.gameTime - lastDisplayAIcheck >= 600 then
		lastDisplayAIcheck = C.gameTime
	end
end

-- -----------------------------------------------------------------
function showAImessage()
	local strMessage = nil
	local bWebSite = false
	
	count = 0
	while count < MAX_PLAYERS do
		if isHumanPlayer(count) and count ~= player then
			if showAIPersonality then
				if allianceExistsBetween(count, player) then
					strMessage = "player " .. player .. " " .. DYDOBP_RELEASE .. " General " .. AIPersonality .. " Level [" .. AIstrength .. "] (Ally)"
				else
					strMessage = "player " .. player .. " " .. DYDOBP_RELEASE .. " General " .. AIPersonality .. " Level [" .. AIstrength .. "] (Enemy)"
				end
			else
				strMessage = DYDOBP_RELEASE .. " is active"
			end
			msg(strMessage, player, count)
		end
		count = count + 1
	end
	repeatingEvent(showAImessage, 600.0)
end
delayedEvent(showAImessage, 6.0)
-- -----------------------------------------------------------------
-- find my lassat
-- fire it at my attack objective.
function useLassat()
	local _targetStruct = nil
	local _loop = 0
	local _pos = 0
	local _xCoord = 0
	local _yCoord = 0
	local _targetPl = 0
	local _rnd = 0
	local _nTargets = 0
	local _mustBeHuman = false
	local _aTargets[7] = nil
	
	eventCheckTime[0] = C.gameTime
	
	_nTargets = 7
	_aTargets[0] = powGen
	_aTargets[1] = factory
	_aTargets[2] = cybFactory
	_aTargets[3] = vtolFactory
	_aTargets[4] = lassat
	_aTargets[5] = playerHQ
	_aTargets[6] = uplinkCenter
	
	_targetPl = -1
	_targetStruct = nil
	
	if not isStructureAvailable(lassat, player) then
		return
	end
	
	if AIstrength > 3 and bHasHumanEnemies(player) then
		_mustBeHuman = true
	else
		_mustBeHuman = false
	end
	
	-- find the nearest enemy player
	_targetPl = getNearestEnemyPlayer(_mustBeHuman)
	if _targetPl < 0 then
		_targetPl = getRandomEnemyPlayer(_mustBeHuman)
	end
	
	if _targetPl < 0 then
		printDebug1("#### useLassat: _targetPl < 0 (" .. _mustBeHuman .. ")")
		return
	end
	-- get a target struct
	_pos = random(_nTargets)
	_loop = 0
	while _loop < _nTargets and _targetStruct == nil do
		if AIstrength < 4 then
			initEnumStruct(false, _aTargets[_pos], _targetPl, player)
		else
			initEnumStruct(false, _aTargets[_pos], _targetPl, _targetPl)
		end
		_targetStruct = enumStruct()
		_loop = _loop + 1
		_pos = _pos + 1
		if _pos == _nTargets then
			_pos = 0
		end
	end
	
	-- target found!!
	boolResult = false
	if _targetStruct ~= nil then
		printDebug1("useLassat: target found !! _targetPl(" .. getPlayerName(_targetPl) .. ") _pos(" .. _pos .. ")")
		initEnumStruct(false, lassat, player, player)
		structure = enumStruct()
		while structure ~= nil do
			if structureComplete(structure) then
				printDebug1("Lassat (" .. structure.id .. ") fires to struct.id (" .. _targetStruct.id .. ") player (" .. getPlayerName(_targetStruct.player) .. ") ")
				skFireLassat(player, _targetStruct)
				boolResult = true
			end
			structure = enumStruct()
		end
	else
		printDebug1("useLassat: No target found, _targetPl(" .. getPlayerName(_targetPl) .. ") _loop(" .. _loop .. ")")
	end
	
	if not boolResult then
		printDebug1("useLassat: Lassat hasn`t fired ")
	end
end

-- ================================================================
--[[add lStopBuildOilDef and check whenoilRes == 0 -> lStopBuildOilDef = false
defendGatewaysPoint: buildDefGroup - defend gateways
defendBase: buildGroup/harvestGrpoup - defend base
defendDerrick buildGroup/dbuildDefGroup/harvestGrpoup def derrick]]--
function AIbrain()
	local _sWallDef = nil
	local _sDef = nil
	local _attackObj = nil
	local _nMaxCybEngineers = 0
	local _nMaxTrucks = 0
	local enemy = 0
	local nMyUnits = 0
	local nEnemyUnits = 0
	local _player = 0
	
	-- if ( gameTime - tProd1 > 600 ){
	-- addPower(500, player);
	-- tProd1 = gameTime;
	-- }
	
	eventCheckTime[1] = C.gameTime
	
	-- hack to put all at same power when debugging
	if isHumanPlayer(player) and not bPowerNormalized then
		bPowerNormalized = true
		count = playerPower(player)
		if player == 0 then
			count1 = playerPower(1)
		else
			count1 = playerPower(0)
		end
		count2 = count1 - count
		if count2 > 300 then
			addPower(player, 500)
			printDebug1(" added 500 power to player #" .. player .. "-" .. getPlayerName(player) .. ", starting was power(" .. count .. ") instead of power(" .. count1 .. ")")
		else
			printDebug1(" No need to add 500 power to player #" .. player .. "-" .. getPlayerName(player) .. ", starting was power(" .. count .. ") instead of power(" .. count1 .. ")")
		end
	end
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: AIbrain " .. player, player)
	
	-- reset alert
	if C.gameTime - alertTime > TIME_TO_RESET_ALERT then
		alertIsOn = false
		alertX = -1
		alertY = -1
		alertTime = -1
		alertLevel = ALERT_INACTIVE
	end
	
	nTotTanks = groupCountMembers(tankGroup) + groupCountMembers(tankDefGroup) + groupCountMembers(toBeRepairedTankGroup) + groupCountMembers(helpGroup)
	nTotCyborgs = groupCountMembers(cyborgDefGroup) + groupCountMembers(cyborgAttGroup) + groupCountMembers(toBeRepairedCyborgGroup)
	nMyDerricks = getNumDerricks(player)
	nPower = playerPower(player)
	nFactories = numStructsByType(factory, player)
	nVTOLFactories = numStructsByType(vtolFactory, player)
	nResLabs = numStructsByType(resLab, player)
	nCybFact = numStructsByType(cybFactory, player)
	nWorkingVTOLFac = getNumStructNotIdle(vtolFactory)
	nWorkingFact = getNumStructNotIdle(factory)
	nWorkingLab = getNumStructNotIdle(resLab)
	nWorkingCybFac = getNumStructNotIdle(cybFactory)
	-- nTotBaseDefences = numFriendlyWeapStructsInRange(player, baseX, baseY, nBaseRange+RANGETILES_DEFSTR_AROUNDBASE*TILE , false);
	nFreeOilRes = numRemainingOilRes()
	bOilResLeft = bAnyOilResLeft()
	-- nTotDerricks     = getTotDerricksMap();//nTotOilInAtStart
	-- update power levels
	
	-- check how many tanks are in tankDefGroup
	nTanksDefGrp = 0
	if C.gameTime - lastDisplayAI >= 90 and groupCountMembers(tankDefGroup) > 0 then
		initIterateGroup(tankDefGroup)
		droid = iterateGroup(tankDefGroup)
		while droid ~= nil do
			if droid.droidType == DROID_WEAPON and droid.propulsion ~= cyborgPropulsion then
				nTanksDefGrp = nTanksDefGrp + 1
			end
			droid = iterateGroup(tankDefGroup)
		end
	end
	
	if aPower[VERY_LOW_POWER] < 400 and researchFinished(cobraBody, player) and researchFinished(mediumCannon, player) then
		aPower[VERY_LOW_POWER] = 400
		aPower[LOW_POWER] = 700
		aPower[HIGH_POWER] = 1100
	end
	if aPower[VERY_LOW_POWER] < 500 and researchFinished(trackPropulsion, player) then
		aPower[VERY_LOW_POWER] = 500
		aPower[LOW_POWER] = 800
		aPower[HIGH_POWER] = 1200
	end
	
	-- reactivate all  (but the fact upgrades!!!)
	lStopTankProduction = false
	lStopBuildTankProd = false
	lStopCybEngProd = false
	lStopCybProduction = false
	lStopFactUpgrade = true
	lStopFactUpgrade2 = true
	lStopResearch = false
	lStopCheapResearch = false
	lStopBuildDef = false
	lStopBuildDefDerricks = false
	lStopBuildDefGateway = false
	lStopBuildRepFacility = false
	lStopBuildingStructures = false
	lStopResLabUpgrade = false
	lStopVTOLProduction = false
	lStopVTOLFactBuilding = false
	
	if nFactories >= structsBuildLimits[nAI_Pers][STR_TANK_FACTORY] and nResLabs >= structsBuildLimits[nAI_Pers][STR_RESLAB] and nCybFact >= structsBuildLimits[nAI_Pers][STR_CYB_FACTORY] then
		lMinBaseStructBuilt = true
	else
		lMinBaseStructBuilt = false
	end
	
	
	if C.gameTime - tLastPowerSwitch > TIME_SWITCH_WORKSTRUCT then
		tLastPowerSwitch = C.gameTime
		nProdSelect = nProdSelect + 1
		if nProdSelect == 8 then
			nProdSelect = 0
		end
	end
	
	-- =========== VERY LOW POWER =============================
	if nPower < 100 then
		lStopTankProduction = true
		lStopCybProduction = true
		lStopResearch = true
		lStopCheapResearch = true
		lStopBuildDef = true
		lStopBuildDefDerricks = true
		lStopBuildDefGateway = true
		-- lStopBuildRepFacility   = true;
		lStopBuildingStructures = true
		lStopVTOLProduction = true
		lStopVTOLFactBuilding = true
	else
		
		if nPower >= 100 and nPower < aPower[VERY_LOW_POWER] then
			if AIPersonality == AI_STANDARD then
				manageVeryLowPower()
			end
			if AIPersonality == AI_VTOL then
				manageVeryLowPower2()
			end
			if AIPersonality == AI_TURTLE then
				manageVeryLowPower3()
			end
			if AIPersonality == AI_CYBORG then
				manageVeryLowPower4()
			end
		end
	end
	
	-- always block with this power level
	-- lStopBuildDefGateway     = true;
	-- lStopVTOLFactBuilding    = true;
	-- lStopBuildingStructures  = true;//activated if not min struct reached
	
	-- ================== POWER END ==============================
	
	-- do not build too many VTOLs
	if groupCountMembers(vtolDefendGr) > 6 then
		if (groupCountMembers(vtolDefendGr)) > (nTotTanks + nTotCyborgs) * 0.33 then
			lStopVTOLProduction = true
		end
	end
	
	count = 0
	count2 = 0
	while count < numCheapRes[0] do
		if researchFinished(researchCheap[0][count], player) then
			count2 = count2 + 1
		end
		count = count + 1
	end
	if count2 == numCheapRes[0] then
		lStopCheapResearch = true
	end
	-- try to minimize the spending of money for researches
	-- if ( nWorkingLab >= 2 ){ lStopCheapResearch = true; }
	
	-- resLab upgrade
	if not lMinBaseStructBuilt and C.gameTime < 8 * TIME_MINUTE then
		lStopResLabUpgrade = true
	end
	
	-- repair Facility
	if C.gameTime < VALID_TIME_REPAIRFAC or numStructsByType(repairFacility, player) >= MAX_REPAIRFAC then
		lStopBuildRepFacility = true
	end
	
	if C.gameTime < 20 * TIME_MINUTE and numStructsByType(repairFacility, player) > 2 then
		lStopBuildRepFacility = true
	end
	
	if C.gameTime < 30 * TIME_MINUTE and numStructsByType(repairFacility, player) > 3 then
		lStopBuildRepFacility = true
	end
	
	if C.gameTime - nLastTimeBuiltRepFac < 2 * TIME_MINUTE then
		lStopBuildRepFacility = true
	end
	
	-- build def only when enough structs have been built!!
	if not lMinBaseStructBuilt and C.gameTime < TIME_HARVESTING_PHASE then
		lStopBuildDef = true
		lStopBuildDefGateway = true
		lStopBuildRepFacility = true
		lStopVTOLFactBuilding = true
		lStopVTOLProduction = true
	end
	
	-- start building gateway def a bit later
	if C.gameTime < VALID_TIME_GATEWAYDEF then
		lStopBuildDefGateway = true
	end
	
	-- defend only on alert points!!
	if defSpotX <= 0 then
		lStopBuildDef = true
	end
	
	-- have been attacked and have no troups remaining
	-- ==============================
	if C.gameTime > 12 * TIME_MINUTE and (nTotCyborgs + nTotTanks) < MIN_TOT_UNITS then
		if nPower > 100 then
			if AIPersonality == AI_CYBORG then
				lStopCybProduction = false
				if nWorkingFact >= 1 then
					lStopTankProduction = true
				end
			else
				lStopTankProduction = false
				lStopCybProduction = false
			end
		end
		
		count = numTemplatesInProduction(cybcondroid, player)
		count = count + numTemplatesInProduction(constructor, player)
		count = count + numTemplatesInProduction(constructor2, player)
		if count + groupCountMembers(cyborgConstructGroup) + groupCountMembers(buildGroup) + groupCountMembers(harvesterGroup) + groupCountMembers(buildDefGroup) >= 2 then
			lStopBuildTankProd = true
			lStopCybEngProd = true
		end
		
		if nPower < aPower[LOW_POWER] then
			lStopResearch = true
			lStopBuildDef = true
			lStopBuildDefDerricks = true
			lStopBuildDefGateway = true
			lStopBuildRepFacility = true
			lStopBuildingStructures = true
			lStopCheapResearch = true
			lStopResLabUpgrade = true
			lStopVTOLProduction = true
			lStopVTOLFactBuilding = true
		end
	else
		if not lMinBaseStructBuilt then
			_nMaxTrucks = MIN_BUILDING_TANKS + 1
			_nMaxCybEngineers = MIN_CYB_CONSTENG + 1
		else
			_nMaxTrucks = MIN_BUILDING_TANKS
			_nMaxCybEngineers = MIN_CYB_CONSTENG
		end
		
		-- Trucks & cybEng
		if groupCountMembers(buildGroup) + groupCountMembers(harvesterGroup) + groupCountMembers(buildDefGroup) < _nMaxTrucks then
			if nPower > 100 then
				lStopBuildTankProd = false
			end
		else
			lStopBuildTankProd = true
		end
		if groupCountMembers(cyborgConstructGroup) + numTemplatesInProduction(cybcondroid, player) < _nMaxCybEngineers then
			if nPower > 100 and C.gameTime > TIME_HARVESTING_PHASE then
				lStopCybEngProd = false
			end
		else
			lStopCybEngProd = true
		end
		
		-- At least one research every 4 min
		if C.gameTime - tLastResearch > 4 * TIME_MINUTE then
			lStopResearch = false
		end
		
		-- upgrades
		if lMinBaseStructBuilt then
			if researchFinished(cobraBody, player) or researchFinished(hoverPropulsion, player) then
				lStopFactUpgrade = false
			end
			if researchFinished(trackPropulsion, player) or researchFinished(phytonBody, player) then
				lStopFactUpgrade2 = false
			end
		end
		
		-- activate building of structs
		if not lMinBaseStructBuilt then
			lStopBuildingStructures = false
		end
	end
	
	
	if AIPersonality == AI_TURTLE then
		if C.gameTime - tLastbuildBaseDef > (TIME_TOFORCE_BUILDDEF_2) then
			lStopBuildDef = false
			lStopBuildDefDerricks = false
			lStopBuildDefGateway = false
		end
	else
		if C.gameTime - tLastbuildBaseDef > TIME_TOFORCE_BUILDDEF then
			lStopBuildDef = false
			lStopBuildDefDerricks = false
			lStopBuildDefGateway = false
		end
	end
	
	-- stop all for 2 minutes long but droids production
	if bFinalAttack_1vs1 and C.gameTime - tLastFinalAttack < 2 * TIME_MINUTE then
		lStopTankProduction = false
		lStopCybProduction = false
		if nPower < aPower[VERY_LOW_POWER] then
			lStopBuildTankProd = true
			lStopResearch = true
			lStopCheapResearch = true
			lStopBuildDef = true
			lStopBuildDefDerricks = true
			lStopBuildDefGateway = true
			lStopBuildRepFacility = true
			lStopBuildingStructures = true
			lStopResLabUpgrade = true
			lStopVTOLProduction = true
			lStopVTOLFactBuilding = true
		end
		nDamageLevelRepair = DAMAGE_REPAIR_LEVEL_LOW
	else
		nDamageLevelRepair = DAMAGE_REPAIR_LEVEL
	end
	
	-- power superiority check in 1vs1 games
	bForceResPowUp = false
	if nEnemyPlayers == 1 and C.gameTime > 15 * TIME_MINUTE then
		if getPowerIndex(nLastEnemyPlayer) >= getPowerIndex(player) then
			if nMyDerricks >= getNumDerricks(nLastEnemyPlayer) then
				bForceResPowUp = true
				lStopResearch = false
			end
		end
	end
	
	-- checking power in all type of games
	_player = 0
	while _player < MAX_PLAYERS and C.gameTime > 15 * TIME_MINUTE do
		if isPlayerStillLive(_player) then
			if getPowerIndex(_player) > getPowerIndex(player) then
				if nMyDerricks >= getNumDerricks(_player) then
					bForceResPowUp = true
					lStopResearch = false
				end
			end
		end
		_player = _player + 1
	end
	
	-- droid production guarantee
	if not bTankAttIsOn and AIPersonality == AI_STANDARD or AIPersonality == AI_TURTLE then
		if nTanksDefGrp < 12 then
			if nTanksDefGrp < 8 then
				if nWorkingFact < 2 then
					lStopTankProduction = false
				end
			else
				if nWorkingFact < 1 then
					lStopTankProduction = false
				end
			end
		end
	end
	
	if not bCybAttIsOn and AIPersonality == AI_CYBORG then
		if nTotCyborgs < 20 then
			if nTotCyborgs < 12 then
				if nWorkingCybFac < 2 then
					lStopCybProduction = false
				end
			else
				if nWorkingCybFac < 1 then
					lStopCybProduction = false
				end
			end
		end
	end
	
	if AIPersonality == AI_VTOL then
		if groupCountMembers(vtolDefendGr) + groupCountMembers(vtolAttGr) < 10 then
			if groupCountMembers(vtolDefendGr) + groupCountMembers(vtolAttGr) < 5 then
				if nWorkingVTOLFac < 2 then
					lStopVTOLProduction = false
				end
			else
				if nWorkingVTOLFac < 1 then
					lStopVTOLProduction = false
				end
			end
		end
	else
		if groupCountMembers(vtolDefendGr) + groupCountMembers(vtolAttGr) < 3 then
			if nWorkingVTOLFac == 0 then
				lStopVTOLProduction = false
			end
			if nWorkingVTOLFac > 1 then
				lStopVTOLProduction = true
			end
		end
	end
	if not bCybAttIsOn and AIPersonality == AI_STANDARD or AIPersonality == AI_TURTLE then
		if nTotCyborgs < 12 then
			if nTotCyborgs < 8 then
				if nWorkingCybFac < 2 then
					lStopCybProduction = false
				end
			else
				if nWorkingCybFac < 1 then
					lStopCybProduction = false
				end
			end
		end
	end
	
	-- Research guarantee
	if nTotTanks + nTotCyborgs > 16 then
		if nWorkingLab < 2 then
			lStopResearch = false
		end
	end
	
	numAAinBase = numAAinRange(player, player, baseX, baseY, nBaseRange)
	if numAAinBase < 5 and bAttackedByVTOL then
		lStopBuildDef = true
		lStopBuildDefDerricks = true
		lStopBuildDefGateway = true
	end
	
	
	if C.gameTime - lastDisplayAI >= 110 then
		lastDisplayAI = C.gameTime
	end
	
	tAIbrain = C.gameTime
end
--[[======================================================================
                              VTOL STUFF
========================================================================]]--
function vtolEnabler()
	ASSERT(player >= 0 and player < 8, "player out of bounds: vtolEnabler " .. player, player)
	dbg("vtolEnabler: __________ (" .. skVtolEnableCheck(0) .. ") 1(" .. skVtolEnableCheck(1) .. ") 7(" .. skVtolEnableCheck(7) .. ")__________", player)
	
	-- check to see if we have vtol technologies.
	if skVtolEnableCheck(player) then
		repeatingEvent(vtolStructs, 3.0)
		repeatingEvent(buildVtols, 3.0)
		repeatingEvent(manageDefVTOL, 4.0)
		-- setEventTrigger(buildAAdef,	buildAAdefTr);
		-- setEventTrigger(vtolAttack,	vtolAttackTr);
		-- turn off this event.
		deactivateEvent(vtolEnabler)
	end
end
-- dbg("----I CAN USE VTOLS----", me);

-- --------------------------------------------------------------------
function defFromLongRangeWeap()
	local _nCBSense = 0
	local _nMortar = 0
	local _nBombard = 0
	local _nPepperpot = 0
	local _nRippleRocket = 0
	
	--[[if( !aiResponsibleForPlayer(player) )
		{
			setEventTrigger(defFromLongRangeWeap, inactive);
		}
		else
		{]]--
	if nKineticX < 0 or nKineticY < 0 then
		deactivateEvent(defFromLongRangeWeap)
		return
	end
	
	-- dbg("dbg->defFromLongRangeWeap: Activated attacked in coord ("& nKineticX/TILE &"-"& nKineticY/TILE &")",player);
	-- check if CB tower has been build in range of myattacked object
	-- alertX&Y are based on enemyBaseObj
	_nCBSense = numStructinRange(CBSense, player, nKineticX, nKineticY, 6 * TILE)
	_nMortar = numStructinRange(defMortar, player, nKineticX, nKineticY, 6 * TILE)
	_nBombard = numStructinRange(defBombard, player, nKineticX, nKineticY, 6 * TILE)
	_nPepperpot = numStructinRange(defPepperpot, player, nKineticX, nKineticY, 6 * TILE)
	_nRippleRocket = numStructinRange(defRippleRockets, player, nKineticX, nKineticY, 6 * TILE)
	
	droid = closestDroidCanBuild(buildDefGroup, nKineticX, nKineticY)
	if droid == nil then
		droid = closestIdleDroid(buildGroup, buildX, buildY)
	end
	if droid == nil then
		return
	end
	
	-- dbg("dbg->defFromLongRangeWeap, build("& buildX/TILE &"-"& buildY/TILE &") alert("& alertX/TILE &"-"& alertY/TILE &") attacked in ("& nKineticX/TILE &"-"& nKineticY/TILE &")",player);
	buildX = nKineticX
	buildY = nKineticY
	
	if bAttackedByMortars then
		if isStructureAvailable(CBSense, player) then
			if _nCBSense == 0 then
				__result, buildX, buildY = pickStructLocation(CBSense, buildX, buildY, player)
				if __result then
					if droidCanReach(droid, buildX, buildY) then
						orderDroidStatsLoc(droid, DORDER_BUILD, CBSense, buildX, buildY)
					end
				end
			end
		end
		
		-- Defences
		if isStructureAvailable(defRippleRockets, player) then
			if _nRippleRocket < 1 then
				__result, buildX, buildY = pickStructLocation(defRippleRockets, buildX, buildY, player)
				if __result then
					if droidCanReach(droid, buildX, buildY) then
						orderDroidStatsLoc(droid, DORDER_BUILD, defRippleRockets, buildX, buildY)
					end
				end
			end
		else
			if isStructureAvailable(defPepperpot, player) then
				if _nPepperpot < 2 then
					__result, buildX, buildY = pickStructLocation(defPepperpot, buildX, buildY, player)
					if __result then
						if droidCanReach(droid, buildX, buildY) then
							orderDroidStatsLoc(droid, DORDER_BUILD, defPepperpot, buildX, buildY)
						end
					end
				end
			else
				if isStructureAvailable(defBombard, player) then
					if _nBombard < 3 then
						__result, buildX, buildY = pickStructLocation(defBombard, buildX, buildY, player)
						if __result then
							if droidCanReach(droid, buildX, buildY) then
								orderDroidStatsLoc(droid, DORDER_BUILD, defBombard, buildX, buildY)
							end
						end
					end
				else
					if isStructureAvailable(defMortar, player) then
						if _nMortar < 3 then
							__result, buildX, buildY = pickStructLocation(defMortar, buildX, buildY, player)
							if __result then
								if droidCanReach(droid, buildX, buildY) then
									orderDroidStatsLoc(droid, DORDER_BUILD, defMortar, buildX, buildY)
								end
							end
						end
					end
				end
			end
		end
	end
	
	-- dbg("dbg->defFromLongRangeWeap, attacked by mortars CBSense("& _nCBSense &") mortar("& _nMortar &") Bombard("& _nBombard &") Pepp("& _nPepperpot &")",player);
	if bAttackedByLongRangeWeap then
		if isStructureAvailable(CBSense, player) then
			if _nCBSense == 0 then
				__result, buildX, buildY = pickStructLocation(CBSense, buildX, buildY, player)
				if __result then
					if droidCanReach(droid, buildX, buildY) then
						orderDroidStatsLoc(droid, DORDER_BUILD, CBSense, buildX, buildY)
					end
				end
			end
		end
		-- defense
		if isStructureAvailable(defRippleRockets, player) then
			if _nRippleRocket < 1 then
				__result, buildX, buildY = pickStructLocation(defRippleRockets, buildX, buildY, player)
				if __result then
					if droidCanReach(droid, buildX, buildY) then
						orderDroidStatsLoc(droid, DORDER_BUILD, defRippleRockets, buildX, buildY)
					end
				end
			end
		end
	end
	
	-- dbg("dbg->defFromLongRangeWeap, attacked by mortars CBSense("& _nCBSense &") mortar("& _nMortar &") Bombard("& _nBombard &") Pepp("& _nPepperpot &")",player);
	
	deactivateEvent(defFromLongRangeWeap)
end
-- }

-- --------------------------------------------------------------------
function buildAAdef()
	local _numAAdefInRange = 0
	local _rnd = 0
	
	if not researchFinished(HurricaneAASite, player) then
		return
	end
	
	dbg("buildAAdef: __________ (" .. lMinBaseStructBuilt .. ")(" .. numAAinBase .. ") attbyVTOL(" .. bAttackedByVTOL .. ") time (" .. C.gameTime - tLastAAbuilt .. ") < 300", player)
	
	-- do not set to inactive because AA def can be destroyed!!
	if numAAinBase >= MIN_AA_INBASERANGE or (not lMinBaseStructBuilt and C.gameTime < 8 * TIME_MINUTE) then
		return
	end
	-- do not set to inactive because AA def can be destroyed!!
	if numAAinBase >= 2 and not bAttackedByVTOL then
		return
	end
	if C.gameTime - tLastAAbuilt < 300 then
		return
	end
	
	-- pick up the position
	nAAPos = nAAPos + 1
	if nAAPos > 3 then
		nAAPos = 0
	end
	if nAAPos == 0 then
		buildX = baseX + (5 * TILE)
		buildY = baseY + (5 * TILE)
	end
	if nAAPos == 1 then
		buildX = baseX + (5 * TILE)
		buildY = baseY - (5 * TILE)
	end
	if nAAPos == 2 then
		buildX = baseX - (5 * TILE)
		buildY = baseY + (5 * TILE)
	end
	if nAAPos == 3 then
		buildX = baseX - (5 * TILE)
		buildY = baseY - (5 * TILE)
	end
	
	if numAAinBase < 2 then
		buildX = baseX
		buildX = baseY
	end
	if numAAinBase == 6 then
		buildX = baseX
		buildX = baseY
	end
	
	droid = closestDroidCanBuild(buildDefGroup, buildX, buildY)
	if droid == nil then
		droid = closestIdleDroid(buildGroup, buildX, buildY)
	end
	
	-- build AA defenses.
	if droid == nil then
		displayMsg("buildAAdef: No idle truck found")
		return
	end
	displayMsg("buildAAdef: truck found")
	
	-- find best defense we can build.
	count = 0
	count2 = -1
	while count < numGenAA do
		if isStructureAvailable(vtolGenStruct[count], player) then
			count2 = count
		end
		count = count + 1
	end
	if count2 >= 0 then
		boolResult, buildX, buildY = pickStructLocation(vtolGenStruct[count2], buildX, buildY, player)
		-- build a vtol defense near the attacked struct...
		if boolResult and droidCanReach(droid, buildX, buildY) then
			displayMsg("buildAAdef: droid (" .. droid.id .. ")build AA def [" .. count2 .. "] at (" .. buildX / TILE .. "-" .. buildY / TILE .. ")")
			orderDroidStatsLoc(droid, DORDER_BUILD, vtolGenStruct[count2], buildX, buildY)
			tLastAAbuilt = C.gameTime
		end
	else
		displayMsg("buildAAdef: No AA def struc found")
	end
end


-- ----------------------------------------------
-- (CALL_STRUCT_ATTACKED, player, ref structure, ref enemyBaseObject)
function vtolDefend(_structure, _enemyBaseObject)
	if _structure.player ~= player then return end
	structure, enemyBaseObject = _structure, _enemyBaseObject -- wz2lua: probably these can be used as function arguments directly
	local _numAAdefInRange = 0
	local _dist = 0
	
	if enemyBaseObject ~= nil then
		if enemyBaseObject.type == OBJ_DROID then
			if isVtol(objToDroid(enemyBaseObject)) then
				bAttackedByVTOL = true
				if structure ~= nil then
					_dist = distBetweenTwoPoints(structure.x, structure.y, baseX, baseY)
				else
					_dist = distBetweenTwoPoints(enemyBaseObject.x, enemyBaseObject.y, baseX, baseY)
				end
				
				if _dist / TILE > (nDefendRange / TILE) * 3 and _dist > nBaseRange then
					return
				end
				
				droid = closestDroidCanBuild(buildDefGroup, baseX, baseY)
				if droid == nil then
					droid = closestIdleDroid(buildGroup, baseX, baseY)
				end
				
				-- build AA defenses.
				if droid ~= nil then
					if structure ~= nil then
						_numAAdefInRange = numAAinRange(player, player, structure.x, structure.y, RANGE_BUILD_AADEF())
						if playerPower(player) > 100 or random(10) > 4 then
							if _numAAdefInRange < MAX_AADEF_INRANGE then
								buildX = structure.x
								buildY = structure.y
								
								-- find best defense we can build.
								count = 0
								count2 = -1
								while count < numGenAA do
									if isStructureAvailable(vtolGenStruct[count], player) then
										count2 = count
									end
									count = count + 1
								end
								if count2 >= 0 then
									boolResult, buildX, buildY = pickStructLocation(vtolGenStruct[count2], buildX, buildY, player)
									-- build a vtol defense near the attacked struct...
									if boolResult and droidCanReach(droid, buildX, buildY) then
										dbg("dbg->vtolDefend: build AA def [" .. count2 .. "] at (" .. buildX / TILE .. "-" .. buildY / TILE .. "), tot AA in struct range (" .. _numAAdefInRange .. ") _dist(" .. _dist / TILE .. ")", player)
										printDebug1("vtolDefend: build AA def [" .. count2 .. "] at (" .. buildX / TILE .. "-" .. buildY / TILE .. "), tot AA in struct range (" .. _numAAdefInRange .. ") _dist(" .. _dist / TILE .. ")")
										orderDroidStatsLoc(droid, DORDER_BUILD, vtolGenStruct[count2], buildX, buildY)
										tLastAAbuilt = C.gameTime
									end
								end
							end
						end
					end
				end
			end
		end
	end
end
callbackEvent(vtolDefend, CALL_STRUCT_ATTACKED)

-- else { dbg("dbg->vtolDefend: cannt build AA def _numAAdefInRange/max("& _numAAdefInRange &"/"& MAX_AADEF_INRANGE &") power("& playerPower(player) &")",player); }
-- else { dbg("dbg->vtolDefend: not enough power ("& playerPower(player) &") to build AA def _dist ("& _dist/TILE &")",player); }
-- else { dbg("dbg->vtolDefend: structure attacked is NULLOBJECT",player); }
-- else { dbg("dbg->vtolDefend: idle droid not found",player); }

-- ------------------ build VTOL structs -----------------------
function vtolStructs()
	local _totalVTOLS = 0
	local _numVtolFacs = 0
	local _numRearmPads = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: vtolStructs " .. player, player)
	-- displayMsg("vtolStructs: vtolStructs event called");
	
	if not isStructureAvailable(vtolFactory, player) then
		return
	end
	
	-- see how many vtol factories we already have
	_numVtolFacs = nVTOLFactories
	_numRearmPads = numStructsByType(vtolPad, player)
	_totalVTOLS = groupCountMembers(vtolDefendGr) + groupCountMembers(vtolAttGr)
	
	-- see if we have enough rearm pads
	if (_numRearmPads * (4 / 3)) <= (_totalVTOLS) and _totalVTOLS > 0 then
		buildRearmPads()
	end
	
	if lStopVTOLFactBuilding then
		return
	end
	
	-- if ( gameTime - lastDisplayAI >= 90 ){
	-- displayMsg("vtolStructs: vtolStructs ("& _numVtolFacs &"/"& structsBuildLimits[STR_VTOL_FACTORY] &")");
	-- }
	if _numVtolFacs < structsBuildLimits[nAI_Pers][STR_VTOL_FACTORY] and C.gameTime - tLastVTOLFactBuild > 900 then
		buildX = baseX
		buildY = baseY
		boolResult, buildX, buildY = pickStructLocation(vtolFactory, buildX, buildY, player)
		if boolResult == true then
			droid = closestDroidCanBuild(buildGroup, buildX, buildY)
			if droid ~= nil then
				if droidCanReach(droid, buildX, buildY) then
					orderDroidStatsLoc(droid, DORDER_BUILD, vtolFactory, buildX, buildY)
					tLastVTOLFactBuild = C.gameTime
				end
			end
		end
	end
end
-- else { displayMsg("vtolStructs: cannot find an idle buildTruck"); }
-- else { displayMsg("#### vtolStructs: CANNOT PICK UP VTOL FACTORY LOCATION "); }
-- else { displayMsg("vtolStructs: MAX VTOL FACT REACHED "); }

-- ------------- build VTOL droids --------------------
function buildVtols()
	local _totalVTOLS = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: buildVtols " .. player, player)
	
	-- displayMsg("buildVtols: buildVtols event called - 1 nProdSelect("& nProdSelect &") lStopVTOLProduction("& lStopVTOLProduction &") lMinBaseStructBuilt("& lMinBaseStructBuilt &")");
	
	if lStopVTOLProduction then
		return
	end
	
	_totalVTOLS = groupCountMembers(vtolDefendGr) + groupCountMembers(vtolAttGr)
	-- got enough vtols?
	if getDroidCount(player) >= MAX_DROIDS then
		return
	end
	if (_totalVTOLS >= MAX_VTOLS and AIPersonality ~= AI_VTOL) or (_totalVTOLS >= MAX_VTOLS_PERS2 and AIPersonality == AI_VTOL) then
		return
	end
	
	-- build vtols
	boolResult = true
	initEnumStruct(false, vtolFactory, player, player)
	structure = enumStruct()
	while structure ~= nil and boolResult do
		if structureIdle(structure) then
			vtolFactoryBuildVtol(structure)
			boolResult = false
		end
		structure = enumStruct()
	end
end

-- ======================================================
function manageDefVTOL()
	local _dist = 0
	local _nVTOLSRequired = 0
	local _dbgString = nil
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: manageDefVTOL " .. player, player)
	
	if attTargetVTOL ~= nil then
		_dist = distBetweenTwoPoints(attTargetVTOL.x, attTargetVTOL.y, baseX, baseY)
	end
	-- dbg("attTarget != NULLOBJECT; VTOLs ("& vtolDefendGr.members &") idle("& idleGroup(vtolDefendGr) &") alertIsOn("& alertIsOn &") alertTime("& alertTime &") tDefVtolAction("& tDefVtolAction &") isDerr("& bVTOLTargetIsDerrick &") dist("& _dist/TILE &"/"& nDefendRange/TILE &") AA("& numEnemyAAInRange(attTargetVTOL.x, attTargetVTOL.y, AA_THREAT_RANGE) &")",player);
	if defTargetVTOL ~= nil then
		_dist = distBetweenTwoPoints(defTargetVTOL.x, defTargetVTOL.y, baseX, baseY)
	end
	-- dbg("defTarget != NULLOBJECT; VTOLs ("& vtolDefendGr.members &") idle("& idleGroup(vtolDefendGr) &") alertIsOn("& alertIsOn &") alertTime("& alertTime &") tDefVtolAction("& tDefVtolAction &") isDerr("& bVTOLTargetIsDerrick &") dist("& _dist/TILE &"/"& nDefendRange/TILE &") AA("& numEnemyAAInRange(defTargetVTOL.x, defTargetVTOL.y, AA_THREAT_RANGE) &")",player);
	-- if ( defTargetVTOL == NULLOBJECT and attTargetVTOL == NULLOBJECT){
	-- dbg("Targets == NULLOBJECTS; VTOLs ("& vtolDefendGr.members &") idle("& idleGroup(vtolDefendGr) &") alertIsOn("& alertIsOn &") alertTime("& alertTime &") tDefVtolAction("& tDefVtolAction &") isDerr("& bVTOLTargetIsDerrick &") ",player);
	-- }
	
	if groupCountMembers(vtolDefendGr) == 0 then
		targetPlayerVTOL = -1
		attTargetVTOL = nil
		defTargetVTOL = nil
		return
	end
	
	if targetPlayerVTOL >= 0 and targetPlayerVTOL < 8 then
		if friendlyPlayer(targetPlayerVTOL) then
			targetPlayerVTOL = -1
			attTargetVTOL = nil
			defTargetVTOL = nil
		end
	end
	
	if alertIsOn then
		attTargetVTOL = nil
		if idleGroup(vtolDefendGr) == 0 then
			return
		end
	else
		if idleGroup(vtolDefendGr) < (groupCountMembers(vtolDefendGr)) * 0.8 then
			return
		end
	end
	
	-- VTOL are attacking something, check target is still valid and have enough VTOLs
	if bVTOLTargetIsDerrick then
		_nVTOLSRequired = MIN_VTOLS_ATTACK_DERRICK
	else
		_nVTOLSRequired = MIN_VTOLS_ATTACK_BASE
	end
	
	if attTargetVTOL ~= nil then
		_dist = distBetweenTwoPoints(attTargetVTOL.x, attTargetVTOL.y, baseX, baseY)
		if _dist > nDefendRange and (groupCountMembers(vtolDefendGr) < _nVTOLSRequired or attTargetVTOL.type == OBJ_DROID) then
			attTargetVTOL = nil
		end
	end
	-- orderGroup( vtolDefendGr, DORDER_RTR );
	
	-- reset defTarget is neat to many AA defences
	if defTargetVTOL ~= nil then
		if groupCountMembers(vtolDefendGr) <= numEnemyAAInRange(defTargetVTOL.x, defTargetVTOL.y, AA_THREAT_RANGE()) * 3 then
			defTargetVTOL = nil
		end
	end
	-- orderGroup( vtolDefendGr, DORDER_RTR );
	
	-- ------------------------------------
	if alertIsOn then
		attTargetVTOL = nil
		
		-- set defTarget, this is required in case a long range was set as Target
		-- and in the meanwhile it happen to got attacked by groud troops. In this
		-- case DyDo has to reset the target.
		if C.gameTime - tTargetTime > 1 * TIME_MINUTE then
			defTargetVTOL = nil
		end
		
		if defTargetVTOL ~= nil then
			if not friendlyPlayer(defTargetVTOL.player) then
				orderGroupObj(vtolDefendGr, DORDER_ATTACK, defTargetVTOL)
				tDefVtolAction = C.gameTime
			end
		else
			if alertX > 0 and alertY > 0 then
				defTargetVTOL = objDroidTargetInRange(alertX, alertY, TILE * 12, true)
				if defTargetVTOL == nil then
					defTargetVTOL = objStrTargetInRange(alertX, alertY, TILE * 12)
				end
			end
			if defTargetVTOL ~= nil then
				orderGroupObj(vtolDefendGr, DORDER_ATTACK, defTargetVTOL)
				tDefVtolAction = C.gameTime
				bVTOLTargetIsDerrick = false
			end
		end
	else
		if groupCountMembers(vtolDefendGr) >= MIN_VTOLS_DEFEND_BASE then
			if attTargetVTOL == nil then
				attTargetVTOL = objStrTargetInRange(baseX, baseY, nDefendRange)
				if attTargetVTOL ~= nil then
					targetPlayerVTOL = attTargetVTOL.player
					bVTOLTargetIsDerrick = false
				end
			end
			-- displayMsg("manageDefVTOL: found TGT STR def range");
			if attTargetVTOL == nil then
				attTargetVTOL = objDroidTargetInRange(baseX, baseY, nDefendRange, true)
				if attTargetVTOL ~= nil then
					targetPlayerVTOL = attTargetVTOL.player
					bVTOLTargetIsDerrick = false
				end
			end
		end
		-- displayMsg("manageDefVTOL: found TGT DROID def range");
		
		-- getAAStruct
		-- ================== Search target = AA structs =========================
		if groupCountMembers(vtolDefendGr) >= MIN_VTOLS_ATTACK_DERRICK then
			if attTargetVTOL == nil then
				attTargetVTOL = getAAStruct(true)
				-- displayMsg("manageDefVTOL: search TGT undefended AA def");
				if attTargetVTOL ~= nil then
					targetPlayerVTOL = attTargetVTOL.player
					bVTOLTargetIsDerrick = true
				end
			end
		end
		-- displayMsg("manageDefVTOL: found TGT undefended AA def");
		
		-- ================== Search target = Enemy Derricks =========================
		if groupCountMembers(vtolDefendGr) >= MIN_VTOLS_ATTACK_DERRICK then
			if attTargetVTOL == nil then
				attTargetVTOL = objHumanDerrick(true, 1, 0)
				if attTargetVTOL ~= nil then
					targetPlayerVTOL = attTargetVTOL.player
					bVTOLTargetIsDerrick = true
				end
			end
			-- displayMsg("manageDefVTOL: found TGT Human Derrick ");
			if attTargetVTOL == nil then
				attTargetVTOL = undefendedEnemyDerrick(true)
				-- displayMsg("manageDefVTOL: search TGT undefended Derrick ");
				if attTargetVTOL ~= nil then
					targetPlayerVTOL = attTargetVTOL.player
					bVTOLTargetIsDerrick = true
				end
			end
		end
		-- displayMsg("manageDefVTOL: found TGT undefended Derrick ");
		
		-- ================== Search target = Enemy Bases =========================
		if groupCountMembers(vtolDefendGr) >= MIN_VTOLS_ATTACK_BASE then
			if attTargetVTOL == nil then
				count = 0
				while attTargetVTOL == nil and count < 5 do
					if targetPlayerVTOL < 0 then
						targetPlayerVTOL = getTargetEnemy(false)
						if targetPlayerVTOL < 0 then
							targetPlayerVTOL = getRandomEnemyPlayer(false)
						end
					end
					if targetPlayerVTOL > 0 then
						attTargetVTOL = getVTOLstructTarget()
					end
					if attTargetVTOL == nil then
						targetPlayerVTOL = -1
					else
						bVTOLTargetIsDerrick = false
					end
					count = count + 1
				end
			end
		end
		
		
		-- if ( attTargetVTOL != NULLOBJECT ){
		-- displayMsg("manageDefVTOL: found TGT enemy base targetPlayerVTOL("& targetPlayerVTOL &")");
		-- } else {
		-- displayMsg("manageDefVTOL: NO TARGETS FOUND !!!");
		-- }
		
		
		if bVTOLTargetIsDerrick then
			_nVTOLSRequired = MIN_VTOLS_ATTACK_DERRICK
		else
			_nVTOLSRequired = MIN_VTOLS_ATTACK_BASE
		end
		
		-- ================== Target is not NULLOBJECT =====================
		if attTargetVTOL ~= nil then
			_dist = distBetweenTwoPoints(attTargetVTOL.x, attTargetVTOL.y, baseX, baseY)
			if _dist > nDefendRange then
				count2 = numEnemyAAInRange(attTargetVTOL.x, attTargetVTOL.y, AA_THREAT_RANGE())
				if groupCountMembers(vtolDefendGr) < count2 * 3 or groupCountMembers(vtolDefendGr) < _nVTOLSRequired then
					attTargetVTOL = nil
					targetPlayerVTOL = -1
					return
				end
				
				-- re-attacking the enemy base
				if idleGroup(vtolDefendGr) >= (groupCountMembers(vtolDefendGr)) * 0.8 then
					orderGroupObj(vtolDefendGr, DORDER_ATTACK, attTargetVTOL)
					tDefVtolAction = C.gameTime
				end
			else
				if not friendlyPlayer(attTargetVTOL.player) then
					if idleGroup(vtolDefendGr) >= (groupCountMembers(vtolDefendGr)) * 0.8 then
						orderGroupObj(vtolDefendGr, DORDER_ATTACK, attTargetVTOL)
						tDefVtolAction = C.gameTime
					end
				end
			end
		end
	end
end

-- if (_dist > nDefendRange){
-- if ( attTargetVTOL != NULLOBJECT )
-- enderlse alertIsOn

-- ===========================  END VTOL STUFF ========================================
-- event 8
function buildBase()
	local _f = 0
	local _r = 0
	local _c = 0
	local _v = 0
	local _h = 0
	local _l = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: buildBase " .. player, player)
	eventCheckTime[2] = C.gameTime
	
	if lStopBuildingStructures then
		return
	end
	
	_f = nFactories
	_r = nResLabs
	_c = nCybFact
	_v = nVTOLFactories
	_h = numStructsByType(playerHQ, player)
	_l = numStructsByType(lassat, player)
	
	boolResult = true
	droid = closestDroidCanBuild(buildGroup, baseX, baseY)
	
	if droid == nil then
		return
	end
	
	
	-- check PlayerHQ first
	if _h == 0 and isStructureAvailable(playerHQ, player) then
		buildX = baseX
		buildY = baseY
		boolResult, buildX, buildY = pickStructLocation(playerHQ, buildX, buildY, player)
		if boolResult then
			if droidCanReach(droid, buildX, buildY) then
				orderDroidStatsLoc(droid, DORDER_BUILD, playerHQ, buildX, buildY)
				boolResult = false
			end
		end
	end
	
	-- check factory as second
	if _f == 0 and isStructureAvailable(factory, player) and boolResult then
		buildX = baseX
		buildY = baseY
		boolResult, buildX, buildY = pickStructLocation(factory, buildX, buildY, player)
		if boolResult then
			if droidCanReach(droid, buildX, buildY) then
				orderDroidStatsLoc(droid, DORDER_BUILD, factory, buildX, buildY)
				boolResult = false
			end
		end
	end
	
	-- check resLab
	if _r == 0 and isStructureAvailable(resLab, player) and boolResult then
		buildX = baseX
		buildY = baseY
		boolResult, buildX, buildY = pickStructLocation(resLab, buildX, buildY, player)
		if boolResult then
			if droidCanReach(droid, buildX, buildY) then
				orderDroidStatsLoc(droid, DORDER_BUILD, resLab, buildX, buildY)
				boolResult = false
			end
		end
	end
	
	-- check cybfactory
	if _c == 0 and isStructureAvailable(cybFactory, player) and boolResult then
		buildX = baseX
		buildY = baseY
		boolResult, buildX, buildY = pickStructLocation(cybFactory, buildX, buildY, player)
		if boolResult then
			if droidCanReach(droid, buildX, buildY) then
				orderDroidStatsLoc(droid, DORDER_BUILD, cybFactory, buildX, buildY)
				boolResult = false
			end
		end
	end
	
	-- check lassat
	if _l == 0 and isStructureAvailable(lassat, player) and boolResult then
		buildX = baseX
		buildY = baseY
		boolResult, buildX, buildY = pickStructLocation(lassat, buildX, buildY, player)
		if boolResult then
			if droidCanReach(droid, buildX, buildY) then
				orderDroidStatsLoc(droid, DORDER_BUILD, lassat, buildX, buildY)
				boolResult = false
			end
		end
	end
	
	
	-- displayMsg("buildBase: _f("& _f &") _r("& _r &") _c("& _c &") _v("& _v &") ");
	-- displayMsg("buildBase: lMinBaseStructBuilt("& lMinBaseStructBuilt &") nStructToBeBuilt("& nStructToBeBuilt &") nAI_Pers("& nAI_Pers &") ("& structsBuildLimits[nAI_Pers][STR_TANK_FACTORY] &")("& structsBuildLimits[nAI_Pers][STR_RESLAB] &")("& structsBuildLimits[nAI_Pers][STR_CYB_FACTORY] &")("& structsBuildLimits[nAI_Pers][STR_VTOL_FACTORY] &") ");
	
	-- just validate the below rows
	-- droid = getADroid(buildGroup);
	
	if boolResult then
		if nStructToBeBuilt >= 4 then
			nStructToBeBuilt = 0
		end
		
		if nStructToBeBuilt == STR_TANK_FACTORY and _f >= structsBuildLimits[nAI_Pers][STR_TANK_FACTORY] then
			nStructToBeBuilt = nStructToBeBuilt + 1
		end
		
		if nStructToBeBuilt == STR_RESLAB and _r >= structsBuildLimits[nAI_Pers][STR_RESLAB] then
			nStructToBeBuilt = nStructToBeBuilt + 1
		end
		
		if nStructToBeBuilt == STR_CYB_FACTORY and _c >= structsBuildLimits[nAI_Pers][STR_CYB_FACTORY] then
			nStructToBeBuilt = nStructToBeBuilt + 1
		end
		
		if nStructToBeBuilt == STR_VTOL_FACTORY and _v >= structsBuildLimits[nAI_Pers][STR_VTOL_FACTORY] and isStructureAvailable(vtolFactory, player) then
			nStructToBeBuilt = nStructToBeBuilt + 1
		end
		
		-- all base structs have been built!
		if nStructToBeBuilt == 4 or (nStructToBeBuilt == 3 and not isStructureAvailable(vtolFactory, player)) then
			nStructToBeBuilt = 0
			return
		end
		
		-- displayMsg("buildBase: nStructToBeBuilt("& nStructToBeBuilt &") ");
		if isStructureAvailable(structs[nStructToBeBuilt], player) then
			buildX = baseX
			buildY = baseY
			__result, buildX, buildY = pickStructLocation(structs[nStructToBeBuilt], buildX, buildY, player)
			if __result then
				droid = closestDroidCanBuild(buildGroup, buildX, buildY)
				if droid == nil and groupCountMembers(buildGroup) < 2 then
					droid = pickCybEng(true)
				end
				if droid ~= nil then
					if droidCanReach(droid, buildX, buildY) then
						orderDroidStatsLoc(droid, DORDER_BUILD, structs[nStructToBeBuilt], buildX, buildY)
						nStructToBeBuilt = nStructToBeBuilt + 1
					end
				end
			end
		end
	end
end
-- if( droid != NULLOBJECT and boolResult)
-- -----------------------------------------
function sendBackDamagedUnits()
	eventCheckTime[3] = C.gameTime
	if getStructure(repairFacility, player) ~= nil and groupCountMembers(toBeRepairedTankGroup) > 0 then
		initIterateGroup(toBeRepairedTankGroup)
		droid = iterateGroup(toBeRepairedTankGroup)
		while droid ~= nil do
			if droid.order ~= DORDER_RTR then
				orderDroid(droid, DORDER_RTR)
			end
			-- displayMsg("*** sendBackDamagedUnits: Order droid ("& droid.id &") RTR with health ("& droid.health &") in group toBeRepairedTankGroup ("& toBeRepairedTankGroup.members &")");
			droid = iterateGroup(toBeRepairedTankGroup)
		end
		
		initIterateGroup(toBeRepairedCyborgGroup)
		droid = iterateGroup(toBeRepairedCyborgGroup)
		while droid ~= nil do
			if droid.order ~= DORDER_RTR then
				orderDroid(droid, DORDER_RTR)
			end
			-- displayMsg("*** sendBackDamagedUnits: Order droid ("& droid.id &") RTR with health ("& droid.health &") in group toBeRepairedTankGroup ("& toBeRepairedCyborgGroup.members &")");
			droid = iterateGroup(toBeRepairedCyborgGroup)
		end
	else
		initIterateGroup(toBeRepairedTankGroup)
		droid = iterateGroup(toBeRepairedTankGroup)
		while droid ~= nil do
			if droid.order ~= DORDER_RTB and droid.order ~= DORDER_RTR then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) > nBaseRange then
					orderDroid(droid, DORDER_RTB)
				end
			end
			-- else{ displayMsg("*** sendBackDamagedUnits: damaged droid ("& droid.id &") already sent back to repair "); }
			
			droid = iterateGroup(toBeRepairedTankGroup)
		end
		
		initIterateGroup(toBeRepairedCyborgGroup)
		droid = iterateGroup(toBeRepairedCyborgGroup)
		while droid ~= nil do
			if droid.order ~= DORDER_RTB and droid.order ~= DORDER_RTR then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) > nBaseRange then
					orderDroid(droid, DORDER_RTB)
				end
			end
			-- else{ displayMsg("*** sendBackDamagedUnits: damaged droid ("& droid.id &") already sent back to repair "); }
			
			droid = iterateGroup(toBeRepairedCyborgGroup)
		end
	end
end

-- =============================================0
function unitRepairSwitch()
	eventCheckTime[4] = C.gameTime
	-- displayMsg("unitRepairSwitch: unitRepairSwitch START ");
	
	-- Check for untis to be repaired
	if getStructure(repairFacility, player) ~= nil or groupCountMembers(repairGroup) > 0 then
		initIterateGroup(tankDefGroup)
		droid = iterateGroup(tankDefGroup)
		while droid ~= nil do
			if droid.health < nDamageLevelRepair then
				groupAddDroid(toBeRepairedTankGroup, droid)
				orderDroid(droid, DORDER_RTR)
			end
			-- displayMsg("*** unitRepairSwitch1: move damaged tankDefGroup to toBeRepairedTankGroup ("& droid.id &") with health ("& droid.health &") added in group toBeRepairedTankGroup ("& toBeRepairedTankGroup.members &")");
			droid = iterateGroup(tankDefGroup)
		end
		
		-- attack tanks
		initIterateGroup(tankGroup)
		droid = iterateGroup(tankGroup)
		while droid ~= nil do
			if droid.health < nDamageLevelRepair and droid.propulsion ~= TrackedProp then
				groupAddDroid(toBeRepairedTankGroup, droid)
				orderDroid(droid, DORDER_RTR)
			end
			-- displayMsg("*** unitRepairSwitch1: move damaged tankGroup to toBeRepairedTankGroup ("& droid.id &") with health ("& droid.health &") added in group toBeRepairedTankGroup ("& toBeRepairedTankGroup.members &")");
			droid = iterateGroup(tankGroup)
		end
		
		-- help group
		initIterateGroup(helpGroup)
		droid = iterateGroup(helpGroup)
		while droid ~= nil do
			if droid.health < nDamageLevelRepair and droid.propulsion ~= TrackedProp then
				groupAddDroid(toBeRepairedTankGroup, droid)
				orderDroid(droid, DORDER_RTR)
			end
			-- displayMsg("*** unitRepairSwitch1: move damaged units to toBeRepairedTankGroup ("& droid.id &") with health ("& droid.health &") added in group toBeRepairedTankGroup ("& toBeRepairedTankGroup.members &")");
			droid = iterateGroup(helpGroup)
		end
		
		-- cyborgs - defend
		initIterateGroup(cyborgDefGroup)
		droid = iterateGroup(cyborgDefGroup)
		while droid ~= nil do
			if droid.health < nDamageLevelRepair then
				groupAddDroid(toBeRepairedCyborgGroup, droid)
				-- displayMsg("*** unitRepairSwitch1: Send back to repair cyborgDefGroup ("& droid.id &") with health ("& droid.health &")");
				orderDroid(droid, DORDER_RTR)
			end
			droid = iterateGroup(cyborgDefGroup)
		end
		
		-- cyborgs - attack
		initIterateGroup(cyborgAttGroup)
		droid = iterateGroup(cyborgAttGroup)
		while droid ~= nil do
			if droid.health < nDamageLevelRepair then
				groupAddDroid(toBeRepairedCyborgGroup, droid)
				-- displayMsg("*** unitRepairSwitch1: Send back to repair cyborgDefGroup ("& droid.id &") with health ("& droid.health &")");
				orderDroid(droid, DORDER_RTR)
			end
			droid = iterateGroup(cyborgAttGroup)
		end
	else
		if groupCountMembers(toBeRepairedTankGroup) > 0 then
			groupAddGroup(tankDefGroup, toBeRepairedTankGroup)
		end
		if groupCountMembers(toBeRepairedCyborgGroup) > 0 then
			groupAddGroup(cyborgDefGroup, toBeRepairedCyborgGroup)
		end
	end
	
	-- check if units have been repaired and assign back to tank group
	initIterateGroup(toBeRepairedTankGroup)
	droid = iterateGroup(toBeRepairedTankGroup)
	while droid ~= nil do
		if droid.health > MIN_HEALT_SWITCH_TO_TANK then
			if droid.droidType == DROID_REPAIR then
				groupAddDroid(repairGroup, droid)
			end
			if droid.droidType == DROID_WEAPON then
				groupAddDroid(tankDefGroup, droid)
			end
			-- mixed group checks!!!
			if droid.droidType == DROID_CYBORG and droid.droidType ~= DROID_CYBORG_CONSTRUCT then
				nTotCyborgBuilt = nTotCyborgBuilt + 1
				if AIPersonality == AI_CYBORG then
					groupAddDroid(cyborgDefGroup, droid)
				else
					if nTotCyborgBuilt > 2 then
						groupAddDroid(tankDefGroup, droid)
						nTotCyborgBuilt = 0
					else
						groupAddDroid(cyborgDefGroup, droid)
					end
				end
			end
		else
			orderDroid(droid, DORDER_RTR)
		end
		droid = iterateGroup(toBeRepairedTankGroup)
	end
	
	-- check if units have been repaired and assign back to tank group
	initIterateGroup(toBeRepairedCyborgGroup)
	droid = iterateGroup(toBeRepairedCyborgGroup)
	while droid ~= nil do
		if droid.health > MIN_HEALT_SWITCH_TO_CYBORG then
			groupAddDroid(cyborgDefGroup, droid)
		else
			orderDroid(droid, DORDER_RTR)
		end
		droid = iterateGroup(toBeRepairedCyborgGroup)
	end
end

-- if ( gameTime - lastDisplayAI >= 80 ){
-- displayMsg("unitRepairSwitch: unitRepairSwitch END ("& toBeRepairedCyborgGroup.members &")("& count &")");
-- }
-- --------------------------------------------------------------
function activateAttack()
	local _nTankUnitsToBeMoved = 0
	local _nTotUnits = 0
	local _nUnitsRequiredToAttack = 0
	local _rndTime = 0
	local _nCybUnitsToBeMoved = 0
	local _nTotCybUnits = 0
	local _nCybUnitsRequiredToAttack = 0
	local _bUseCybUnitsToo = false
	
	local _nMyUnitsTot = 0
	local _nMyUnitsPower = 0
	local _nMyUnitsHP = 0
	local _nEnUnitsTot = 0
	local _nEnUnitsPower = 0
	local _nEnUnitsHP = 0
	local _cybRequired = 0
	local _tankRequired = 0
	local _player = 0
	local _nMyPowerIndex = 0
	local _nEnPowerIndex = 0
	
	eventCheckTime[22] = C.gameTime
	
	if groupCountMembers(tankDefGroup) < minDefDroids[nAI_Pers][MINDEF_TANKS] and groupCountMembers(cyborgDefGroup) < minDefDroids[nAI_Pers][MINDEF_CYBORGS] then
		return
	end
	if alertLevel == RED_ALERT then
		return
	end
	
	-- ----------------------------------------------------------------------
	-- Check for Final Attack in 1vs1 game or if just one enemy player exists
	_nMyUnitsTot = groupCountMembers(tankDefGroup) + groupCountMembers(cyborgDefGroup) + groupCountMembers(cyborgAttGroup)
	if not bTankAttIsOn and nEnemyPlayers == 1 and (C.gameTime - tLastFinalAttack) > 6 * TIME_MINUTE and C.gameTime > 20 * TIME_MINUTE then
		_nMyUnitsPower = getWeaponUnitsInfo(player, WUI_POWER)
		_nMyUnitsHP = getWeaponUnitsInfo(player, WUI_HP)
		_nMyPowerIndex = getPowerIndex(player)
		
		_nEnUnitsTot = getWeaponUnitsInfo(nLastEnemyPlayer, WUI_TOTUNITS)
		_nEnUnitsPower = getWeaponUnitsInfo(nLastEnemyPlayer, WUI_POWER)
		_nEnUnitsHP = getWeaponUnitsInfo(nLastEnemyPlayer, WUI_HP)
		_nEnPowerIndex = getPowerIndex(nLastEnemyPlayer)
		
		bFinalAttack_1vs1 = false
		-- droid superiority
		if _nMyUnitsTot > 15 and _nMyUnitsTot > _nEnUnitsTot * 2 then
			if _nMyUnitsTot > _nEnUnitsTot * 3 then
				bFinalAttack_1vs1 = true
			end
			if _nMyUnitsPower > _nEnUnitsPower * 2 then
				bFinalAttack_1vs1 = true
			end
			if _nMyUnitsHP > _nEnUnitsHP * 2 then
				bFinalAttack_1vs1 = true
			end
		end
		-- enemy with lower power
		if _nMyPowerIndex > _nEnPowerIndex * 2.0 then
			if _nMyUnitsTot > 15 then
				if _nMyUnitsTot > _nEnUnitsTot * 2 then
					bFinalAttack_1vs1 = true
				end
				if _nMyUnitsPower > _nEnUnitsPower * 1.5 then
					bFinalAttack_1vs1 = true
				end
				if _nMyUnitsHP > _nEnUnitsHP * 1.5 then
					bFinalAttack_1vs1 = true
				end
			end
		end
	end
	-- dbg("dbg->activateAttack: Final Attack - tkdef("& tankDefGroup.members &") cybdef("& cyborgDefGroup.members &") tkatt("& tankGroup.members &") cybatt("& cyborgAttGroup.members &") pow("& _nMyPowerIndex &")("& _nEnPowerIndex &") my("& _nMyUnitsTot &"-"& _nMyUnitsPower &"-"& _nMyUnitsHP &") en("& _nEnUnitsTot &"-"& _nEnUnitsPower &"-"& _nEnUnitsHP &") ("& tLastFinalAttack &")("& nEnemyPlayers &") ["& bFinalAttack_1vs1 &"] bForceResPowUp("& bForceResPowUp &")",player);
	-- else {  dbg("dbg->activateAttack: gameTime("& gameTime &") ",player); }
	
	if bFinalAttack_1vs1 then
		if C.gameTime - tLastFinalAttack > 5 * TIME_MINUTE then
			if groupCountMembers(helpGroup) > 0 then
				groupAddGroup(tankGroup, helpGroup)
			end
			if groupCountMembers(tankDefGroup) > 0 then
				groupAddGroup(tankGroup, tankDefGroup)
			end
			if groupCountMembers(cyborgDefGroup) > 0 then
				groupAddGroup(tankGroup, cyborgDefGroup)
			end
			if groupCountMembers(cyborgAttGroup) > 0 then
				groupAddGroup(tankGroup, cyborgAttGroup)
			end
			printDebug1("activateAttack: Final Attack Activated, attacking with droids(" .. groupCountMembers(tankGroup) .. ") tLastFinalAttack(" .. tLastFinalAttack .. ") ")
			tLastFinalAttack = C.gameTime
			tLastTankAttack = C.gameTime
			bTankAttIsOn = true
			nFinalAttacks = nFinalAttacks + 1
			-- dbg("dbg->activateAttack:  ____________________ FINAL ATTACK ___________________" , player);
			-- dbg("dbg->activateAttack: FINAL ATTACK, ("& getPlayerName(player) &") attacks with ("& tankGroup.members &") units against ("& getPlayerName(nLastEnemyPlayer) &")" , player);
			if not bTankAttIsOn then
				repeatingEvent(TankAttack, 3.0)
			end
			return
		end
	end
	
	if not bFinalAttack_1vs1 then
		if not bTankAttIsOn then
			_player = 0
			nTotEnemyDroids = 0
			while _player < MAX_PLAYERS do
				if isPlayerStillLive(_player) and not friendlyPlayer(_player) then
					nTotEnemyDroids = nTotEnemyDroids + (aStat[OC_CYBORGS][_player] + aStat[OC_TANKS][_player])
				end
				_player = _player + 1
			end
			-- send reinforcements by grouping them (min 8 droids)
			if nTotEnemyDroids * 4 < _nMyUnitsTot and _nMyUnitsTot > 8 then
				if groupCountMembers(helpGroup) > 0 then
					groupAddGroup(tankGroup, helpGroup)
				end
				if groupCountMembers(tankDefGroup) > 0 then
					groupAddGroup(tankGroup, tankDefGroup)
				end
				if groupCountMembers(cyborgDefGroup) > 0 then
					groupAddGroup(tankGroup, cyborgDefGroup)
				end
				if groupCountMembers(cyborgAttGroup) > 0 then
					groupAddGroup(tankGroup, cyborgAttGroup)
				end
				tLastTankAttack = C.gameTime
				bTankAttIsOn = true
				repeatingEvent(TankAttack, 3.0)
				printDebug1("activateAttack: Virtual Victory check is positive: attacking with droids (" .. groupCountMembers(tankGroup) .. ") TotEnemyDroids*4(" .. nTotEnemyDroids * 4 .. ") < MyTotUnits(" .. _nMyUnitsTot .. ") and available droids > 8 ")
				return
			end
		end
		
		-- ================== TANK ATTACK =============================
		if AIPersonality ~= AI_CYBORG and groupCountMembers(tankDefGroup) > minDefDroids[nAI_Pers][MINDEF_TANKS] then
			_nTotUnits = groupCountMembers(tankDefGroup)
			-- MIN_DEFENDING_TANKS;
			_nTankUnitsToBeMoved = _nTotUnits - minDefDroids[nAI_Pers][MINDEF_TANKS]
			_nUnitsRequiredToAttack = minDefDroids[nAI_Pers][MINDEF_TANKS] + MIN_ATTACKING_TANKS + nAttackingUnitsToAdd
			if groupCountMembers(cyborgDefGroup) > minDefDroids[nAI_Pers][MINDEF_CYBORGS] then
				_nCybUnitsToBeMoved = groupCountMembers(cyborgDefGroup) - minDefDroids[nAI_Pers][MINDEF_CYBORGS]
			else
				_nCybUnitsToBeMoved = 0
			end
			_bUseCybUnitsToo = false
			
			-- force attack after some time by using both cyborgs and tanks droids.
			if AIPersonality == AI_TURTLE then
				_rndTime = (10 * TIME_MINUTE + _random(900))
			else
				_rndTime = (6 * TIME_MINUTE + _random(900))
			end
			if nMapPower <= LOW_POWER_MAP then
				_bUseCybUnitsToo = true
			end
			if C.gameTime > (15 * TIME_MINUTE + tTotalAttack) and ((C.gameTime - tLastTankAttack > _rndTime) or (C.gameTime - tLastCyborgAttack > _rndTime)) then
				_bUseCybUnitsToo = true
				-- otherwise will always attack with 7!!
				_nUnitsRequiredToAttack = _nUnitsRequiredToAttack + 5
			end
			if _bUseCybUnitsToo then
				_nTotUnits = _nTotUnits + _nCybUnitsToBeMoved
			end
			
			if _nTotUnits >= _nUnitsRequiredToAttack then
				if _bUseCybUnitsToo and (groupCountMembers(cyborgDefGroup) > minDefDroids[nAI_Pers][MINDEF_CYBORGS]) then
					_nCybUnitsToBeMoved = groupCountMembers(cyborgDefGroup) - minDefDroids[nAI_Pers][MINDEF_CYBORGS]
					moveUnitsBetweenGRPs(tankGroup, cyborgDefGroup, _nCybUnitsToBeMoved, false)
				end
				moveUnitsBetweenGRPs(tankGroup, tankDefGroup, _nTankUnitsToBeMoved, true)
				tLastTankAttack = C.gameTime
				bTankAttIsOn = true
				-- alternate attacks
				bAttackedHumanDerrick = false
				-- dbg("dbg->activateAttack: ("& getPlayerName(player) &") attacks with tanks ("& tankGroup.members &") _bUseCybUnitsToo ("& _bUseCybUnitsToo &")",player);
				printDebug1("ActivateAttack: Tank Attack Activated, att droids(" .. groupCountMembers(tankGroup) .. ") _nTotUnits(" .. _nTotUnits .. ") _nUnitsRequired(" .. _nUnitsRequiredToAttack .. ") _bUseCybUn(" .. _bUseCybUnitsToo .. ") ToBeMoved Tk-Cy-toAdd(" .. _nTankUnitsToBeMoved .. ")(" .. _nCybUnitsToBeMoved .. ")(" .. nAttackingUnitsToAdd .. ")")
				repeatingEvent(TankAttack, 3.0)
				return
			end
		end
		
		-- ==================== CYBORG ATTACK =====================================
		-- cyborgs
		if not bCybAttIsOn and groupCountMembers(cyborgDefGroup) > minDefDroids[nAI_Pers][MINDEF_CYBORGS] and C.gameTime > VALID_TIME_CYBATTACK then
			_nTotCybUnits = groupCountMembers(cyborgDefGroup)
			_nCybUnitsRequiredToAttack = minDefDroids[nAI_Pers][MINDEF_CYBORGS] + MIN_ATT_CYBORGS + nCybAttUnitsToAdd
			_nCybUnitsToBeMoved = _nTotCybUnits - minDefDroids[nAI_Pers][MINDEF_CYBORGS]
			if _nTotCybUnits >= _nCybUnitsRequiredToAttack then
				moveUnitsBetweenGRPs(cyborgAttGroup, cyborgDefGroup, _nCybUnitsToBeMoved, false)
				bCybAttIsOn = true
				tLastCyborgAttack = C.gameTime
				-- alternate attacks
				bAttackedHumanDerrick = false
				-- dbg("dbg->activateAttack: ("& getPlayerName(player) &") attacks with cyborg team units: ("& cyborgAttGroup.members &") ",player);
				printDebug1("ActivateAttack: Cyborg Attack Activated, attacking with Cyborgs (" .. groupCountMembers(cyborgAttGroup) .. ") ")
				repeatingEvent(CyborgAttack, 3.0)
				return
			end
		end
		
		-- ==================== HUMAN DERRICKS =====================================
		-- attack human derrick with few defences if no targets in defend range
		if AIPersonality == AI_CYBORG then
			if not bCybAttIsOn then
				_cybRequired = 5 + minDefDroids[nAI_Pers][MINDEF_CYBORGS]
				if attackCybObj == nil and not bAttackedHumanDerrick then
					if groupCountMembers(cyborgDefGroup) >= _cybRequired then
						attackCybObj = objHumanDerrick(false, 1, 8)
						if attackCybObj ~= nil then
							moveUnitsBetweenGRPs(cyborgAttGroup, cyborgDefGroup, 5, false)
							bCybAttIsOn = true
							tLastCyborgAttack = C.gameTime
							-- alternate attacks
							bAttackedHumanDerrick = true
							nAttHumanPlayer = nAttHumanPlayer + 1
							-- dbg("dbg->activateAttack: '"& getPlayerName(player) &"' attacks human derrick with cyborgs ("& cyborgAttGroup.members &")",player);
							printDebug1("ActivateAttack: Attacking human derricks with Tk+Cy droids(" .. groupCountMembers(cyborgAttGroup) .. ") ")
							repeatingEvent(CyborgAttack, 3.0)
							return
						end
					end
				end
			end
		else
			if not bTankAttIsOn then
				_cybRequired = 3 + minDefDroids[nAI_Pers][MINDEF_CYBORGS]
				_tankRequired = 2 + minDefDroids[nAI_Pers][MINDEF_TANKS]
				if not alertIsOn and not bAttackedHumanDerrick then
					if groupCountMembers(tankDefGroup) >= _tankRequired and groupCountMembers(cyborgDefGroup) >= _cybRequired then
						attackTankObj = objHumanDerrick(false, 1, 8)
						if attackTankObj ~= nil then
							moveUnitsBetweenGRPs(tankGroup, cyborgDefGroup, 3, false)
							moveUnitsBetweenGRPs(tankGroup, tankDefGroup, 2, true)
							bTankAttIsOn = true
							tLastTankAttack = C.gameTime
							-- alternate attacks
							bAttackedHumanDerrick = true
							nAttHumanPlayer = nAttHumanPlayer + 1
							-- dbg("dbg->activateAttack: '"& getPlayerName(player) &"' attacks human derrick with tanks ("& tankGroup.members &")",player);
							printDebug1("ActivateAttack: Attacking human derricks with droids(" .. groupCountMembers(tankGroup) .. ") ")
							repeatingEvent(TankAttack, 3.0)
							return
						end
					end
				end
			end
		end
	end
end
-- else { dbg("dbg->activateAttack: '"& getPlayerName(player) &"' no undefended human derricks to attack found",player);  }

-- if ( !bFinalAttack_1vs1 ){

-- ===========================================================================
function TankAttack()
	local _distFromObj = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: TankAttack " .. player, player)
	-- if ( gameTime - lastDisplayAI >= 10 ){
	-- dbg("dbg->TankAttack : tank ("& tankGroup.members &") bTankAlreadyGathered("& bTankAlreadyGathered &") targ("& targetPlayerTank &") x-Y("& tankAttackX &")("& tankAttackY &") ",player);
	-- }
	
	-- do a preliminary check
	if groupCountMembers(tankGroup) < MIN_SURVIVOR_TANKS and not bAttackedHumanDerrick then
		if groupCountMembers(tankGroup) > 0 then
			groupAddGroup(tankDefGroup, tankGroup)
		end
		deactivateTankAttack()
		-- this is necessary otherwise the event proceeeds!
		return
	end
	
	-- get target for the first attack, further targets are chosen below
	if attackTankObj == nil and not bTankAlreadyGathered then
		attackTankObj = getTargetObj()
		if attackTankObj ~= nil then
			if isHumanPlayer(attackTankObj.player) then
				nAttHumanPlayer = nAttHumanPlayer + 1
				dropBeaconToAllies("Player " .. getPlayerName(player) .. " attacking " .. getPlayerName(attackTankObj.player) .. " with " .. groupCountMembers(tankGroup) .. " droids", attackTankObj.x, attackTankObj.y, 0, true)
				printDebug1("TankAttack: attacking human player '" .. getPlayerName(attackTankObj.player) .. "' with (" .. groupCountMembers(tankGroup) .. ")")
			else
				nAttAIPlayer = nAttAIPlayer + 1
				dropBeaconToAllies("go!", attackTankObj.x, attackTankObj.y, 0, false)
				printDebug1("TankAttack: attacking AI player '" .. getPlayerName(attackTankObj.player) .. "' with (" .. groupCountMembers(tankGroup) .. ")")
			end
		end
	end
	
	if attackTankObj == nil then
		if bTankAlreadyGathered then
			attackTankObj = objDroidTargetInRange(tankAttackX, tankAttackY, TILE * 25, false)
			if attackTankObj == nil then
				attackTankObj = objStrTargetInRange(tankAttackX, tankAttackY, TILE * 25)
			end
			
			if attackTankObj ~= nil then
				targetPlayerTank = attackTankObj.player
				targetPlayerVTOL = targetPlayerTank
				tankAttackX = attackTankObj.x
				tankAttackY = attackTankObj.y
				orderGroupScoutCMD(tankGroup, tankAttackX, tankAttackY)
			else
				groupAddGroup(tankDefGroup, tankGroup)
				deactivateTankAttack()
			end
		end
		-- else { displayMsg("TankAttack: ________________ FIRST TARGET NOT FOUND ___________________"); }
		return
	else
		_distFromObj = 13 * TILE + (((C.mapWidth * TILE + C.mapHeight * TILE) / 2) / 40)
		targetPlayerTank = attackTankObj.player
		targetPlayerVTOL = targetPlayerTank
		tankAttackX = attackTankObj.x
		tankAttackY = attackTankObj.y
		
		-- determine gathering positions, 12 tiles away from it
		-- send tanks to gathering positions
		if not lTankSentToGatheringPoint then
			if nTankGatheringX <= 0 and nTankGatheringY <= 0 then
				count = random(3)
				-- between bases
				if count == 0 then
					if attackTankObj.x > baseX then
						count2 = baseX + (attackTankObj.x - baseX) / 2
					else
						count2 = baseX - (baseX - attackTankObj.x) / 2
					end
					if attackTankObj.y > baseY then
						count3 = baseY + (attackTankObj.y - baseY) / 2
					else
						count3 = baseY - (baseY - attackTankObj.y) / 2
					end
					nTankGatheringX = getCoordRelated(count2, count3, baseX, baseY, 1, 1 * TILE)
					nTankGatheringY = getCoordRelated(count2, count3, baseX, baseY, 2, 1 * TILE)
				end
				-- centre of the map
				if count == 1 then
					count2 = (C.mapWidth * TILE) / 2
					count3 = (C.mapHeight * TILE) / 2
					nTankGatheringX = getCoordRelated(count2, count3, baseX, baseY, 1, 1 * TILE)
					nTankGatheringY = getCoordRelated(count2, count3, baseX, baseY, 2, 1 * TILE)
				end
				-- standard
				if count == 2 then
					nTankGatheringX = getCoordRelated(attackTankObj.x, attackTankObj.y, baseX, baseY, 1, _distFromObj)
					nTankGatheringY = getCoordRelated(attackTankObj.x, attackTankObj.y, baseX, baseY, 2, _distFromObj)
				end
			end
			
			-- centre of the map.
			if nTankGatheringX <= 0 or nTankGatheringY <= 0 then
				nTankGatheringX = (C.mapWidth * TILE) / 2
				nTankGatheringY = (C.mapHeight * TILE) / 2
			end
			
			orderGroupLoc(tankGroup, DORDER_MOVE, nTankGatheringX, nTankGatheringY)
			lTankSentToGatheringPoint = true
			tTanksSentToGathering = C.gameTime
		end
		
		-- check if tank group has arrived at gathring point, need to check the distance too!!!
		if not bTankAlreadyGathered then
			if idleGroup(tankGroup) > groupCountMembers(tankGroup) * 0.8 or distBetweenTwoPoints(tankGroup.x, tankGroup.y, nTankGatheringX, nTankGatheringY) < 4 * TILE or C.gameTime - tTanksSentToGathering > 2400 then
				bTankAlreadyGathered = true
				nTankGatheringX = -1
				nTankGatheringY = -1
				tTanksSentToGathering = 0
				orderGroupScoutCMD(tankGroup, tankAttackX, tankAttackY)
			else
				if C.gameTime - tTanksReSentToGathering > 70 then
					if bAttackTeamAttacked then
						orderGroupScoutCMD(tankGroup, nTankGatheringX, nTankGatheringY)
					else
						orderGroupLoc(tankGroup, DORDER_MOVE, nTankGatheringX, nTankGatheringY)
					end
					tTanksReSentToGathering = C.gameTime
					if tTanksSentToGathering < 0 then
						tTanksSentToGathering = C.gameTime
					end
				end
			end
		else
			if structInRange(targetPlayerTank, tankAttackX, tankAttackY, 2 * TILE) or droidInRange(targetPlayerTank, tankAttackX, tankAttackY, 2 * TILE) then
				if C.gameTime - tTankAttackAction > 100 then
					orderGroupScoutCMD(tankGroup, tankAttackX, tankAttackY)
					tTankAttackAction = C.gameTime
				end
			end
		end
	end
end

-- ===========================================================================
-- Original event ID: xx (of 106)
function CyborgAttack()
	local _distFromObj = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: CyborgAttack " .. player, player)
	-- dbg("dbg->CyborgAttack: '"& getPlayerName(player) &"' cyborgs ("& cyborgAttGroup.members &") CALLED bCybAlreadyGathered("& bCybAlreadyGathered &") targ("& targetPlayerCyb &") x-Y("& cybAttackX &")("& cybAttackY &")",player);
	
	-- do a preliminary check
	if groupCountMembers(cyborgAttGroup) < MIN_SURVIVOR_CYBORGS and not bAttackedHumanDerrick then
		if groupCountMembers(cyborgAttGroup) > 0 then
			groupAddGroup(cyborgDefGroup, cyborgAttGroup)
		end
		deactivateCybAttack()
		return
	end
	
	-- get target
	-- displayMsg("CyborgAttack: ________________ START CYBORG ATTACK ___________________");
	
	if attackCybObj == nil then
		if bCybAlreadyGathered then
			attackCybObj = objDroidTargetInRange(cybAttackX, cybAttackY, TILE * 25, false)
			if attackCybObj == nil then
				attackCybObj = objStrTargetInRange(cybAttackX, cybAttackY, TILE * 25)
			end
			if attackCybObj ~= nil then
				targetPlayerCyb = attackCybObj.player
				targetPlayerVTOL = targetPlayerCyb
				cybAttackX = attackCybObj.x
				cybAttackY = attackCybObj.y
				
				-- dbg("CyborgAttack: ________________ CYBORG ATTACK NEW TARGET IN AREA ___________________",player);
				-- dbg("CyborgAttack: move all ("& cyborgAttGroup.members &") attacking struct/droid ("& cybAttackX/128 &"-"& cybAttackY/128 &") ",player);
				tCybAttackAction = C.gameTime
				orderGroupScoutCMD(cyborgAttGroup, cybAttackX, cybAttackX)
			else
				if groupCountMembers(cyborgAttGroup) > 0 then
					groupAddGroup(cyborgDefGroup, cyborgAttGroup)
				end
				deactivateCybAttack()
			end
		else
			attackCybObj = getTargetObj()
			if attackCybObj ~= nil then
				if isHumanPlayer(attackCybObj.player) then
					nAttHumanPlayer = nAttHumanPlayer + 1
					dropBeaconToAllies("Player " .. getPlayerName(player) .. " attacking " .. getPlayerName(attackCybObj.player) .. " with " .. groupCountMembers(cyborgAttGroup) .. " droids", attackCybObj.x, attackCybObj.y, 0, true)
					printDebug1("CyborgAttack: attacking Human player '" .. getPlayerName(attackCybObj.player) .. "' with " .. groupCountMembers(cyborgAttGroup) .. " droids ")
				else
					nAttAIPlayer = nAttAIPlayer + 1
					dropBeaconToAllies("go!", attackCybObj.x, attackCybObj.y, 0, false)
					printDebug1("CyborgAttack: attacking AI player '" .. getPlayerName(attackCybObj.player) .. "' with " .. groupCountMembers(cyborgAttGroup) .. " droids")
				end
			end
			return
		end
	else
		_distFromObj = 13 * TILE + (((C.mapWidth * TILE + C.mapHeight * TILE) / 2) / 40)
		targetPlayerCyb = attackCybObj.player
		targetPlayerVTOL = targetPlayerCyb
		cybAttackX = attackCybObj.x
		cybAttackY = attackCybObj.y
		
		-- determine gathering positions, 12 tiles away from it
		-- send cyborgs to gathering positions
		if not lCybSentToGatheringPoint then
			if nCybGatheringX <= 0 and nCybGatheringX <= 0 then
				count = random(3)
				count2 = (C.mapWidth * TILE + C.mapHeight * TILE) / 2
				
				if count == 0 then
					if attackCybObj.x > baseX then
						count2 = baseX + (attackCybObj.x - baseX) / 2
					else
						count2 = baseX - (baseX - attackCybObj.x) / 2
					end
					if attackCybObj.y > baseY then
						count3 = baseY + (attackCybObj.y - baseY) / 2
					else
						count3 = baseY - (baseY - attackCybObj.y) / 2
					end
					nCybGatheringX = getCoordRelated(count2, count3, baseX, baseY, 1, 1 * TILE)
					nCybGatheringY = getCoordRelated(count2, count3, baseX, baseY, 2, 1 * TILE)
				end
				-- displayMsg("### CyborgAttack: gathering point 1 selected (between bases)");
				-- centre of the map
				if count == 1 then
					count2 = (C.mapWidth * TILE) / 2
					count3 = (C.mapHeight * TILE) / 2
					nCybGatheringX = getCoordRelated(count2, count3, baseX, baseY, 1, 1 * TILE)
					nCybGatheringY = getCoordRelated(count2, count3, baseX, baseY, 2, 1 * TILE)
				end
				-- displayMsg("### CyborgAttack: gathering point 2 selected (centre of Map)");
				-- standard
				if count == 2 then
					nCybGatheringX = getCoordRelated(attackCybObj.x, attackCybObj.y, baseX, baseY, 1, _distFromObj)
					nCybGatheringY = getCoordRelated(attackCybObj.x, attackCybObj.y, baseX, baseY, 2, _distFromObj)
				end
			end
			-- displayMsg("### CyborgAttack: gathering point 3 selected (standard)");
			
			-- centre of the map.
			if nCybGatheringX <= 0 or nCybGatheringY <= 0 then
				nCybGatheringX = (C.mapWidth * TILE) / 2
				nCybGatheringY = (C.mapHeight * TILE) / 2
			end
			
			-- displayMsg("CyborgAttack: ________________ SEND CYBORG TO GATHERING POINT ___________________");
			-- displayMsg("CyborgAttack: cSend ("& cyborgAttGroup.members &") Cyborgs to coord ("& nCybGatheringX/TILE &"-"& nCybGatheringY/TILE &") enemy ("& targetPlayerCyb &") obj coord ("& cybAttackX/TILE &"-"& cybAttackY/TILE &")");
			orderGroupLoc(cyborgAttGroup, DORDER_MOVE, nCybGatheringX, nCybGatheringY)
			lCybSentToGatheringPoint = true
			tCybSentToGathering = C.gameTime
		end
		
		-- check if Cyborgs group has arrived at gathring point, need to check the distance too!!!
		if not bCybAlreadyGathered then
			if idleGroup(cyborgAttGroup) > groupCountMembers(cyborgAttGroup) * 0.8 or distBetweenTwoPoints(cyborgAttGroup.x, cyborgAttGroup.y, nCybGatheringX, nCybGatheringY) < 4 * TILE or C.gameTime - tCybSentToGathering > 2400 then
				bCybAlreadyGathered = true
				nCybGatheringX = -1
				nCybGatheringY = -1
				tCybSentToGathering = 0
				orderGroupScoutCMD(cyborgAttGroup, cybAttackX, cybAttackY)
			else
				if C.gameTime - tCybReSentToGathering > 100 then
					if bAttackTeamAttacked then
						orderGroupScoutCMD(cyborgAttGroup, nCybGatheringX, nCybGatheringY)
					else
						orderGroupLoc(cyborgAttGroup, DORDER_MOVE, nCybGatheringX, nCybGatheringY)
					end
					-- displayMsg("CyborgAttack: remember ("& cyborgAttGroup.members &") cyborgs to gather at coord ("& nCybGatheringX/128 &"-"& nCybGatheringY/128 &") enemy ("& targetPlayerCyb &")");
					tCybReSentToGathering = C.gameTime
					if tCybSentToGathering < 0 then
						tCybSentToGathering = C.gameTime
					end
				end
			end
		else
			if structInRange(targetPlayerCyb, cybAttackX, cybAttackY, 2 * TILE) or droidInRange(targetPlayerCyb, cybAttackX, cybAttackY, 2 * TILE) then
				if C.gameTime - tCybAttackAction > 100 then
					tCybAttackAction = C.gameTime
					-- orderGroupLoc(cyborgAttGroup,DORDER_SCOUT,cybAttackX,cybAttackY);
					orderGroupScoutCMD(cyborgAttGroup, cybAttackX, cybAttackY)
				end
			end
		end
	end
end


-- //attackCybObj != NULLOBJECT


-- ================================================================
-- CALL_ATTACKED, player, ref myBaseObject, ref enemyBaseObject
-- event 20
function AIattacked(_myBaseObject, _enemyBaseObject)
	if _myBaseObject.player ~= player then return end
	myBaseObject, enemyBaseObject = _myBaseObject, _enemyBaseObject -- wz2lua: probably these can be used as function arguments directly
	local _droid = nil
	local _droid2 = nil
	local _structure = nil
	local _structure2 = nil
	local bProceed = false
	local _bAttackedByVTOL = false
	local _nDistFromBase = 0
	local _nDistFromEnemy = 0
	local _nAA = 0
	
	--[[if( !aiResponsibleForPlayer(player) )
		{
			setEventTrigger(AIattacked,inactive);
		}
		else
		{]]--
	ASSERT(player >= 0 and player < 8, "player out of bounds: myDroidAttacked " .. player, player)
	
	bProceed = true
	
	if C.gameTime - alertTime < 80 then
		return
	end
	
	if enemyBaseObject ~= nil and myBaseObject ~= nil then
		_nDistFromEnemy = distBetweenTwoPoints(myBaseObject.x, myBaseObject.y, enemyBaseObject.x, enemyBaseObject.y)
		_nDistFromBase = distBetweenTwoPoints(baseX, baseY, myBaseObject.x, myBaseObject.y)
	else
		return
	end
	
	if enemyBaseObject.type == OBJ_DROID then
		_droid2 = objToDroid(enemyBaseObject)
		if isVtol(_droid2) then
			_bAttackedByVTOL = true
			bAttackedByVTOL = true
		else
			_bAttackedByVTOL = false
		end
	end
	
	-- recall to base if buildGroup, buildDefGroup or cyborgConstructGroup
	if myBaseObject.type == OBJ_DROID then
		_droid = objToDroid(myBaseObject)
		if _droid.group == buildGroup or _droid.group == buildDefGroup or _droid.group == cyborgConstructGroup then
			if _nDistFromBase > nBaseRange then
				orderDroid(_droid, DORDER_RTB)
			end
		end
	end
	
	-- displayMsg("AIattacked:  dist myOBJ from base/def Range ("& _nDistFromBase/TILE &"/"& nDefendRange/TILE &") dist my obj/en obj ("& _nDistFromEnemy/TILE &")");
	if _nDistFromBase > nDefendRange then
		if myBaseObject.type == OBJ_DROID then
			_droid = objToDroid(myBaseObject)
			if _droid.group == tankGroup or _droid.group == cyborgAttGroup or _droid.group == helpGroup then
				if enemyBaseObject.type == OBJ_DROID then
					if not _bAttackedByVTOL then
						bAttackTeamAttacked = true
					end
				end
			end
		else
			if not _bAttackedByVTOL then
				if groupCountMembers(vtolDefendGr) > 0 and defTargetVTOL == nil then
					_nAA = numEnemyAAInRange(enemyBaseObject.x, enemyBaseObject.y, AA_THREAT_RANGE())
					if _nAA * 3 < groupCountMembers(vtolDefendGr) then
						defTargetVTOL = enemyBaseObject
						targetPlayerVTOL = enemyBaseObject.player
						tTargetTime = C.gameTime
					end
				end
			end
		end
		-- bVTOLTargetIsDerrick  = false;
		-- dbg("dbg->AIattacked: order VTOL to defend structure and attack at ("& enemyBaseObject.x/TILE &"-"& enemyBaseObject.y/TILE &"), dist from base("& _nDistFromBase/TILE &")",player);
		return
	end
	
	-- check if attacked by mortars!!!
	if not _bAttackedByVTOL then
		if _nDistFromEnemy > 16 * TILE and _nDistFromEnemy < 19 * TILE then
			bAttackedByMortars = true
			nKineticX = myBaseObject.x
			nKineticY = myBaseObject.y
			-- dbg("dbg->AIattacked: '"& getPlayerName(player) &"' attacked by long range weapons ("& _nDistFromBase/TILE &"/"& nDefendRange/TILE &") dist my obj en obj ("& _nDistFromEnemy/TILE &")",player);
			if numEnemyAAInRange(enemyBaseObject.x, enemyBaseObject.y, AA_THREAT_RANGE()) < 2 then
				defTargetVTOL = enemyBaseObject
				targetPlayerVTOL = enemyBaseObject.player
				bVTOLTargetIsDerrick = false
				tTargetTime = C.gameTime
			end
			-- send also def troops to attack
			bProceed = true
			-- build
			delayedEvent(defFromLongRangeWeap, 0.1)
		else
			-- attacked by ripple rockets or other very long range kinetic turrets
			if _nDistFromEnemy >= 19 * TILE then
				bAttackedByLongRangeWeap = true
				nKineticX = myBaseObject.x
				nKineticY = myBaseObject.y
				-- dbg("dbg->AIattacked: '"& getPlayerName(player) &"' attacked by very long range weapon ("& _nDistFromBase/TILE &"/"& nDefendRange/TILE &") dist my obj en obj ("& _nDistFromEnemy/TILE &")",player);
				if numEnemyAAInRange(enemyBaseObject.x, enemyBaseObject.y, AA_THREAT_RANGE()) < 2 then
					defTargetVTOL = enemyBaseObject
					targetPlayerVTOL = enemyBaseObject.player
					bVTOLTargetIsDerrick = false
					tTargetTime = C.gameTime
				end
				if _nDistFromEnemy >= 19 and _nDistFromEnemy <= 22 then
					bProceed = true
				else
					bProceed = false
				end
				delayedEvent(defFromLongRangeWeap, 0.1)
			else
				bProceed = true
			end
		end
	end
	
	if bProceed and C.gameTime - alertTime > 50 then
		if enemyBaseObject ~= nil and myBaseObject ~= nil then
			if enemyBaseObject.type == OBJ_DROID then
				_droid2 = objToDroid(enemyBaseObject)
				attackedByDroid(_droid2)
			end
			if enemyBaseObject.type == OBJ_STRUCTURE then
				_structure2 = objToStructure(enemyBaseObject)
				attackedByStruct(_structure2)
			end
			
			-- displayMsg("AIattacked: ACTIVATED alertTime=("& gameTime &")");
			if not _bAttackedByVTOL then
				if C.gameTime - alertTime > 10 then
					gatherDefTankX = getCoordRelated(myBaseObject.x, myBaseObject.y, baseX, baseY, 1, 8 * TILE)
					gatherDefTankY = getCoordRelated(myBaseObject.x, myBaseObject.y, baseX, baseY, 2, 8 * TILE)
					gatherDefCybX = getCoordRelated(myBaseObject.x, myBaseObject.y, baseX, baseY, 1, 12 * TILE)
					gatherDefCybY = getCoordRelated(myBaseObject.x, myBaseObject.y, baseX, baseY, 2, 12 * TILE)
				end
				-- dbg("dbg->AIattacked: Attack data stored: base("& baseX/TILE  &"-"& baseY/TILE &") myOBJ("& myBaseObject.x/TILE &"-"& myBaseObject.x/TILE &") gath("& gatherDefTankX/TILE &"-"& gatherDefTankY/TILE &") dist myOBJ from base("& _nDistFromBase/TILE &"/"& nDefendRange/TILE &") dist myOBJ from EnOBJ("& _nDistFromEnemy/TILE &")",player);
				-- printDebug1("AIattacked: Attack data stored, base("& baseX/TILE  &"-"& baseY/TILE &") myOBJ("& myBaseObject.x/TILE &"-"& myBaseObject.x/TILE &") gath("& gatherDefTankX/TILE &"-"& gatherDefTankY/TILE &") dist myOBJ from base("& _nDistFromBase/TILE &"/"& nDefendRange/TILE &") dist myOBJ from EnOBJ("& _nDistFromEnemy/TILE &")");
				
				alertTime = C.gameTime
				alertIsOn = true
				alertX = enemyBaseObject.x
				alertY = enemyBaseObject.y
				
				-- remember coord of attacked obj: build defences
				if C.gameTime - nLastDefSpotUpdate > 5 * TIME_MINUTE then
					defSpotX = myBaseObject.x
					defSpotY = myBaseObject.y
					nLastDefSpotUpdate = C.gameTime
				end
			end
		end
	end
end
callbackEvent(AIattacked, CALL_ATTACKED)

-- if(enemyBaseObject != NULLOBJECT and myBaseObject  != NULLOBJECT){
-- if(bProceed and gameTime - alertTime > 50){
-- }
-- --------------------------------------------------------------
function manageDefTank()
	local _x = 0
	local _y = 0
	local _x1 = 0
	local _y1 = 0
	local _nDist = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: manageDefTank " .. player, player)
	eventCheckTime[6] = C.gameTime
	
	-- if ( gameTime - lastDisplayAI >= 80 ){
	-- displayMsg("manageDefTank: defTK ("& tankDefGroup.members &") at("& tankDefGroup.x/TILE &"-"& tankDefGroup.y/TILE &") alertIsOn ("& alertIsOn &") alertX ("& alertX/TILE &")("& alertY/TILE &")   alertTime ("& alertTime &") alert level ("& alertLevel &")______");
	-- }
	
	if alertLevel == RED_ALERT and C.gameTime > 10 * TIME_MINUTE then
		if alertX >= 0 and alertY >= 0 then
			dropBeaconToAllies("help", alertX, alertY, 0, true)
			dropBeaconToAllies("help", alertX, alertY, 0, false)
		end
	end
	
	if groupCountMembers(tankDefGroup) == 0 then
		return
	end
	
	if gatherDefTankX >= 0 and gatherDefTankY >= 0 then
		count2 = distBetweenTwoPoints(gatherDefTankX, gatherDefTankY, baseX, baseY)
		-- bring def units back at home
		if count2 > nDefendRange then
			gatherDefTankX = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 1, 8 * TILE)
			gatherDefTankY = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 2, 8 * TILE)
		end
	else
		gatherDefTankX = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 1, 8 * TILE)
		gatherDefTankY = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 2, 8 * TILE)
	end
	-- check is not -1;
	if gatherDefTankX == -1 then
		gatherDefTankX = baseX
		gatherDefTankY = baseY
	end
	if gatherDefTankY == -1 then
		gatherDefTankX = baseX
		gatherDefTankY = baseY
	end
	
	-- if an ALERT is on send to ALERT coord
	if alertIsOn then
		_nDist = distBetweenTwoPoints(tankDefGroup.x, tankDefGroup.y, alertX, alertY)
		if _nDist > 1 * TILE and C.gameTime - tDefTankAction > 50 and (groupCountMembers(tankDefGroup) >= MIN_DEFUNIT_DEFEND) then
			orderGroupScoutCMD(tankDefGroup, alertX, alertY)
			tDefTankAction = C.gameTime
		end
	else
		if cybAlertX > 0 then
			cybAlertX = -1
			cybAlertY = -1
		end
		
		-- get a target or gather coord
		if distBetweenTwoPoints(tankDefGroup.x, tankDefGroup.y, baseX, baseY) < nDefendRange then
			if objTargetTankDefGRP == nil then
				objTargetTankDefGRP = objDroidTargetInRange(baseX, baseY, nDefendRange, false)
			end
			if objTargetTankDefGRP == nil then
				objTargetTankDefGRP = objStrTargetInRange(baseX, baseY, nDefendRange)
			end
			
			-- target found!
			if objTargetTankDefGRP ~= nil and groupCountMembers(tankDefGroup) >= MIN_DEFUNIT_ATTACK then
				if C.gameTime - tDefTankAction > 60 then
					if distBetweenTwoPoints(tankDefGroup.x, tankDefGroup.y, objTargetTankDefGRP.x, objTargetTankDefGRP.y) > 2 * TILE then
						orderGroupScoutCMD(tankDefGroup, objTargetTankDefGRP.x, objTargetTankDefGRP.y)
						tDefTankAction = C.gameTime
					end
				end
			else
				if distBetweenTwoPoints(tankDefGroup.x, tankDefGroup.y, gatherDefTankX, gatherDefTankY) > 3 * TILE and C.gameTime - tDefTankAction > 60 then
					orderGroupScoutCMD(tankDefGroup, gatherDefTankX, gatherDefTankY)
					tDefTankAction = C.gameTime
				end
			end
		else
			objTargetTankDefGRP = nil
			if distBetweenTwoPoints(tankDefGroup.x, tankDefGroup.y, gatherDefTankX, gatherDefTankY) > 3 * TILE and C.gameTime - tDefTankAction > 60 then
				orderGroupScoutCMD(tankDefGroup, gatherDefTankX, gatherDefTankY)
				tDefTankAction = C.gameTime
			end
		end
	end
end


-- alertIsOn

-- ======================================================
-- event 18!!!!
function manageDefCyborgs()
	local _nUnitsToBeMoved = 0
	local _nTotUnits = 0
	local _nUnitsRequiredToAttack = 0
	local _x = 0
	local _y = 0
	local _x1 = 0
	local _y1 = 0
	local _nDist = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: manageDefCyborgs " .. player, player)
	eventCheckTime[5] = C.gameTime
	-- if ( gameTime - lastDisplayAI >= 90 ){
	-- displayMsg("manageDefCyborgs: cyborgs ("& cyborgDefGroup.members &") CALLED ("& alertIsOn &") ("& alertX &"-"& alertY &") ");
	-- }
	
	if groupCountMembers(cyborgDefGroup) == 0 then
		return
	end
	
	if gatherDefCybX >= 0 and gatherDefCybY >= 0 then
		count2 = distBetweenTwoPoints(gatherDefCybX, gatherDefCybY, baseX, baseY)
		if count2 > nDefendRange then
			gatherDefCybX = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 1, 8 * TILE)
			gatherDefCybY = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 2, 8 * TILE)
		end
	else
		gatherDefCybX = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 1, 8 * TILE)
		gatherDefCybY = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 2, 8 * TILE)
	end
	if gatherDefCybX == -1 then
		gatherDefCybX = baseX
		gatherDefCybY = baseY
	end
	if gatherDefCybY == -1 then
		gatherDefCybX = baseX
		gatherDefCybY = baseY
	end
	
	if alertIsOn then
		if cybAlertX < 0 or (cybAlertX ~= alertX) then
			if alertX > 0 then
				cybAlertX = alertX
				cybAlertY = alertY
			end
		end
		
		-- go to alert coord
		_nDist = distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, alertX, alertY)
		-- displayMsg("manageDefCyborgs: cyborgs ("& cyborgDefGroup.members &") CALLED ("& alertIsOn &") _nDist("& _nDist/TILE &")");
		if _nDist > 1 * TILE and C.gameTime - tDefCybAction > 50 and (groupCountMembers(cyborgDefGroup) >= MIN_DEFCYB_DEFEND) then
			orderGroupScoutCMD(cyborgDefGroup, cybAlertX, cybAlertY)
			tDefCybAction = C.gameTime
		end
	else
		if groupCountMembers(cyborgDefGroup) >= MIN_DEFUNIT_ATTACK then
			if cybAlertX > 0 then
				cybAlertX = -1
				cybAlertY = -1
			end
			
			-- enemy droid or struct in Cyborg Range?
			count = distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, baseX, baseY)
			if count < nDefendRange then
				if objTargetCybDefGRP == nil then
					objTargetCybDefGRP = objStrTargetInRange(baseX, baseY, nDefendRange)
				end
				if objTargetCybDefGRP == nil then
					objTargetCybDefGRP = objDroidTargetInRange(baseX, baseY, nDefendRange, false)
				end
				-- if no targets go back to gathering points
				if objTargetCybDefGRP == nil then
					if distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, gatherDefCybX, gatherDefCybY) > 3 * TILE and C.gameTime - tDefCybAction > 60 then
						orderGroupScoutCMD(cyborgDefGroup, gatherDefCybX, gatherDefCybY)
						tDefCybAction = C.gameTime
					end
				else
					if C.gameTime - tDefCybAction > 60 then
						count = distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, objTargetCybDefGRP.x, objTargetCybDefGRP.y)
						if count > 2 * TILE then
							orderGroupScoutCMD(cyborgDefGroup, objTargetCybDefGRP.x, objTargetCybDefGRP.y)
							tDefCybAction = C.gameTime
						end
					end
				end
			else
				if distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, gatherDefCybX, gatherDefCybY) > 3 * TILE and C.gameTime - tDefCybAction > 60 then
					orderGroupScoutCMD(cyborgDefGroup, gatherDefCybX, gatherDefCybY)
					tDefCybAction = C.gameTime
				end
			end
		else
			if C.gameTime - tDefCybAction > 60 then
				if distBetweenTwoPoints(cyborgDefGroup.x, cyborgDefGroup.y, gatherDefCybX, gatherDefCybY) > 3 * TILE and C.gameTime - tDefCybAction > 60 then
					orderGroupScoutCMD(cyborgDefGroup, gatherDefCybX, gatherDefCybY)
					tDefCybAction = C.gameTime
				end
			end
		end
	end
end
-- alertIsOn
-- ===================================================================
-- manages idle buildGrp,harvGrp,buildDefGrp and CybEng Grp
-- does not use any money, only help and repairTaks
function manageIdleTrucks()
	ASSERT(player >= 0 and player < 8, "player out of bounds: manageIdleTrucks " .. player, player)
	eventCheckTime[7] = C.gameTime
	-- dbg("manageIdleTrucks: ________________ START 1__________________",player);
	if C.gameTime < 300 then
		return
	end
	
	boolResult = true
	boolResult2 = true
	boolResult3 = true
	
	-- force helpbuild of derricks
	initEnumStruct(false, derrick, player, player)
	structure = enumStruct()
	while structure ~= nil do
		if not structureComplete(structure) then
			if not threatInRange(player, structure.x, structure.y, THREAT_RANGE_TILES_SHORT * 128, false) then
				_idleTruck = pickCybEng(true)
				if _idleTruck == nil then
					_idleTruck = closestIdleDroid(buildGroup, baseX, baseY)
				end
				if _idleTruck ~= nil then
					if droidCanReach(_idleTruck, structure.x, structure.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, structure)
					end
				end
			end
		end
		
		-- else {displayMsg("manageIdleTrucks: there is some threat in range of derrick");}
		structure = enumStruct()
	end
	
	-- force helpbuild of repair Facility first
	initEnumStruct(false, repairFacility, player, player)
	structure = enumStruct()
	while structure ~= nil do
		if not structureComplete(structure) then
			if not threatInRange(player, structure.x, structure.y, THREAT_RANGE_TILES_SHORT * 128, false) then
				_idleTruck = pickCybEng(true)
				if _idleTruck == nil then
					_idleTruck = closestIdleDroid(buildGroup, baseX, baseY)
				end
				if _idleTruck ~= nil then
					if droidCanReach(_idleTruck, structure.x, structure.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, structure)
					end
				end
			end
		end
		-- else {displayMsg("manageIdleTrucks: there is some threat in range of repairFacility");}
		structure = enumStruct()
	end
	
	if (numAAinBase > 4 and bAttackedByVTOL) or not bAttackedByVTOL then
		if groupCountMembers(buildDefGroup) > 0 then
			if not repairDefStructs(BUILDDEF_GRP) then
				if not repairStructs(BUILDDEF_GRP) then
					if not helpBuild(BUILDDEF_GRP) then
						boolResult = helpBuild(BUILDDEF_GRP)
					end
				end
			end
		end
	end
	-- else {displayMsg("manageIdleTrucks:  - nothing to do for BUILDDEF_GRP");}
	
	-- if ( gameTime - lastDisplayAI >= 20 ){  displayMsg("manageIdleTrucks: ________________ START 2__________________");  }
	if groupCountMembers(cyborgConstructGroup) > 0 then
		harvestNearOilRes()
		if not repairStructs(CYBENG_GRP) then
			if not repairDefStructs(BUILDDEF_GRP) then
				if not helpBuild(CYBENG_GRP) then
					boolResult3 = repairDefStructs(CYBENG_GRP)
				end
			end
		end
	end
	-- if( !boolResult3 and gameTime > TIME_HARVESTING_PHASE ){
	-- harvestNearOilRes();
	-- }
	-- if ( gameTime - lastDisplayAI >= 20 ){  displayMsg("manageIdleTrucks: ________________ START 4__________________");  }
	if groupCountMembers(buildGroup) > 0 and lMinBaseStructBuilt then
		if not helpBuild(BUILD_GRP) then
			if not repairStructs(BUILD_GRP) then
				boolResult2 = repairDefStructs(BUILD_GRP)
			end
		end
	end
	-- else {displayMsg("manageIdleTrucks: - nothing to do for BUILD_GRP");}
	
	-- exit;// problems before
	-- if ( gameTime - lastDisplayAI >= 20 ){  displayMsg("manageIdleTrucks: ________________ START 5__________________");  }
	-- send all idle back to the base!!!
	sendIdleBackToTheBase(BUILD_GRP)
	sendIdleBackToTheBase(CYBENG_GRP)
	sendIdleBackToTheBase(BUILDDEF_GRP)
end

-- if ( gameTime - lastDisplayAI >= 80 ){ displayMsg("manageIdleTrucks: ________________ STOP 6__________________");}

-- ================================================
function manageRepairTeam()
	ASSERT(player >= 0 and player < 8, "player out of bounds: manageRepairTeam " .. player, player)
	
	-- if ( gameTime - lastDisplayAI >= 80 ){
	-- displayMsg("manageRepairTeam: _____________ START 1("& toBeRepairedCyborgGroup.members &")("& toBeRepairedTankGroup.members &")("& repairGroup.members &") _______________");
	-- }
	if groupCountMembers(repairGroup) < 0 then
		return
	end
	
	-- displayMsg("manageRepairTeam: _____________ START 2("& tankGroup.members &")("& toBeRepairedTankGroup.members &")("& repairGroup.members &") _______________");
	boolResult = true
	
	droid2 = idleRepairDroid(baseX, baseY)
	if droid2 ~= nil then
		droid = nearestDroidToBeRepaired(toBeRepairedTankGroup, droid2.x, droid2.y)
		if droid ~= nil then
			if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nBaseRange then
				orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
				-- displayMsg("*** manageRepairTeam: found unit in TankRepGroup ("& droid.id &"), health ("& droid.health &")");
				boolResult = false
			end
		end
	end
	-- else { displayMsg("manageRepairTeam: toBeRepairedTankGroup ("& droid.id &") too far away from base"); }
	-- else { displayMsg("manageRepairTeam: toBeRepairedTankGroup droid not found"); }
	-- else { displayMsg("manageRepairTeam: idle repair droid not found"); }
	
	if boolResult then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(toBeRepairedCyborgGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nBaseRange then
					orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
					-- displayMsg("*** manageRepairTeam: found unit in repairGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
					boolResult = false
				end
			end
		end
	end
	
	if boolResult then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(buildGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nBaseRange then
					orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
					-- displayMsg("*** manageRepairTeam: found unit in repairGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
					boolResult = false
				end
			end
		end
	end
	
	if boolResult then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(harvesterGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nBaseRange then
					orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
					-- displayMsg("*** manageRepairTeam: found unit in repairGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
					boolResult = false
				end
			end
		end
	end
	
	if boolResult then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(buildDefGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nBaseRange then
					orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
					-- displayMsg("*** manageRepairTeam: found unit in repairGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
					boolResult = false
				end
			end
		end
	end
	
	if boolResult then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(cyborgConstructGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nBaseRange then
					orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
					-- displayMsg("*** manageRepairTeam: found unit in repairGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
					boolResult = false
				end
			end
		end
	end
	
	if boolResult then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(repairGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if droid.id ~= droid2.id then
					if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nBaseRange then
						orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
						-- displayMsg("*** manageRepairTeam: found unit in repairGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
						boolResult = false
					end
				end
			end
		end
	end
	
	-- modify -> force return to base even if not idle
	initIterateGroup(repairGroup)
	droid = iterateGroup(repairGroup)
	while droid ~= nil do
		if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) > nBaseRange + 5 * TILE then
			orderDroid(droid, DORDER_RTB)
		end
		droid = iterateGroup(repairGroup)
	end
	
	-- As last chance let`s try to completely repair defend idle droids
	if boolResult and not alertIsOn then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(tankDefGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nDefendRange then
					orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
					-- displayMsg("*** manageRepairTeam: found unit in tankDefGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
					boolResult = false
				end
			end
		end
	end
	if boolResult and not alertIsOn then
		droid2 = idleRepairDroid(baseX, baseY)
		if droid2 ~= nil then
			droid = nearestDroidToBeRepaired(cyborgDefGroup, droid2.x, droid2.y)
			if droid ~= nil then
				if distBetweenTwoPoints(droid.x, droid.y, baseX, baseY) < nDefendRange then
					orderDroidObj(droid2, DORDER_DROIDREPAIR, droid)
					-- displayMsg("*** manageRepairTeam: found unit in cyborgDefGroup ("& droid.id &") to be repaired, health ("& droid.health &")");
					boolResult = false
				end
			end
		end
	end
end


-- =====================================================================
function updateBaseDetails()
	ASSERT(player >= 0 and player < 17, "player out of bounds: updateBaseDetails " .. player, player)
	eventCheckTime[17] = C.gameTime
	
	updateBaseRange()
	updateBaseCoord()
	updateBeacons()
	
	-- get all players stats
	updatePlayersStats()
	
	-- units to attack with tanks
	if tChangeTimeTankToAdd == 0 then
		tChangeTimeTankToAdd = tLastTankAttack
	end
	if C.gameTime - tChangeTimeTankToAdd > TIME_CHANGE_TANKSTOADD then
		nAttackingUnitsToAdd = random(MAX_ATTACK_TANKS_ADD)
		nCybAttUnitsToAdd = random(MAX_ATTACK_CYBORG_ADD)
		tChangeTimeTankToAdd = C.gameTime
	end
	
	-- store the oliRes to get at the beginning
	if nTotOilInAtStart < nFreeOilRes then
		nTotOilInAtStart = nFreeOilRes
	end
	
	updateDefendRange()
	
	-- checking if I have min numb of derricks;
	if nPlayersInGame > 1 and nTotOilInAtStart > 0 then
		if nMyDerricks - nDerricksAtStart < nTotOilInAtStart / nPlayersInGame then
			bNeedDerrick = true
		else
			bNeedDerrick = false
		end
	end
	
	-- build defense queue
	count = 0
	pickDefQueueDepth = 0
	while count < numDefStructs do
		if isStructureAvailable(defStructs[count], player) then
			pickDefQueue[pickDefQueueDepth] = defStructs[count]
			pickDefQueueDepth = pickDefQueueDepth + 1
		end
		count = count + 1
	end
	
	-- build wall defense queue
	count = 0
	pickWallDefQueueDepth = 0
	while count < numWallWeaps do
		if isStructureAvailable(wallWeaps[count], player) then
			pickWallDefQueue[pickWallDefQueueDepth] = wallWeaps[count]
			pickWallDefQueueDepth = pickWallDefQueueDepth + 1
		end
		count = count + 1
	end
	
	-- Fortresses queue
	count = 0
	pickFortQueueDepth = 0
	while count < numFortressDef do
		if isStructureAvailable(fortressDef[count], player) then
			pickFortQueue[pickFortQueueDepth] = fortressDef[count]
			pickFortQueueDepth = pickFortQueueDepth + 1
		end
		count = count + 1
	end
	
	-- update structs queue
	count = 0
	pickStrQueueDepth = 0
	while count < numStructs do
		if isStructureAvailable(structs[count], player) then
			pickStrQueue[pickStrQueueDepth] = structs[count]
			pickStrQueueDepth = pickStrQueueDepth + 1
		end
		count = count + 1
	end
end


-- ============================ Debug messages====================
function showPlayerInfo()
	ASSERT(player >= 0 and player < 8, "player out of bounds: showPlayerInfo " .. player, player)
	boolResult = true
end

-- -----------------------------------------------------------------
function buildRepFirst()
	local _nMaxRepFac = 0
	ASSERT(player >= 0 and player < 8, "player out of bounds:.5 " .. player, player)
	eventCheckTime[9] = C.gameTime
	
	-- displayMsg("lStopBuildRepFacility ("& lStopBuildRepFacility &") nPower("& nPower &")");
	if not lStopBuildRepFacility then
		if nMapPower <= LOW_POWER_MAP then
			_nMaxRepFac = 2
		end
		if nMapPower == NORMAL_POWER_MAP then
			_nMaxRepFac = 3
		end
		if nMapPower == HIGH_POWER_MAP then
			_nMaxRepFac = 5
		end
		-- check on quantity and avoid multiple contruction at time, build max repFac - 1 to keep one
		-- repFac to support attack team
		if numStructsByType(repairFacility, player) < _nMaxRepFac and (C.gameTime - nLastTimeBuiltRepFac) > 600 then
			boolResult = false
			if isStructureAvailable(repairFacility, player) then
				buildX = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 1, nBaseRange / 4)
				buildY = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 2, nBaseRange / 4)
				
				boolResult, buildX, buildY = pickStructLocation(repairFacility, buildX, buildY, player)
				-- DylanDog - BUG on BP2.92, the check on struct availability was not made
				if boolResult then
					droid = closestDroidCanBuild(buildGroup, buildX, buildY)
					if droid ~= nil then
						if droidCanReach(droid, buildX, buildY) then
							orderDroidStatsLoc(droid, DORDER_BUILD, repairFacility, buildX, buildY)
							nLastTimeBuiltRepFac = C.gameTime
						end
					end
				end
			end
		end
	end
end



-- ====================================ADVANCED HARVESTER SCRIPT==========================
function harvesterOperate()
	ASSERT(player >= 0 and player < 8, "player out of bounds: harvesterOperate " .. player, player)
	eventCheckTime[10] = C.gameTime
	
	-- displayMsg("harvestOperate: called ("& bOilResLeft &") ("& harvesterGroup.members &")");
	
	if not bOilResLeft then
		return
	end
	
	-- stop moving to oilRes if a derrick is already built in that position or if a threat is present
	stopDroidHarvesting()
	
	_oilRes = nil
	
	-- reset if necessary oilResTargetId, oilResTargetX, oilResTargetY
	checkDerrickIsBuilt(player)
	
	-- nearest oilRes to base, try to pick up the nearest to the base as it is
	-- the easier to defend.
	droid = closestIdleDroid(harvesterGroup, baseX, baseY)
	if droid ~= nil then
		_oilRes = closestOilRes(droid, droid.x, droid.y)
	end
	-- else { displayMsg("harvesterOperate: no idle harvester trucks found"); }
	-- get the number of Derricks built
	if _oilRes ~= nil then
		if nMyDerricks < numMaxDerricks then
			if C.gameTime < TIME_HARVESTING_PHASE then
				_nOilRes = getOilResTargetFree()
				if _nOilRes > -1 and droidCanReach(droid, _oilRes.x, _oilRes.y) then
					oilResTargetId[_nOilRes] = _oilRes.id
					oilResTargetX[_nOilRes] = _oilRes.x
					oilResTargetY[_nOilRes] = _oilRes.y
					orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _oilRes.x, _oilRes.y)
				end
			else
				if count2 < count and droidCanReach(droid, _oilRes.x, _oilRes.y) then
					orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _oilRes.x, _oilRes.y)
				end
			end
		end
	end
end
-- displayMsg("*** harvestOperate: droid (" & droid.id & ")  build DERRICK (" & _oilRes.id  & ") oilResTargetId[" & _nOilRes & "] coord (" & _oilRes.x/TILE  & "-" & _oilRes.y/TILE  & ")" );
-- else {  displayMsg("harvesterOperate: oilRes is too far away ("& count2/TILE &" / "& count/TILE &") ");  }
-- else {  displayMsg("harvesterOperate: oilRes not found");}

-- ======================================================================
function truckGroupSlider()
	ASSERT(player >= 0 and player < 8, "player out of bounds: truckGroupSlider " .. player, player)
	eventCheckTime[11] = C.gameTime
	-- displayMsg("truckGroupSlider 1: b("& buildGroup.members &") d("& buildDefGroup.members  &") h("& harvesterGroup.members  &") ");
	-- at this time the harvesting phase should be finished
	if C.gameTime > TIME_HARVESTING_PHASE then
		if not bOilResLeft then
			initIterateGroup(harvesterGroup)
			droid = iterateGroup(harvesterGroup)
			while droid ~= nil do
				if groupCountMembers(buildGroup) > groupCountMembers(buildDefGroup) then
					groupAddDroid(buildDefGroup, droid)
				else
					groupAddDroid(buildGroup, droid)
				end
				droid = iterateGroup(harvesterGroup)
			end
		else
			if groupCountMembers(harvesterGroup) == 0 then
				if groupCountMembers(buildGroup) > groupCountMembers(buildDefGroup) then
					droid = closestIdleDroid(buildGroup, baseX, baseY)
					if droid == nil then
						droid = getADroid(buildGroup)
					end
					if droid ~= nil then
						groupAddDroid(harvesterGroup, droid)
					end
				else
					if droid == nil then
						droid = pickDefTruck(true)
					end
					if droid == nil then
						droid = getADroid(buildDefGroup)
					end
					if droid ~= nil then
						groupAddDroid(harvesterGroup, droid)
					end
				end
			end
		end
	else
		if bOilResLeft then
			if groupCountMembers(harvesterGroup) < 2 then
				if groupCountMembers(buildDefGroup) >= 1 then
					droid = getADroid(buildDefGroup)
					if droid ~= nil then
						groupAddDroid(harvesterGroup, droid)
					end
				end
			end
			if groupCountMembers(harvesterGroup) < 2 then
				if groupCountMembers(buildGroup) > 1 then
					droid = getADroid(buildGroup)
					if droid ~= nil then
						groupAddDroid(harvesterGroup, droid)
					end
				end
			end
		else
			if groupCountMembers(harvesterGroup) > 0 then
				initIterateGroup(harvesterGroup)
				droid = iterateGroup(harvesterGroup)
				while droid ~= nil do
					if groupCountMembers(buildGroup) > groupCountMembers(buildDefGroup) then
						groupAddDroid(buildDefGroup, droid)
					else
						groupAddDroid(buildGroup, droid)
					end
					droid = iterateGroup(harvesterGroup)
				end
			end
		end
	end
	
	-- gametime > TIME_HARVESTING_PHASE
	
	-- ensure a bit of balance between buildGrp and buildDef GRP
	if not lMinBaseStructBuilt then
		if groupCountMembers(buildDefGroup) > groupCountMembers(buildGroup) then
			droid = getADroid(buildDefGroup)
			if droid ~= nil then
				groupAddDroid(buildGroup, droid)
			end
		end
		
		if groupCountMembers(buildGroup) > groupCountMembers(buildDefGroup) + 1 then
			droid = getADroid(buildGroup)
			if droid ~= nil then
				groupAddDroid(buildDefGroup, droid)
			end
		end
	else
		if groupCountMembers(buildGroup) > groupCountMembers(buildDefGroup) then
			droid = getADroid(buildGroup)
			if droid ~= nil then
				groupAddDroid(buildDefGroup, droid)
			end
		end
		
		if groupCountMembers(buildDefGroup) > groupCountMembers(buildGroup) + 1 then
			droid = getADroid(buildDefGroup)
			if droid ~= nil then
				groupAddDroid(buildGroup, droid)
			end
		end
	end
end

-- displayMsg("truckGroupSlider 2: b("& buildGroup.members &") d("& buildDefGroup.members  &") h("& harvesterGroup.members  &") ");


-- ============================================================================
function defendDerrick()
	local _defStruct = nil
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: defendDerrick " .. player, player)
	eventCheckTime[12] = C.gameTime
	
	if lStopBuildDefDerricks then
		return
	end
	-- displayMsg("_______________ defendDerrick called 1______________");
	
	-- also checks there are already enough def around the derrick
	_derrick = closestDerrickToDefend()
	-- check on time is to avoid this event starts before AIbrain
	if C.gameTime > 300 and _derrick ~= nil then
		droid = pickDefTruck(false)
		
		if droid ~= nil then
			_defStruct = getDefStruct()
			
			if isStructureAvailable(_defStruct, player) then
				buildX = _derrick.x
				buildY = _derrick.y
				if not threatInRange(player, buildX, buildY, THREAT_RANGE_TILES * 128, false) then
					__result, buildX, buildY = pickStructLocation(_defStruct, buildX, buildY, player)
					if __result then
						if droidCanReach(droid, buildX, buildY) then
							orderDroidStatsLoc(droid, DORDER_BUILD, _defStruct, buildX, buildY)
						end
					end
				end
			end
		end
	end
end

-- else { displayMsg("defendDerrick : some threat in range") ;}
-- else { displayMsg("defendDerrick : structure no available") ;}
-- else {  displayMsg("defendDerrick : NO idle trucks found") ; }
-- else { displayMsg("defendDerrick : NO DERRICKS FOUND???"); }

-- ============================================================================
-- build a power gen for every 4 derricks. VITAL!
function buildPowerGenerators()
	ASSERT(player >= 0 and player < 8, "player out of bounds:.13 " .. player, player)
	eventCheckTime[13] = C.gameTime
	
	-- search for incompleted structure fist
	boolResult = true
	initEnumStruct(false, powGen, player, player)
	structure = enumStruct()
	while structure ~= nil and boolResult do
		if not structureComplete(structure) then
			droid = closestDroidCanBuild(buildGroup, structure.x, structure.y)
			if droid ~= nil then
				if droidCanReach(droid, structure.x, structure.y) then
					orderDroidObj(droid, DORDER_HELPBUILD, structure)
					boolResult = false
				end
			end
		end
		-- else { displayMsg("*** buildPowerGenerators: completing powGen - DROID NOT FOUND"); }
		-- else { displayMsg("*** buildPowerGenerators: struct is complete"); }
		structure = enumStruct()
	end
	
	if boolResult and (numStructsByType(powGen, player) * 4) < numStructsByType(derrick, player) and (C.gameTime - tLastPowerGen) > 300 then
		buildX = baseX
		buildY = baseY
		boolResult, buildX, buildY = pickStructLocation(powGen, buildX, buildY, player)
		if boolResult then
			droid = closestDroidCanBuild(buildGroup, baseX, baseY)
			if droid ~= nil then
				if droidCanReach(droid, buildX, buildY) then
					-- displayMsg("*** buildPowerGenerators: building Power Generator - Derricks ("& count &") powGen ("& count2 &") last build ("& tLastPowerGen &"), ("& (gameTime - tLastPowerGen)/10 &") secs ago");
					orderDroidStatsLoc(droid, DORDER_BUILD, powGen, buildX, buildY)
				end
				tLastPowerGen = C.gameTime
			end
		end
	end
end

-- -------------------------------------
function defendGatewaysPoint()
	ASSERT(player >= 0 and player < 8, "player out of bounds: defendGatewaysPoint " .. player, player)
	eventCheckTime[14] = C.gameTime
	_idleTruck = nil
	_notIdleTruck = nil
	-- --------------------------------
	-- displayMsg("defendGatewaysPoint: lStopBuildDefGateway("& lStopBuildDefGateway &") defTanks("& buildDefGroup.members &") pickWallDefQueueDepth("& pickWallDefQueueDepth &")nRealGatewaysFound("& nRealGatewaysFound &") numGTW("& nRealGatewaysFound &") defStrAtGTW("& numDefStrAtGateway &")");
	
	if groupCountMembers(buildDefGroup) < 0 or lStopBuildDefGateway then
		return
	end
	
	-- defend real gateways if they exists
	if nRealGatewaysFound == 0 then
		deactivateEvent(defendGatewaysPoint)
		return
	end
	
	_idleTruck = pickDefTruck(false)
	if _idleTruck == nil then
		return
	end
	
	count = 0
	boolResult = true
	while count < nRealGatewaysFound and boolResult do
		count2 = numFriendlyWeapStructsInRange(player, aGatewayPosX[count], aGatewayPosY[count], 2 * TILE, false)
		-- displayMsg("defendGatewaysPoint: _____________ GTW("& count &"/"& nRealGatewaysFound &") numDefStrAtGateway("& count2 &"/"& numDefStrAtGateway &")_____________");
		if count2 < numDefStrAtGateway and not threatInRange(player, aGatewayPosX[count], aGatewayPosY[count], THREAT_RANGE_TILES * 128, false) then
			buildGatewayDef(_idleTruck, count)
			-- exit the loop
			boolResult = false
		else
			displayMsg("defendGatewaysPoint: cannot build def as GTW(" .. count .. " >= " .. nRealGatewaysFound .. ") or threat in range")
		end
		count = count + 1
	end
end


-- =======================================================================
function defendBase()
	local _defStruct = nil
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: defendBase " .. player, player)
	eventCheckTime[15] = C.gameTime
	
	-- dbg("dbg->defendBase: lStopBuildDef ("& lStopBuildDef &")  time("& gameTime - tLastbuildBaseDef &") > ("& TIME_TOFORCE_BUILDDEF &")",player);
	if pickDefQueueDepth <= 0 and pickWallDefQueueDepth <= 0 then
		return
	end
	
	-- hack, check time to avoid building at very beginning
	if lStopBuildDef or C.gameTime < 2 * TIME_MINUTE then
		return
	end
	
	droid = pickDefTruck(false)
	if droid == nil then
		return
	end
	
	count = random(100)
	if AIPersonality == AI_TURTLE then
		count = count + 25
	end
	if pickFortQueueDepth > 0 and count > 75 and lMinBaseStructBuilt then
		count = random(pickFortQueueDepth)
		_defStruct = pickFortQueue[count]
	else
		_defStruct = getDefStruct()
	end
	
	-- ----------- build! ----------------
	if isStructureAvailable(_defStruct, player) then
		if defSpotX > 0 and defSpotY > 0 then
			buildX = defSpotX
			buildY = defSpotY
		else
			buildX = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 1, count * TILE)
			buildY = getCoordRelated(baseX, baseY, C.mapWidth * TILE / 2, C.mapHeight * TILE / 2, 2, count * TILE)
		end
		
		-- check number of def already built in area
		if numFriendlyWeapStructsInRange(player, buildX, buildY, TILE * 6, false) < MAX_DEFSTR_SPOT then
			boolResult, buildX, buildY = pickStructLocation(_defStruct, buildX, buildY, player)
			if boolResult == true then
				if droidCanReach(droid, buildX, buildY) then
					printDebug1("defendBase: building base defence on coord (" .. buildX / TILE .. "-" .. buildY / TILE .. ") defSpotX-Y(" .. defSpotX / TILE .. ")(" .. defSpotY / TILE .. ")")
					orderDroidStatsLoc(droid, DORDER_BUILD, _defStruct, buildX, buildY)
					tLastbuildBaseDef = C.gameTime
				end
			end
		else
			if C.gameTime - tLastbuildBaseDef > TIME_TOFORCE_BUILDDEF then
				__result, buildX, buildY = pickStructLocation(_defStruct, buildX, buildY, player)
				if __result then
					if droidCanReach(droid, buildX, buildY) then
						printDebug1("defendBase: force building base defence on coord (" .. buildX / TILE .. "-" .. buildY / TILE .. ") defSpotX-Y(" .. defSpotX / TILE .. ")(" .. defSpotY / TILE .. ")")
						orderDroidStatsLoc(droid, DORDER_BUILD, _defStruct, buildX, buildY)
						tLastbuildBaseDef = C.gameTime
					end
				end
			end
		end
	else
		printDebug1("#### Trying to build a def struct which is not available")
	end
end


-- ==========================================================================
function upgradeStructures()
	ASSERT(player >= 0 and player < 8, "player out of bounds:.17 " .. player, player)
	eventCheckTime[16] = C.gameTime
	
	droid = closestIdleDroid(buildGroup, baseX, baseY)
	if droid == nil then
		droid = pickDefTruck(true)
	end
	if droid ~= nil then
		boolResult = true
		
		if lMinBaseStructBuilt then
			initEnumStruct(false, powGen, player, player)
			structure = enumStruct()
			while structure ~= nil and boolResult do
				if structureComplete(structure) and isStructureAvailable(powModule, player) and (not testStructureModule(player, structure, 0)) then
					orderDroidStatsLoc(droid, DORDER_BUILD, powModule, structure.x, structure.y)
					boolResult = false
				end
				structure = enumStruct()
			end
		end
		
		-- if "R-Vehicle-Body05" is not completed we do not perform the upgrade
		if not lStopFactUpgrade and boolResult then
			initEnumStruct(false, factory, player, player)
			structure = enumStruct()
			while structure ~= nil and boolResult do
				if structureComplete(structure) and isStructureAvailable(facModule, player) and (skGetFactoryCapacity(structure) < 1) then
					orderDroidStatsLoc(droid, DORDER_BUILD, facModule, structure.x, structure.y)
					boolResult = false
				end
				structure = enumStruct()
			end
			
			if not lStopFactUpgrade2 and boolResult then
				initEnumStruct(false, factory, player, player)
				structure = enumStruct()
				while structure ~= nil and boolResult do
					if structureComplete(structure) and isStructureAvailable(facModule, player) and (skGetFactoryCapacity(structure) < 2) then
						orderDroidStatsLoc(droid, DORDER_BUILD, facModule, structure.x, structure.y)
						boolResult = false
					end
					structure = enumStruct()
				end
			end
			
			initEnumStruct(false, vtolFactory, player, player)
			structure = enumStruct()
			while structure ~= nil and boolResult do
				if structureComplete(structure) and isStructureAvailable(facModule, player) and (skGetFactoryCapacity(structure) < 2) then
					orderDroidStatsLoc(droid, DORDER_BUILD, facModule, structure.x, structure.y)
					boolResult = false
				end
				structure = enumStruct()
			end
		end
		
		-- if ( !lStopFactUpgrade and boolResult )
		
		-- researches
		if not lStopResLabUpgrade and boolResult then
			initEnumStruct(false, resLab, player, player)
			structure = enumStruct()
			while structure ~= nil and boolResult do
				if structureComplete(structure) and isStructureAvailable(resModule, player) and (not testStructureModule(player, structure, 0)) then
					orderDroidStatsLoc(droid, DORDER_BUILD, resModule, structure.x, structure.y)
					boolResult = false
				end
				structure = enumStruct()
			end
		end
	end
end
-- power check

-- else { displayMsg("UpgradeStructures: no idle buildDroid found!! ");   }

-- ===========================================================================
-- (CALL_NEWDROID,player, ref droid,ref structure);
function droidBuilt(_droid, _structure)
	if _droid.player ~= player then return end
	droid, structure = _droid, _structure -- wz2lua: probably these can be used as function arguments directly
	ASSERT(player >= 0 and player < 8, "player out of bounds: droidBuilt " .. player, player)
	
	boolResult = true
	-- dbg("dbg->droidBuilt : droid ("& droid.id &") hitPoints ("& droid.hitPoints &") ",player);
	if droid ~= nil then
		if droid.player ~= player then
			return
		end
		-- TANK
		if droid.droidType == DROID_WEAPON and droid.propulsion ~= cyborgPropulsion then
			nTotTankBuilt = nTotTankBuilt + 1
			-- displayMsg("droidBuilt: tank ("& droid.id &") hitPoints ("& droid.hitPoints &") power ("& calcDroidPower(droid) &") ");
			groupAddDroid(tankDefGroup, droid)
		end
		
		-- TANK REPAIR
		if droid.droidType == DROID_REPAIR then
			groupAddDroid(repairGroup, droid)
		end
		
		-- TANK CONTRUCTOR
		if droid.droidType == DROID_CONSTRUCT then
			groupAddDroid(buildGroup, droid)
		end
		
		-- CYBORG
		if droid.propulsion == cyborgPropulsion then
			if droid.droidType == DROID_CYBORG_CONSTRUCT then
				groupAddDroid(cyborgConstructGroup, droid)
			else
				nTotCyborgBuilt = nTotCyborgBuilt + 1
				if AIPersonality == AI_CYBORG then
					groupAddDroid(cyborgDefGroup, droid)
				else
					if nTotCyborgBuilt > 2 then
						groupAddDroid(tankDefGroup, droid)
						nTotCyborgBuilt = 0
					else
						groupAddDroid(cyborgDefGroup, droid)
					end
				end
			end
		end
		
		-- VTOL
		if isVtol(droid) then
			groupAddDroid(vtolDefendGr, droid)
			-- need to check if I have to give new droid an order to attack
			if attTargetVTOL ~= nil then
				if not friendlyPlayer(attTargetVTOL.player) then
					orderDroidObj(droid, DORDER_ATTACK, attTargetVTOL)
				end
			end
			-- else { displayMsg("droidbuilt: attTargetVTOL is NULL ");  }
			if defTargetVTOL ~= nil then
				if not friendlyPlayer(defTargetVTOL.player) then
					orderDroidObj(droid, DORDER_ATTACK, defTargetVTOL)
				end
			end
			-- else {  displayMsg("droidbuilt: defTargetVTOL is NULL "); }
			-- setDroidSecondary(droid, DSO_PATROL, DSS_PATROL_SET);
			return
		end
		
		-- to be improved: add secondary for weapons cyborgs
		setDroidSecondary(droid, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER)
		setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_PERSUE)
		setDroidSecondary(droid, DSO_ATTACK_LEVEL, DSS_ALEV_ALWAYS)
		
		boolResult = false
		if droid.droidType == DROID_WEAPON then
			boolResult = true
			-- short range tanks
			if droid.weapon == Flamer or droid.weapon == PlasmFlamer or droid.weapon == Inferno or droid.weapon == PlasmaCannon or droid.weapon == EMPCannon or droid.weapon == AGun or droid.weapon == MGun or droid.weapon == TwinMGun or droid.weapon == HMGun or droid.weapon == TwinAGun then
				setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_SHORT)
			else
				-- displayMsg("droidbuilt: short attack range assigned to tank ");
				-- long range  tanks-1
				if droid.weapon == LCannon or droid.weapon == MCannon or droid.weapon == ACannon or droid.weapon == HCannon or droid.weapon == TACannon or droid.weapon == NeedleGun or droid.weapon == RailGun or droid.weapon == GaussCannon then
					setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_SHORT)
				else
					-- displayMsg("droidbuilt: short attack range assigned to tank ");
					if droid.weapon == FlashLight or droid.weapon == PulseLaser or droid.weapon == HeavyLaser then
						setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG)
					else
						-- displayMsg("droidbuilt: long attack range assigned to Laser-tank ");
						-- long range  tanks-2
						if droid.weapon == RocketBB or droid.weapon == RocketPod or droid.weapon == HVCannon or droid.weapon == RocketMRL or droid.weapon == Lancer or droid.weapon == TankKiller or droid.weapon == RippleRockets or droid.weapon == ScourgeMissle or droid.weapon == ArchangelMissile then
							setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG)
						else
							setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_DEFAULT)
						end
					end
				end
			end
		end
		-- displayMsg("droidbuilt: default attack range assigned to droid ");
		
		if droid.propulsion == cyborgPropulsion and droid.droidType ~= DROID_CYBORG_CONSTRUCT then
			boolResult = true
			-- short range cyborgs
			if droid.weapon == cybGren or droid.weapon == cybLancer or droid.weapon == cybScourge or droid.weapon == cybSuperHPV or droid.weapon == cybSuperScourge or droid.weapon == cybTankKiller then
				setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG)
			else
				setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_SHORT)
			end
		end
	end
end
callbackEvent(droidBuilt, CALL_NEWDROID)

-- for debug purposes only
-- if( !boolResult ){
-- dbg("dbg->droidbuilt: no attack range assigned to droid",player);
-- }

-- droid != NULLOBJECT
-- }

-- ================== UNITS RESORTING SCRIPT ==========================
function reSortUnits()
	ASSERT(player >= 0 and player < 8, "player out of bounds: reSortUnits " .. player, player)
	
	groupAddAreaNoGroup(xGroup, player, 0, 0, (C.mapWidth * 128), (C.mapHeight * 128))
	-- dbg("reSortUnits: xGroup.members bofore re-sort ("& xGroup.members &") _________________",player);
	initIterateGroup(xGroup)
	droid = iterateGroup(xGroup)
	while droid ~= nil do
		assignDroidToGrp(droid)
		droid = iterateGroup(xGroup)
	end
	
	groupAddAreaNoGroup(xGroup, player, 0, 0, (C.mapWidth * 128), (C.mapHeight * 128))
	-- dbg("reSortUnits: xGroup.members after re-sort ("& xGroup.members &") _______________",player);
	
	-- deactivate itself
	deactivateEvent(reSortUnits)
end

-- }

-- =============================================================================
function SelectTankTemplate()
	local _nRnd = 0
	local _nRnd2 = 0
	local _nBestHvyBody = 0
	local _nBestMedBody = 0
	local _nBestLghBody = 0
	
	eventCheckTime[17] = C.gameTime
	ASSERT(player >= 0 and player < 8, "player out of bounds:.27 " .. player, player)
	
	-- displayMsg("SelectTankTemplate 1: nWorkingFact("& nWorkingFact &") nFactories("& nFactories &") boolResult ("& boolResult &") nProdSelect("& nProdSelect &") stopProdTank("& lStopTankProduction &")_______________");
	
	if getDroidCount(player) >= MAX_DROIDS then
		return
	end
	if nWorkingFact == nFactories then
		return
	end
	
	boolResult = true
	
	-- build trucks
	if C.gameTime > TIME_HARVESTING_PHASE and (numTemplatesInProduction(constructor2, player) > 0 or numTemplatesInProduction(constructor, player) > 0) then
		lStopBuildTankProd = true
	end
	if not lStopBuildTankProd then
		initEnumStruct(false, factory, player, player)
		structure = enumStruct()
		while structure ~= nil and boolResult do
			if structureComplete(structure) and structureIdle(structure) then
				if skCanBuildTemplate(player, structure, constructor2) then
					buildDroid(constructor2, structure, player, 1)
				else
					buildDroid(constructor, structure, player, 1)
				end
				lastTruckBuilt = C.gameTime
				boolResult = false
			end
			structure = enumStruct()
		end
	end
	
	-- repair Truck
	if boolResult and groupCountMembers(repairGroup) + numTemplatesInProduction(repairTank, player) < MAX_REPAIR_UNITS then
		if getStructure(repairFacility, player) == nil then
			if C.gameTime > TIME_HARVESTING_PHASE then
				initEnumStruct(false, factory, player, player)
				structure = enumStruct()
				while structure ~= nil and boolResult do
					if structureComplete(structure) and structureIdle(structure) then
						if skCanBuildTemplate(player, structure, repairTank) then
							boolResult = false
							-- build tank repair
							buildDroid(repairTank, structure, player, 1)
							-- avoid multipe builds in high power
							lastTimeRepairBuilt = C.gameTime
						end
					end
					-- else { displayMsg("SelectTankTemplate: 1-cannot build template for repair tank");}
					structure = enumStruct()
				end
			end
		end
	end
	
	-- do not build any other type of tanks for cyborgAI
	if AIPersonality == AI_CYBORG then
		return
	end
	
	-- displayMsg("SelectTankTemplate 2: nWorkingFact("& nWorkingFact &") nFactories("& nFactories &") boolResult ("& boolResult &") nProdSelect("& nProdSelect &") stopProdTank("& lStopTankProduction &")_______________");
	
	-- build tanks
	if boolResult and not lStopTankProduction then
		boolResult = true
		-- tmpl to be built
		_pos = -1
		
		initEnumStruct(false, factory, player, player)
		structure = enumStruct()
		while structure ~= nil and boolResult do
			if structureComplete(structure) and structureIdle(structure) then
				_nRnd = random(100)
				if _nRnd < 40 then
					_nRnd = 0
				end
				if _nRnd >= 40 and _nRnd < 70 then
					_nRnd = 1
				end
				if _nRnd >= 70 and _nRnd < 100 then
					_nRnd = 2
				end
				-- body type
				_nRnd2 = random(100)
				
				-- heavy
				_nBestHvyBody = checkBestBody(BODY_HEAVY, _nRnd, structure)
				-- medium
				_nBestMedBody = checkBestBody(BODY_MEDIUM, _nRnd, structure)
				-- light
				_nBestLghBody = checkBestBody(BODY_LIGHT, _nRnd, structure)
				
				-- dbg("SelectTankTemplate: _nRnd("& _nRnd &") bodies hv-md-lg("& _nBestHvyBody &")("& _nBestMedBody &")("& _nBestLghBody &")",player);
				printDebug1("SelectTankTemplate: _nRnd2(" .. _nRnd2 .. ") _nRnd(" .. _nRnd .. ") bodies hv-md-lg(" .. _nBestHvyBody .. ")(" .. _nBestMedBody .. ")(" .. _nBestLghBody .. ")")
				
				if _nBestHvyBody == 0 and _nBestMedBody == 0 and _nBestLghBody == 0 then
					printDebug1("####SelectTankTemplate: Not able to build any template with _nRnd(" .. _nRnd .. "); bodies hv-md-lg(" .. _nBestHvyBody .. ")(" .. _nBestMedBody .. ")(" .. _nBestLghBody .. ")")
					--
					-- Viper Flamer
					if skCanBuildTemplate(player, structure, tmpl0[61]) then
						buildDroid(tmpl0[61], structure, player, 1)
					else
						if skCanBuildTemplate(player, structure, tmpl0[60]) then
							buildDroid(tmpl0[60], structure, player, 1)
						else
							if skCanBuildTemplate(player, structure, tmpl0[62]) then
								buildDroid(tmpl0[62], structure, player, 1)
							else
								printDebug1("####SelectTankTemplate: REALLY not able to build any tank template !!")
							end
						end
					end
					return
				end
				
				-- Heavy and Medium are availabe
				if _nBestHvyBody > 0 then
					if _nBestMedBody > 0 then
						if _nRnd2 < 65 then
							boolResult = buildHeavyTank(_nRnd, structure)
						else
							boolResult = buildMediumTank(_nRnd, structure)
						end
					else
						boolResult = buildHeavyTank(_nRnd, structure)
					end
				end
				
				-- Medium and Light are availabe
				if _nBestHvyBody == 0 then
					if _nBestMedBody > 0 then
						if _nBestLghBody > 0 then
							if _nRnd2 < 65 then
								boolResult = buildMediumTank(_nRnd, structure)
							else
								boolResult = buildLightTank(_nRnd, structure)
							end
						else
							boolResult = buildMediumTank(_nRnd, structure)
						end
					end
				end
				
				-- Only Light is availabe
				if _nBestHvyBody == 0 and _nBestMedBody == 0 and _nBestLghBody > 0 then
					boolResult = buildLightTank(_nRnd, structure)
				end
			end
			
			
			-- if ( boolResult ){
			-- dbg("Building Tank: _nRnd("& _nRnd &") _nRnd2("& _nRnd2 &") bodies hv-md-lg("& _nBestHvyBody &")("& _nBestMedBody &")("& _nBestLghBody &")",player);
			-- printDebug1(" Building Tank: _nRnd("& _nRnd &") _nRnd2("& _nRnd2 &") bodies hv-md-lg("& _nBestHvyBody &")("& _nBestMedBody &")("& _nBestLghBody &")");
			-- } else {
			-- printDebug1("#### Not able to build _nRnd("& _nRnd &") _nRnd2("& _nRnd2 &") bodies hv-md-lg("& _nBestHvyBody &")("& _nBestMedBody &")("& _nBestLghBody &")");
			-- }
			
			-- endif(structureComplete(structure) and structureIdle(structure))
			
			structure = enumStruct()
		end
	end
end
-- end while

-- endif (boolResult and !lStopTankProduction)

-- =========================================================================
function SelectCyborgTemplate()
	local cybTmpl[17] = nil
	local _nRnd = 0
	local _pos = 0
	local _bBuildAR_cyborg = false
	local _bBuildAT_cyborg = false
	local _bBuildAP_cyborg = false
	local _bBuildKK_cyborg = false
	
	ASSERT(player >= 0 and player < 8, "player out of bounds:.29 " .. player, player)
	eventCheckTime[18] = C.gameTime
	-- displayMsg("*** SelectCyborgTemplate: ___________ CALLED lStopCybProduction("& lStopCybProduction &") droids tot("& getDroidCount(player) &"/"& MAX_DROIDS &")___________");
	
	_pos = -1
	-- AllRounder
	_bBuildAR_cyborg = false
	-- AntiTank
	_bBuildAT_cyborg = false
	-- AntiPersonnel
	_bBuildAP_cyborg = false
	-- Kinetic (Grenadier-NeedleGunner)
	_bBuildKK_cyborg = false
	
	if getDroidCount(player) >= MAX_DROIDS then
		return
	end
	
	if not lStopCybProduction then
		initEnumStruct(false, cybFactory, player, player)
		structure = enumStruct()
		boolResult = true
		while structure ~= nil and boolResult do
			if structureComplete(structure) and structureIdle(structure) then
				boolResult = true
				
				-- build cyborg constructor
				if not lStopCybEngProd then
					boolResult = false
					lastCybEngBuilt = C.gameTime
					buildDroid(cybcondroid, structure, player, 1)
				end
				
				
				-- build cyborg Mechanic
				--[[if ( nCybMechanic < 3 and (gameTime - tLastCybMech > 2*TIME_MINUTE) ){
				            tLastCybMech = gameTime;
				            nCybMechanic++;
										buildDroid(cybMech, structure, player, 1); 
				          }]]--
				
				if boolResult then
					count = 0
					while _pos == -1 and count < 20 do
						_nRnd = random(100)
						if _nRnd < 30 then
							_bBuildAR_cyborg = true
							nTotCybAR = nTotCybAR + 1
						else
							if _nRnd >= 30 and _nRnd < 55 then
								_bBuildAT_cyborg = true
								nTotCybAT = nTotCybAT + 1
							else
								if _nRnd >= 55 and _nRnd < 80 then
									_bBuildAP_cyborg = true
									nTotCybAP = nTotCybAP + 1
								else
									_bBuildKK_cyborg = true
									nTotCybKK = nTotCybKK + 1
								end
							end
						end
						
						-- Build best Anti-Tank Template
						if _bBuildAT_cyborg then
							if skCanBuildTemplate(player, structure, superCyb[9]) then
								_pos = 9
							end
							-- Scourge
							if skCanBuildTemplate(player, structure, superCyb[7]) then
								_pos = 7
							end
							if random(10) < 5 then
								if skCanBuildTemplate(player, structure, superCyb[3]) then
									_pos = 3
								end
							else
								if skCanBuildTemplate(player, structure, superCyb[0]) then
									_pos = 0
								else
									if skCanBuildTemplate(player, structure, superCyb[3]) then
										_pos = 3
									end
								end
							end
						end
						
						-- Build best All-Rounder Template
						if _bBuildAR_cyborg then
							if skCanBuildTemplate(player, structure, superCyb[6]) then
								_pos = 6
							end
							if skCanBuildTemplate(player, structure, superCyb[5]) then
								_pos = 5
							end
							if skCanBuildTemplate(player, structure, superCyb[4]) then
								_pos = 4
							end
							if skCanBuildTemplate(player, structure, superCyb[1]) then
								_pos = 1
							end
						end
						
						-- Build best Anti-Personnel Template
						if _bBuildAP_cyborg then
							if random(100) < 65 then
								if skCanBuildTemplate(player, structure, superCyb[15]) then
									_pos = 15
								end
								if skCanBuildTemplate(player, structure, superCyb[12]) then
									_pos = 12
								end
								if skCanBuildTemplate(player, structure, superCyb[10]) then
									_pos = 10
								end
								if skCanBuildTemplate(player, structure, superCyb[2]) then
									_pos = 2
								end
							else
								if skCanBuildTemplate(player, structure, superCyb[16]) then
									_pos = 16
								end
								if skCanBuildTemplate(player, structure, superCyb[14]) then
									_pos = 14
								end
								if skCanBuildTemplate(player, structure, superCyb[11]) then
									_pos = 11
								end
							end
						end
						
						-- Build best Kinetic Template
						if _bBuildKK_cyborg then
							if skCanBuildTemplate(player, structure, superCyb[13]) then
								_pos = 13
							end
							if skCanBuildTemplate(player, structure, superCyb[8]) then
								_pos = 8
							end
						end
						count = count + 1
					end
					-- endwhile
					
					if _pos == -1 then
						printDebug1("#### SelectCyborgTemplate: (A) cannot build template [" .. _pos .. "] ")
						nTotCybErr = nTotCybErr + 1
						return
					end
					if skCanBuildTemplate(player, structure, superCyb[_pos]) then
						buildDroid(superCyb[_pos], structure, player, 1)
						boolResult = false
					else
						printDebug1("#### SelectCyborgTemplate: (B) cannot build template [" .. _pos .. "] ")
					end
				end
			end
			
			-- end check on tankGroupMembers
			
			structure = enumStruct()
		end
	end
end


-- ---------------------- DylanDog ----------------------------------
function buildRepFacSuppAttack()
	local _totFacilities = 0
	eventCheckTime[19] = C.gameTime
	
	-- need to think if this is ok
	return
end

-- =======================================================================
-- do research
-- doResearchTr
function doResearch()
	ASSERT(player >= 0 and player < 8, "player out of bounds:.44 " .. player, player)
	eventCheckTime[20] = C.gameTime
	-- displayMsg("doResearch:___________("& lStopResearch &")prod["& nProdSelect &"]work("& getNumStructNotIdle(resLab) &")______________");
	
	initEnumStruct(false, resLab, player, player)
	structure = enumStruct()
	count = 0
	boolResult2 = true
	while structure ~= nil and boolResult2 do
		if structureIdle(structure) and structureComplete(structure) then
			if bAttackedByVTOL then
				if not researchFinished(CycloneAASite, player) then
					boolResult = pursueResearch(structure, player, CycloneAASite)
					if boolResult then
						printDebug1("doResearch: forcing research of Cyclone AA Site")
						boolResult2 = false
						tLastResearch = C.gameTime
					end
				end
			end
			-- execute only once
			-- need rearmin pad for VTOL troops?
			if nVTOLFactories > 0 then
				if not isStructureAvailable(vtolPad, player) then
					boolResult = pursueResearch(structure, player, VTOLPadRes)
					if boolResult then
						printDebug1("doResearch: forced research OF VTOLPad")
						boolResult2 = false
						tLastResearch = C.gameTime
					end
				end
			end
			-- execute only once
			
			if not lStopResearch and boolResult2 then
				if bForceResPowUp then
					if not researchFinished(powUpgrades3, player) then
						boolResult = pursueResearch(structure, player, powUpgrades3)
						if boolResult then
							boolResult2 = false
							tLastResearch = C.gameTime
							-- dbg("dbg->doResearch: ("& getPlayerName(player) &") OK forcing research of POWER UPGRADES 'powUpgrades3' ",player);
							printDebug1("doResearch: OK forcing research of POWER UPGRADES 'powUpgrades3' ")
						end
					else
						if not researchFinished(powUpgrades6, player) then
							boolResult = pursueResearch(structure, player, powUpgrades6)
							if boolResult then
								boolResult2 = false
								tLastResearch = C.gameTime
								-- dbg("dbg->doResearch: ("& getPlayerName(player) &") forcing research of POWER UPGRADES 'powUpgrades6' ",player);
								printDebug1("doResearch: OK forcing research of POWER UPGRADES 'powUpgrades6' ")
							end
						end
					end
				end
				-- else { dbg("dbg->doResearch: ("& getPlayerName(player) &") failed forcing research of POWER UPGRADES 'powUpgrades6' ",player);       }
				
				-- Need a CB tower and bombard ?
				if boolResult2 and bAttackedByMortars then
					if not researchFinished(resCBSense, player) then
						boolResult = pursueResearch(structure, player, resCBSense)
						if boolResult then
							boolResult2 = false
							tLastResearch = C.gameTime
							-- dbg("dbg->doResearch: ("& getPlayerName(player) &") attacked by long range weapon weap OK FORCING RESEARCH OF CB TOWER ",player);
							printDebug1("doResearch: attacked by long range weapon weap forcing research of CB TOWER")
						end
					else
						if not researchFinished(bombardPit, player) then
							boolResult = pursueResearch(structure, player, bombardPit)
							if boolResult then
								boolResult2 = false
								tLastResearch = C.gameTime
								-- dbg("dbg->doResearch: ("& getPlayerName(player) &") attacked by long range weapon weap OK FORCING RESEARCH OF BOMBARD ",player);
								printDebug1("doResearch: attacked by long range weapon weap forcing research of BOMBARD")
							end
						end
					end
				end
				-- else { dbg("dbg->doResearch: ("& getPlayerName(player) &") attacked by long range weapon weap FAILED FORCING RESEARCH OF BOMBARD ",player);           }
				
				-- Need a CB tower and RippleRockets ?
				if boolResult2 and bAttackedByLongRangeWeap then
					if not researchFinished(resCBSense, player) then
						boolResult = pursueResearch(structure, player, resCBSense)
						if boolResult then
							boolResult2 = false
							tLastResearch = C.gameTime
							-- dbg("dbg->doResearch: ("& getPlayerName(player) &") attacked by very long range weap OK forcing research of CB TOWER",player);
							printDebug1("doResearch: attacked by very long range weap forcing research of OF CB TOWER")
						end
					else
						if not researchFinished(rippleRockets, player) then
							boolResult = pursueResearch(structure, player, rippleRockets)
							if boolResult then
								boolResult2 = false
								tLastResearch = C.gameTime
								-- dbg("dbg->doResearch: ("& getPlayerName(player) &") attacked by very long range weap OK forcing research of RippleRockets ",player);
								printDebug1("doResearch: attacked by very long range weap OK forcing research of RippleRockets")
							end
						end
					end
				end
				-- else {   dbg("dbg->doResearch: ("& getPlayerName(player) &") attacked by very long range weap FAILED forcing research of RippleRockets ",player);            }
				
				-- Need Scorpion for VTOL templates?
				if boolResult2 and not researchFinished(scorpionBody, player) and isStructureAvailable(vtolFactory, player) then
					boolResult = pursueResearch(structure, player, scorpionBody)
					if boolResult then
						boolResult2 = false
						tLastResearch = C.gameTime
						-- dbg("dbg->doResearch: ("& getPlayerName(player) &") forcing research to Scorpion body",player);
						printDebug1("doResearch: forcing research to Scorpion body as VTOL struct is available")
					end
				end
				
				-- Need Scorpion for VTOL templates?
				if boolResult2 and not researchFinished(lancerATweap, player) and isStructureAvailable(vtolFactory, player) then
					boolResult = pursueResearch(structure, player, lancerATweap)
					if boolResult then
						boolResult2 = false
						tLastResearch = C.gameTime
						-- dbg("dbg->doResearch: ("& getPlayerName(player) &") forcing research to Scorpion body",player);
						printDebug1("doResearch: forcing research to Lancer AT weapon as VTOL struct is available")
					end
				end
				
				-- perform a standard Research
				if boolResult2 and do_Research(structure, 0) < 0 then
					printDebug1("doResearch: no standard research to pursue found, doing a random research")
					skDoResearch(structure, player, 1)
					tLastResearch = C.gameTime
					-- execute only once
					boolResult2 = false
				else
					boolResult2 = false
				end
			end
		end
		
		-- if ( !lStopResearch ){
		
		-- if( structureIdle(structure) and structureComplete(structure) ){
		structure = enumStruct()
	end
	-- endwhile
	-- }//(!lStopResearch)
	
	-- =========== perform cheap researches ==============
	boolResult = true
	if not lStopCheapResearch then
		initEnumStruct(false, resLab, player, player)
		structure = enumStruct()
		count = 0
		while structure ~= nil and boolResult do
			if structureIdle(structure) and structureComplete(structure) then
				count = do_CheapResearch(structure, 0)
				-- if ( do_CheapResearch(structure, 0 ) < 0 ){
				-- displayMsg("doResearch: no cheap research to pursue found");
				-- }
				-- execute only once
				boolResult = false
			end
			structure = enumStruct()
		end
	end
end
-- (!lStopCheapResearch)

-- ----------------------------------------------------------------
function difficultyModifier()
	if EnableSliders == true and not isHumanPlayer(player) then
		skDifficultyModifier(player)
	else
		deactivateEvent(difficultyModifier)
	end
end

-- -----------------------------------------------------------------------------
function manageHelpTeam()
	local _dist = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: manageHelpTeam " .. player, player)
	
	if C.gameTime - tProd4 >= 80 then
		tProd4 = C.gameTime
	end
	
	if nAllyBeingHelped == -1 then
		deactivateHelp()
		return
	end
	
	if groupCountMembers(helpGroup) == 0 then
		msg("Player '" .. getPlayerName(player) .. "' has no helping units left, stop helping player '" .. getPlayerName(nAllyBeingHelped) .. "'", player, nAllyBeingHelped)
		deactivateHelp()
	else
		if haveBeacon(nAllyBeingHelped) or nHelpX > -1 then
			if beaconX[nAllyBeingHelped] > -1 then
				nHelpX = beaconX[nAllyBeingHelped]
				nHelpY = beaconY[nAllyBeingHelped]
			end
			_dist = distBetweenTwoPoints(helpGroup.x, helpGroup.y, nHelpX, nHelpY)
			
			-- move to beacon
			if _dist > TILE * 12 then
				if C.gameTime - tHelpAction > 200 then
					orderGroupMoveCMD(helpGroup, nHelpX, nHelpY)
					-- dbg("dbg: player # ("& player &") - moving to beacon ("& nHelpX/TILE &"-"& nHelpY/TILE &")", player);
					tHelpAction = C.gameTime
				end
			else
				if C.gameTime - tHelpAction > 50 then
					orderGroupScoutCMD(helpGroup, nHelpX, nHelpY)
					tHelpAction = C.gameTime
				end
				-- reset help coord, this will force searching of target next time event is called
				if _dist < TILE * 3 and numEnemyWeapObjInRange(player, nHelpX, nHelpY, TILE * 5, false, false) == 0 then
					nHelpX = -1
					nHelpY = -1
				end
			end
		else
			if objTargetHelpTeam == nil then
				if objTargetHelpTeam == nil then
					objTargetHelpTeam = objDroidTargetInRange(helpGroup.x, helpGroup.y, 15 * TILE, false)
				end
				if objTargetHelpTeam == nil then
					objTargetHelpTeam = objStrTargetInRange(helpGroup.x, helpGroup.y, 25 * TILE)
				end
				
				if objTargetHelpTeam ~= nil then
					_dist = distBetweenTwoPoints(helpGroup.x, helpGroup.y, objTargetHelpTeam.x, objTargetHelpTeam.y)
					
					-- move to target
					if _dist > TILE * 12 then
						if C.gameTime - tHelpAction > 200 then
							orderGroupMoveCMD(helpGroup, objTargetHelpTeam.x, objTargetHelpTeam.y)
							msg("manageHelpTeam: player (" .. player .. ") - moving to new target", player, nAllyBeingHelped)
							tHelpAction = C.gameTime
						end
					else
						if C.gameTime - tHelpAction > 50 then
							orderGroupScoutCMD(helpGroup, objTargetHelpTeam.x, objTargetHelpTeam.y)
							-- msg("manageHelpTeam: player ("& player &") - SCOUT to beacon",player, nAllyBeingHelped);
							tHelpAction = C.gameTime
						end
					end
				else
					msg("manageHelpTeam: No enemies in range, no beacon...let`s come back to the base", player, nAllyBeingHelped)
					deactivateHelp()
				end
			else
				if C.gameTime - tHelpAction > 50 then
					orderGroupScoutCMD(helpGroup, objTargetHelpTeam.x, objTargetHelpTeam.y)
					-- msg("manageHelpTeam: player ("& player &") - SCOUT to beacon",player, nAllyBeingHelped);
					tHelpAction = C.gameTime
				end
			end
		end
	end
end



-- ----------------------------------------------------------------
-- check if all units are assigned to a group !!!
function unitAssignationCheck()
	eventCheckTime[21] = C.gameTime
	count = groupCountMembers(toBeRepairedCyborgGroup) + groupCountMembers(cyborgConstructGroup) + groupCountMembers(cyborgAttGroup) + groupCountMembers(cyborgDefGroup) + groupCountMembers(toBeRepairedTankGroup) + groupCountMembers(tankDefGroup) + groupCountMembers(tankGroup) + groupCountMembers(vtolDefendGr) + groupCountMembers(vtolAttGr) + groupCountMembers(repairGroup) + groupCountMembers(buildDefGroup) + groupCountMembers(buildGroup) + groupCountMembers(harvesterGroup) + groupCountMembers(helpGroup)
	if count ~= numDroidsInArea(player, 0, 0, (C.mapWidth * 128), (C.mapHeight * 128)) then
		dbg("dbg->unitAssignationCheck: activating reSortUnits assigned(" .. count .. ") tot(" .. numDroidsInArea(player, 0, 0, (C.mapWidth * 128), (C.mapHeight * 128)) .. ") ", player)
		repeatingEvent(reSortUnits, 3.0)
	end
end
-- ----------------------------------------------------------------
function VTOLmicroManager()
	local _droid = nil
	local _targetVTOL[3] = nil
	local _n = 0
	local _i = 0
	local _nPos = 0
	local _nNumEnDroids = 0
	local _nBestHit = 0
	local _aTmp[60] = nil
	_n = 0
	_i = 0
	_nNumEnDroids = 0
	
	if not alertIsOn or alertX < 0 or alertY < 0 then
		return
	end
	if groupCountMembers(vtolDefendGr) < 1 or targetPlayerVTOL < 0 then
		return
	end
end

-- ----------------------------------------------------------------
function reassignPlayers(_playerLeft)
	playerLeft = _playerLeft -- wz2lua: probably these can be used as function arguments directly
	if playerLeft == player then
		console(getPlayerName(player) .. " is now assigned to DyDo AI as human player has left")
		bRunning = true
		activateAI()
	end
end
callbackEvent(reassignPlayers, CALL_PLAYERLEFT)

-- ----------------------------------------------------------------
-- Check if any threat is in range of Trucks/cybEng order location.
-- The order RTB is given only if the droid distance from order location is
-- greater than 4 TILES. This because AI left the droid complete the
-- building even with threat in range. The droid is called back anyway if
-- it is attacked (see event AIattacked).
function threatCheck()
	local _dist = 0
	local _dist2 = 0
	
	-- buildGroup
	initIterateGroup(buildGroup)
	droid = iterateGroup(buildGroup)
	while droid ~= nil do
		_dist2 = distBetweenTwoPoints(baseX, baseY, droid.x, droid.y)
		_dist = distBetweenTwoPoints(droid.orderx, droid.ordery, droid.x, droid.y)
		if _dist2 > nBaseRange and _dist > 4 * TILE and threatInRange(player, droid.orderx, droid.ordery, THREAT_RANGE_TILES * 128, false) then
			orderDroid(droid, DORDER_RTB)
		end
		droid = iterateGroup(buildGroup)
	end
	
	-- buildDefGroup
	initIterateGroup(buildDefGroup)
	droid = iterateGroup(buildDefGroup)
	while droid ~= nil do
		_dist2 = distBetweenTwoPoints(baseX, baseY, droid.x, droid.y)
		_dist = distBetweenTwoPoints(droid.orderx, droid.ordery, droid.x, droid.y)
		if _dist2 > nBaseRange and _dist > 4 * TILE and threatInRange(player, droid.orderx, droid.ordery, THREAT_RANGE_TILES * 128, false) then
			orderDroid(droid, DORDER_RTB)
		end
		droid = iterateGroup(buildDefGroup)
	end
	
	-- cyborgConstruct
	initIterateGroup(cyborgConstructGroup)
	droid = iterateGroup(cyborgConstructGroup)
	while droid ~= nil do
		_dist2 = distBetweenTwoPoints(baseX, baseY, droid.x, droid.y)
		_dist = distBetweenTwoPoints(droid.orderx, droid.ordery, droid.x, droid.y)
		if _dist2 > nBaseRange and _dist > 4 * TILE and threatInRange(player, droid.orderx, droid.ordery, THREAT_RANGE_TILES * 128, false) then
			orderDroid(droid, DORDER_RTB)
		end
		droid = iterateGroup(cyborgConstructGroup)
	end
end
repeatingEvent(threatCheck, 3.0)

-- ----------------------------------------------------------------
-- structureBuiltInRange
function buildRippleRockets()
	local _nBestDef = 0
	local _numWeapInRange = 0
	local _numWeapInBase = 0
	local _rnd = 0
	
	if not isStructureAvailable(incendrys[3], player) then
		return
	end
	
	_numWeapInBase = numStructinRange(incendrys[3], player, baseX, baseY, nDefendRange)
	
	-- dbg("buildRippleRockets Weap: lMinBaseStructBuilt("& lMinBaseStructBuilt &") _numWeapInBase("& _numWeapInBase &") lStopBuildDef("& lStopBuildDef &") tLastRRBuilt("& tLastRRBuilt &")",player);
	
	if _numWeapInBase >= 2 or (not lMinBaseStructBuilt and C.gameTime < 10 * TIME_MINUTE) then
		return
	end
	if _numWeapInBase > 1 and lStopBuildDef then
		return
	end
	if C.gameTime - tLastRRBuilt < 3 * TIME_MINUTE then
		return
	end
	
	droid = closestDroidCanBuild(buildDefGroup, baseX, baseY)
	if droid == nil then
		droid = closestIdleDroid(buildGroup, baseX, baseY)
	end
	if groupCountMembers(buildGroup) < 2 and groupCountMembers(buildDefGroup) < 2 then
		if droid == nil then
			droid = pickCybEng(true)
		end
	end
	
	-- build AA defenses.
	if droid ~= nil then
		buildX = baseX + (5 * TILE)
		buildY = baseY - (5 * TILE)
		
		if _nBestDef >= 0 then
			boolResult, buildX, buildY = pickStructLocation(incendrys[3], buildX, buildY, player)
			if boolResult and droidCanReach(droid, buildX, buildY) then
				printDebug1("buildRippleRockets: build Ripple Rockets _numWeapInBase(" .. _numWeapInBase .. ")")
				orderDroidStatsLoc(droid, DORDER_BUILD, incendrys[3], buildX, buildY)
				tLastRRBuilt = C.gameTime
			end
		end
	end
end
-- else { displayMsg("buildRippleRockets: No def struc found"); }
-- else { displayMsg("buildRippleRockets: No idle droid found"); }

-- ----------------------------------------------------------------
-- structureBuiltInRange
function buildArtillery()
	local _nBestDef = 0
	local _numWeapInRange = 0
	local _numWeapInBase = 0
	local _rnd = 0
	
	-- find best defense we can build.
	count = 0
	_nBestDef = -1
	while count < numIncendrys do
		if isStructureAvailable(incendrys[count], player) then
			_nBestDef = count
		end
		count = count + 1
	end
	-- no artillery
	if _nBestDef < 0 then
		return
	end
	
	count = 0
	while count < numIncendrys do
		_numWeapInBase = _numWeapInBase + numStructinRange(incendrys[count], player, baseX, baseY, nDefendRange + TILE * 3)
		count = count + 1
	end
	
	-- dbg("buildArtillery Weap: lMinBaseStructBuilt("& lMinBaseStructBuilt &") num weap in base("& _numWeapInBase &") lStopBuildDef("& lStopBuildDef &") tLastArtilleryBuilt("& tLastArtilleryBuilt &")",player);
	
	if _numWeapInBase >= 5 or (not lMinBaseStructBuilt and C.gameTime < 10 * TIME_MINUTE) then
		return
	end
	if _numWeapInBase > 2 and lStopBuildDef then
		return
	end
	-- if ( gameTime - tLastIWbuilt < 1 * TIME_MINUTE ){ exit; }
	
	droid = closestDroidCanBuild(buildDefGroup, baseX, baseY)
	if droid == nil then
		droid = closestIdleDroid(buildGroup, baseX, baseY)
	end
	
	-- build AA defenses.
	if droid ~= nil then
		nArtilleryPos = nArtilleryPos + 1
		if nArtilleryPos > 3 then
			nArtilleryPos = 0
		end
		if nArtilleryPos == 0 then
			buildX = baseX + (5 * TILE)
			buildY = baseY + (5 * TILE)
		end
		if nArtilleryPos == 1 then
			buildX = baseX + (5 * TILE)
			buildY = baseY - (5 * TILE)
		end
		if nArtilleryPos == 2 then
			buildX = baseX - (5 * TILE)
			buildY = baseY + (5 * TILE)
		end
		if nArtilleryPos == 3 then
			buildX = baseX - (5 * TILE)
			buildY = baseY - (5 * TILE)
		end
		
		if _nBestDef >= 0 then
			boolResult, buildX, buildY = pickStructLocation(incendrys[_nBestDef], buildX, buildY, player)
			if boolResult and droidCanReach(droid, buildX, buildY) then
				printDebug1("buildArtillery:  build def [" .. _nBestDef .. "] _numWeapInBase(" .. _numWeapInBase .. ")")
				orderDroidStatsLoc(droid, DORDER_BUILD, incendrys[_nBestDef], buildX, buildY)
				tLastArtilleryBuilt = C.gameTime
			end
		end
	end
end
-- else { displayMsg("buildArtillery: No def struc found"); }
-- else { displayMsg("buildArtillery: No idle droid found"); }

--[[==============================================================================
Functions Section 
==============================================================================]]--
function shutDownThisAI()
	bRunning = false
	deactivateEvent(activateAttack)
	deactivateEvent(AIbrain)
	deactivateEvent(AIcheck)
	deactivateEvent(defFromLongRangeWeap)
	deactivateEvent(beaconEv)
	deactivateEvent(buildAAdef)
	deactivateEvent(buildBase)
	deactivateEvent(buildPowerGenerators)
	deactivateEvent(buildRepFacSuppAttack)
	deactivateEvent(buildRepFirst)
	deactivateEvent(buildVtols)
	deactivateEvent(CyborgAttack)
	deactivateEvent(defendBase)
	deactivateEvent(defendDerrick)
	deactivateEvent(defendGatewaysPoint)
	deactivateEvent(difficultyModifier)
	deactivateEvent(doResearch)
	deactivateEvent(evDebug)
	deactivateEvent(evPrintDebug)
	deactivateEvent(harvesterOperate)
	deactivateEvent(manageDefCyborgs)
	deactivateEvent(manageDefTank)
	deactivateEvent(manageDefVTOL)
	deactivateEvent(manageHelpTeam)
	deactivateEvent(manageIdleTrucks)
	deactivateEvent(manageRepairTeam)
	deactivateEvent(reSortUnits)
	deactivateEvent(SelectCyborgTemplate)
	deactivateEvent(SelectTankTemplate)
	deactivateEvent(sendBackDamagedUnits)
	deactivateEvent(showAImessage)
	deactivateEvent(showPlayerInfo)
	deactivateEvent(shutDownAI)
	deactivateEvent(TankAttack)
	deactivateEvent(truckGroupSlider)
	deactivateEvent(unitAssignationCheck)
	deactivateEvent(unitRepairSwitch)
	deactivateEvent(updateBaseDetails)
	deactivateEvent(upgradeStructures)
	deactivateEvent(useLassat)
	deactivateEvent(vtolEnabler)
	deactivateEvent(vtolStructs)
	deactivateEvent(threatCheck)
	-- events activated via callbacks, not sure if this is required or not.
	deactivateEvent(droidBuilt)
	deactivateEvent(AIattacked)
	deactivateEvent(vtolDefend)
	-- setEventTrigger(consoleEv, inactive);
	deactivateEvent(multiMsgEv)
	deactivateEvent(beaconEv)
	deactivateEvent(reassignPlayers)
	deactivateEvent(VTOLhunter)
	deactivateEvent(buildArtillery)
	deactivateEvent(buildRippleRockets)
end


-- -----------------------------------------------------------------------------
function buildRearmPads()
	if not isStructureAvailable(vtolPad, player) then
		return
	end
	
	buildX = baseX
	buildY = baseY
	
	__result, buildX, buildY = pickStructLocation(vtolPad, buildX, buildY, player)
	if __result then
		droid = closestDroidCanBuild(buildGroup, buildX, buildY)
		if groupCountMembers(buildGroup) < 2 then
			if droid == nil then
				droid = pickCybEng(true)
			end
		end
		if droid ~= nil then
			if droidCanReach(droid, buildX, buildY) then
				orderDroidStatsLoc(droid, DORDER_BUILD, vtolPad, buildX, buildY)
			end
		end
	end
end
-- else { displayMsg("buildRearmPads: no idle buildDroid found"); }
-- else { displayMsg("#### buildRearmPads: cannot pick up a location to build vtolPad"); }
-- -----------------------------------------------------------------------------
function vtolFactoryBuildVtol(_factory)
	local _nRnd = 0
	local _t = 0
	local _nLoop = 0
	local _nTemplAT = 0
	local _nTemplBomb = 0
	local _templateAT = 0
	local _templateBomb = 0
	local _tmplToBuild = nil
	local _bResult = false
	local _bBombVTOL = false
	
	if _factory == nil then
		return
	end
	if not structureIdle(_factory) then
		return
	end
	
	_bResult = false
	_bBombVTOL = false
	
	_t = -1
	_nLoop = 0
	_nTemplAT = 0
	_nTemplBomb = 0
	while _nLoop < numVtolTemplates do
		if _nLoop < 5 then
			if skCanBuildTemplate(player, _factory, vtols[_nLoop]) then
				_nTemplAT = _nTemplAT + 1
				_bResult = true
			end
		else
			if skCanBuildTemplate(player, _factory, vtols[_nLoop]) then
				_nTemplBomb = _nTemplBomb + 1
				_bResult = true
			end
		end
		_nLoop = _nLoop + 1
	end
	
	if not _bResult then
		return
	end
	
	_nRnd = random(100)
	-- Only AT
	if _nTemplBomb == 0 then
		if _nRnd < 70 then
			if skCanBuildTemplate(player, _factory, vtols[0]) then
				_t = 0
			end
			if skCanBuildTemplate(player, _factory, vtols[2]) then
				_t = 2
			end
			if skCanBuildTemplate(player, _factory, vtols[4]) then
				_t = 4
			end
			-- backup
			if _t == -1 then
				if skCanBuildTemplate(player, _factory, vtols[1]) then
					_t = 1
				end
				if skCanBuildTemplate(player, _factory, vtols[3]) then
					_t = 3
				end
			end
		else
			if skCanBuildTemplate(player, _factory, vtols[1]) then
				_t = 1
			end
			if skCanBuildTemplate(player, _factory, vtols[3]) then
				_t = 3
			end
			-- backup
			if _t == -1 then
				if skCanBuildTemplate(player, _factory, vtols[0]) then
					_t = 0
				end
				if skCanBuildTemplate(player, _factory, vtols[2]) then
					_t = 2
				end
				if skCanBuildTemplate(player, _factory, vtols[4]) then
					_t = 4
				end
			end
		end
	else
		if _nRnd < 50 then
			if skCanBuildTemplate(player, _factory, vtols[5]) then
				_t = 5
			end
			if skCanBuildTemplate(player, _factory, vtols[6]) then
				_t = 6
			end
			if skCanBuildTemplate(player, _factory, vtols[7]) then
				_t = 7
			end
			if skCanBuildTemplate(player, _factory, vtols[8]) then
				_t = 8
			end
		else
			_nRnd = random(100)
			-- Lancer - Scourge
			if _nRnd < 70 then
				if skCanBuildTemplate(player, _factory, vtols[0]) then
					_t = 0
				end
				if skCanBuildTemplate(player, _factory, vtols[2]) then
					_t = 2
				end
				if skCanBuildTemplate(player, _factory, vtols[4]) then
					_t = 4
				end
				-- backup
				if _t == -1 then
					if skCanBuildTemplate(player, _factory, vtols[1]) then
						_t = 1
					end
					if skCanBuildTemplate(player, _factory, vtols[3]) then
						_t = 3
					end
				end
			else
				if skCanBuildTemplate(player, _factory, vtols[1]) then
					_t = 1
				end
				if skCanBuildTemplate(player, _factory, vtols[3]) then
					_t = 3
				end
				-- backup
				if _t == -1 then
					if skCanBuildTemplate(player, _factory, vtols[0]) then
						_t = 0
					end
					if skCanBuildTemplate(player, _factory, vtols[2]) then
						_t = 2
					end
					if skCanBuildTemplate(player, _factory, vtols[4]) then
						_t = 4
					end
				end
			end
		end
	end
	
	
	if _t == -1 then
		return
	end
	
	if skCanBuildTemplate(player, _factory, vtols[_t]) then
		displayMsg("vtolFactoryBuildVtol: build VTOL _t(" .. _t .. "), _bBombVTOL(" .. _bBombVTOL .. ") _nTemplBomb(" .. _nTemplBomb .. ") _nTemplAT(" .. _nTemplAT .. ")_nRnd(" .. _nRnd .. ") lancer(" .. researchFinished(lancerATweap, player) .. ") scorpion(" .. researchFinished(scorpionBody, player) .. ")")
		buildDroid(vtols[_t], _factory, player, 1)
	end
end
-- else {
-- dbg("vtolFactoryBuildVtol: CANNOT build VTOL; lancer("& researchFinished(lancerATweap,player) &") scorpion("& researchFinished(scorpionBody,player) &") _t("& _t &"), _bBombVTOL("& _bBombVTOL &") _nTemplBomb("& _nTemplBomb &") _nTemplAT("& _nTemplAT &")_nRnd("& _nRnd &") ",player);
-- }

-- -----------------------------------------------------------------------------
function deactivateTankAttack()
	tTanksSentToGathering = 0
	tTankAttackAction = 0
	bTankAttIsOn = false
	lTankSentToGatheringPoint = false
	bTankAlreadyGathered = false
	nTankGatheringX = -1
	nTankGatheringY = -1
	tankAttackX = -1
	tankAttackY = -1
	targetPlayerTank = -1
	attackTankObj = nil
	bAttackTeamAttacked = false
	deactivateEvent(TankAttack)
end
-- -----------------------------------------------------------------------------
function deactivateCybAttack()
	bCybAttIsOn = false
	lCybSentToGatheringPoint = false
	bCybAlreadyGathered = false
	cybAttackX = -1
	cybAttackY = -1
	nCybGatheringX = -1
	nCybGatheringY = -1
	targetPlayerCyb = -1
	tCybSentToGathering = 0
	tCybAttackAction = 0
	bAttackTeamAttacked = false
	deactivateEvent(CyborgAttack)
end
-- -----------------------------------------------------------------------------
function harvestNearOilRes()
	local _oilRes = nil
	local _bestOilRes = nil
	local _player = 0
	local _tempDist = 0
	local _bestDist = 0
	local _hq = nil
	local _okToProceed = false
	
	_oilRes = nil
	_bestOilRes = nil
	_okToProceed = true
	_bestDist = 9999 * TILE
	
	-- needed for droidCanReach
	droid = pickCybEng(true)
	if droid ~= nil then
		initGetFeature(oilRes, player, player)
		_oilRes = getFeature(player)
		
		while _oilRes ~= nil do
			if droidCanReach(droid, _oilRes.x, _oilRes.y) then
				_okToProceed = true
				_player = 0
				while _player < MAX_PLAYERS do
					if friendlyPlayer(_player) and (_player ~= player) then
						_hq = getStructure(playerHQ, _player)
						if _hq ~= nil then
							if distBetweenTwoPoints(_oilRes.x, _oilRes.y, _hq.x, _hq.y) < 15 * TILE then
								_okToProceed = false
							end
						end
					end
					
					_player = _player + 1
				end
				-- endwhile
				
				-- Check this oilRes is not too far away, trucks will harvest anyway
				count = ((C.mapWidth + C.mapHeight) / 2) * TILE
				-- half map
				count = (count / 2)
				count2 = distBetweenTwoPoints(_oilRes.x, _oilRes.y, baseX, baseY)
				if count2 > count then
					_okToProceed = false
				end
				-- displayMsg("harvestNearOilRes: oilRes is too far away ("& count2/TILE &" / "& count/TILE &") ");
				
				-- check for threats in range
				if threatInRange(player, _oilRes.x, _oilRes.y, THREAT_RANGE_TILES_SHORT * 128, false) then
					_okToProceed = false
				end
				
				if _okToProceed then
					_tempDist = distBetweenTwoPoints(_oilRes.x, _oilRes.y, droid.x, droid.y)
					if _tempDist < _bestDist then
						_bestOilRes = _oilRes
						_bestDist = _tempDist
					end
				end
			end
			
			-- endif droidCanReach
			
			_oilRes = getFeature(player)
		end
	end
	-- while
	
	if _bestOilRes ~= nil then
		droid = closestIdleDroid(cyborgConstructGroup, _bestOilRes.x, _bestOilRes.y)
		if nMyDerricks < numMaxDerricks then
			orderDroidStatsLoc(droid, DORDER_BUILD, derrick, _bestOilRes.x, _bestOilRes.y)
		end
	end
	-- displayMsg("*** manageIdleTrucks: Cybdroid (" & droid.id & ")  build DERRICK (" & _bestOilRes.id  & ") coord (" & _bestOilRes.x/TILE  & "-" & _bestOilRes.y/TILE  & ")" );
	
	return
end
-- -----------------------------------------------------------------------------
function pickCybEng(_idleOne)
	local _Truck = nil
	local _tempTruck = nil
	_Truck = nil
	initIterateGroup(cyborgConstructGroup)
	_tempTruck = iterateGroup(cyborgConstructGroup)
	while _tempTruck ~= nil and _Truck == nil do
		if _idleOne then
			if droidOrderIdle(_tempTruck) then
				_Truck = _tempTruck
			end
		else
			_Truck = _tempTruck
		end
		_tempTruck = iterateGroup(cyborgConstructGroup)
	end
	-- end while
	
	return _Truck
end

-- -----------------------------------------------------------------------------
function getOilResTargetFree()
	local _i = 0
	_i = 0
	while _i < 11 do
		if oilResTargetId[_i] == -1 then
			return _i
		end
		_i = _i + 1
	end
	return -1
end

-- -----------------------------------------------------------------------------
function checkDerrickIsBuilt(_player)
	local _structure = nil
	local _tempOilRes = nil
	local _i = 0
	local _cc = 0
	local _el = 0
	
	-- if no oliRes left then reset the array!
	initGetFeature(oilRes, -1, player)
	_tempOilRes = getFeature(player)
	_i = 0
	while _tempOilRes ~= nil and _i < MAX_WHILE_LOOPS do
		_i = _i + 1
		_tempOilRes = getFeature(player)
	end
	
	if _i == 0 then
		_cc = 0
		while _cc < 11 do
			oilResTargetId[_cc] = -1
			oilResTargetX[_cc] = -1
			oilResTargetY[_cc] = -1
			_cc = _cc + 1
		end
	end
	
	_el = 0
	initEnumStruct(false, derrick, _player, _player)
	_structure = enumStruct()
	-- displayMsg("checkDerrickIsBuilt player (" & _player & ")" ); /* -------DEBUG MESSAGE -------------- */
	while _structure ~= nil do
		while _el < 11 do
			if (_structure.x == oilResTargetX[_el]) and (_structure.y == oilResTargetY[_el]) and (structureComplete(_structure)) then
				oilResTargetId[_el] = -1
				oilResTargetX[_el] = -1
				oilResTargetY[_el] = -1
			end
			-- else { if (  _structure.x == oilResTargetX[_el]  and  _structure.y == oilResTargetY[_el]  ){displayMsg("checkDerrickIsBuilt: derrick (" & _structure.id & ") being built" ); }}
			_el = _el + 1
		end
		_el = 0
		_structure = enumStruct()
	end
end
-- -----------------------------------------------------------------------------
function stopDroidHarvesting()
	local _player = 0
	local _dist = 0
	local _dist2 = 0
	local _c2 = 0
	
	_player = 0
	
	if groupCountMembers(harvesterGroup) == 0 and groupCountMembers(cyborgConstructGroup) == 0 then
		return
	end
	
	while _player < MAX_PLAYERS do
		initEnumStruct(false, derrick, _player, _player)
		structure = enumStruct()
		_c2 = 0
		while structure ~= nil and _c2 < MAX_WHILE_LOOPS do
			initIterateGroup(harvesterGroup)
			droid = iterateGroup(harvesterGroup)
			while droid ~= nil do
				if droid.orderx == structure.x and droid.ordery == structure.y then
					_dist = distBetweenTwoPoints(structure.x, structure.y, droid.x, droid.y)
					if _dist > 3 * TILE then
						if bOilResLeft then
							orderDroid(droid, DORDER_STOP)
						else
							if _dist < 20 * TILE and not threatInRange(player, structure.x, structure.y, THREAT_RANGE_TILES * 128, false) then
								boolResult = buildDefStruct(droid, structure.x, structure.y)
								-- cannot reach location!
								if not boolResult then
									orderDroid(droid, DORDER_RTB)
								end
							else
								orderDroid(droid, DORDER_RTB)
							end
						end
					end
				end
				droid = iterateGroup(harvesterGroup)
			end
			-- check cyborg engineers
			initIterateGroup(cyborgConstructGroup)
			droid = iterateGroup(cyborgConstructGroup)
			while droid ~= nil do
				if droid.orderx == structure.x and droid.ordery == structure.y then
					_dist = distBetweenTwoPoints(structure.x, structure.y, droid.x, droid.y)
					if _dist > 3 * TILE then
						if bOilResLeft then
							orderDroid(droid, DORDER_STOP)
						else
							if _dist < 15 * TILE and not threatInRange(player, structure.x, structure.y, THREAT_RANGE_TILES * 128, false) then
								boolResult = buildDefStruct(droid, structure.x, structure.y)
								if not boolResult then
									orderDroid(droid, DORDER_RTB)
								end
							else
								orderDroid(droid, DORDER_RTB)
							end
						end
					end
				end
				droid = iterateGroup(cyborgConstructGroup)
			end
			
			structure = enumStruct()
			_c2 = _c2 + 1
		end
		_player = _player + 1
	end
	
	-- check if any threat is in range
	initIterateGroup(harvesterGroup)
	droid = iterateGroup(harvesterGroup)
	while droid ~= nil do
		_dist = distBetweenTwoPoints(droid.orderx, droid.ordery, droid.x, droid.y)
		if _dist > 4 * TILE and threatInRange(player, droid.orderx, droid.ordery, THREAT_RANGE_TILES * 128, false) then
			orderDroid(droid, DORDER_RTB)
		end
		droid = iterateGroup(harvesterGroup)
	end
	
	initIterateGroup(cyborgConstructGroup)
	droid = iterateGroup(cyborgConstructGroup)
	while droid ~= nil do
		_dist2 = distBetweenTwoPoints(baseX, baseY, droid.x, droid.y)
		_dist = distBetweenTwoPoints(droid.orderx, droid.ordery, droid.x, droid.y)
		if _dist2 > nBaseRange and _dist > 4 * TILE and threatInRange(player, droid.orderx, droid.ordery, THREAT_RANGE_TILES * 128, false) then
			orderDroid(droid, DORDER_RTB)
		end
		droid = iterateGroup(cyborgConstructGroup)
	end
	
	return
end
-- -----------------------------------------------------------------------------
function buildDefStruct(_droid, _x, _y)
	local _t = 0
	_t = math.max(pickDefQueueDepth - 1 - _random(3), 0)
	if isStructureAvailable(pickDefQueue[_t], player) then
		buildX = _x
		buildY = _y
		__result, buildX, buildY = pickStructLocation(pickDefQueue[_t], buildX, buildY, player)
		if __result then
			if droidCanReach(_droid, buildX, buildY) then
				orderDroidStatsLoc(_droid, DORDER_BUILD, pickDefQueue[_t], buildX, buildY)
				-- displayMsg("buildDefStruct: droid ("& _droid.id &") build def ["& _t &"] best is ["& pickDefQueueDepth &"] " );
				return true
			end
		end
	end
	return false
end

-- -----------------------------------------------------------------------------
function getWeaponUnitsInfo(_player, _choice)
	if _choice == WUI_TOTUNITS then
		return aStat[OC_CYBORGS][_player] + aStat[OC_TANKS][_player]
	end
	if _choice == WUI_POWER then
		return aStat[OC_CYB_POWER][_player] + aStat[OC_TK_POWER][_player]
	end
	if _choice == WUI_HP then
		return aStat[OC_CYB_HP][_player] + aStat[OC_TK_HP][_player]
	end
	return -1
end
-- -----------------------------------------------------------------------------
function getPowerIndex(_player)
	local _powUpgrades[7] = nil
	local _powUpgrPerc[7] = 0
	local _nArr = 0
	local _index = 0
	local _nLastRes = 0
	local _nDerricks = 0
	local _powIndRet = 0
	_nArr = 7
	
	_powUpgrades[0] = powUpgrades0
	_powUpgrades[1] = powUpgrades1
	_powUpgrades[2] = powUpgrades2
	_powUpgrades[3] = powUpgrades3
	_powUpgrades[4] = powUpgrades4
	_powUpgrades[5] = powUpgrades5
	_powUpgrades[6] = powUpgrades6
	
	_powUpgrPerc[0] = 125
	_powUpgrPerc[1] = 150
	_powUpgrPerc[2] = 175
	_powUpgrPerc[3] = 200
	_powUpgrPerc[4] = 230
	_powUpgrPerc[5] = 260
	_powUpgrPerc[6] = 290
	
	_nLastRes = -1
	_index = 0
	while _index < _nArr do
		if researchFinished(_powUpgrades[_index], _player) then
			_nLastRes = _index
		end
		-- else {  displayMsg("getPowerIndex: NO _player("& _player &") _index("& _index &") completed("& researchFinished( _powUpgrades[_index],_player) &")" );}
		_index = _index + 1
	end
	_nDerricks = getNumDerricks(_player)
	
	if _nLastRes ~= -1 then
		_powIndRet = _nDerricks * _powUpgrPerc[_nLastRes] / 100
		-- displayMsg("dbg -> getPowerIndex: YES _player ("& _player &") derricks("& _nDerricks &") powIndex("& _powIndRet &")" );
		return _powIndRet
	end
	-- else { displayMsg("dbg -> getPowerIndex: NO _player ("& _player &") _nLastRes("& _nLastRes &") " );}
	
	return _nDerricks
end
-- researchFinished(res,pl)

-- -----------------------------------------------------------------------------
function getNumDerricks(_player)
	local _count = 0
	local _structure = nil
	_count = 0
	initEnumStruct(false, derrick, _player, _player)
	_structure = enumStruct()
	while _structure ~= nil do
		_count = _count + 1
		_structure = enumStruct()
	end
	return _count
end

-- -----------------------------------------------------------------------------
-- show a debug message, ca be activated/deactivated
function displayMsg(_message)
	if isHumanPlayer(player) then
		dbg(_message, player)
	end
end
-- -----------------------------------------------------------------------------
-- show a debug message -> reports error
function dropBeaconToAllies(_message, _x, _y, _z, _bToHuman)
	local _toPlayer = 0
	_toPlayer = 0
	
	-- avoid too many blips...
	if _message ~= "help" then
		if (C.gameTime - tBeaconSent) < 2 * TIME_MINUTE then
			return
		end
	else
		if (C.gameTime - tBeaconSent) < 1 * TIME_MINUTE then
			return
		end
	end
	
	while _toPlayer < MAX_PLAYERS do
		if friendlyPlayer(_toPlayer) then
			if _bToHuman then
				if isHumanPlayer(_toPlayer) then
					dropBeacon(_message, _toPlayer, player, _x, _y, _z)
					msg(_message, player, _toPlayer)
				end
			else
				if not isHumanPlayer(_toPlayer) then
					dropBeacon("a", _toPlayer, player, _x, _y, _z)
					msg(_message, player, _toPlayer)
				end
			end
		end
		_toPlayer = _toPlayer + 1
	end
	tBeaconSent = C.gameTime
	return
end


-- -----------------------------------------------------------------------------
-- show a debug message -> reports error
function sendMsgToAllAllies(_message)
	local _c = 0
	_c = 0
	while _c < MAX_PLAYERS do
		if friendlyPlayer(_c) then
			msg(_message, player, _c)
		end
		_c = _c + 1
	end
end
-- -----------------------------------------------------------------------------
-- show a debug message -> reports error
function displayErrMsg(_message)
	local _c = 0
	_c = 0
	while _c < MAX_PLAYERS do
		if isHumanPlayer(_c) then
			dbg(_message, _c)
		end
		_c = _c + 1
	end
end
-- -----------------------------------------------------------------------------
-- Return an AA defence as target for
-- VTOL: _nDefInRange*3 < vtolDefendGr.members
-- DROID: _nDefInRange < 1
function getAAStruct(_bVTOLTarget)
	local _n = 0
	local _bestDist = 0
	local _tempDist = 0
	local _targetPl = 0
	local _dist = 0
	local _numPl = 0
	local _nDefInRange = 0
	local _bestAAdef = nil
	local _tempAAdef = nil
	local _BaseStruct = nil
	local _struct = nil
	
	_bestDist = 999 * TILE
	_bestAAdef = nil
	-- avoid to start always from player 0
	_numPl = 0
	-- avoid to start always from player 0
	_targetPl = random(MAX_PLAYERS)
	
	while _numPl < MAX_PLAYERS do
		if not friendlyPlayer(_targetPl) and isPlayerStillLive(_targetPl) then
			_dist = 0
			_struct = getStructure(playerHQ, _targetPl)
			if _struct == nil then
				_struct = getStructure(factory, _targetPl)
			end
			if _struct == nil then
				_struct = getStructure(resLab, _targetPl)
			end
			if _struct == nil then
				_struct = getStructure(cybFactory, _targetPl)
			end
			
			if _struct ~= nil then
				_n = 0
				while _n < numGenAA do
					if AIstrength < 4 then
						initEnumStruct(false, vtolGenStruct[_n], _targetPl, player)
					else
						initEnumStruct(false, vtolGenStruct[_n], _targetPl, _targetPl)
					end
					_tempAAdef = enumStruct()
					while _tempAAdef ~= nil and _struct ~= nil do
						_tempDist = distBetweenTwoPoints(_tempAAdef.x, _tempAAdef.y, baseX, baseY)
						_dist = distBetweenTwoPoints(_struct.x, _struct.y, _tempAAdef.x, _tempAAdef.y)
						
						if _bVTOLTarget then
							_nDefInRange = numEnemyAAInRange(_tempAAdef.x, _tempAAdef.y, AA_THREAT_RANGE())
							if _tempDist < _bestDist and _dist > 20 * TILE and _nDefInRange * 3 < groupCountMembers(vtolDefendGr) then
								_bestAAdef = _tempAAdef
								_bestDist = _tempDist
							end
						else
							_nDefInRange = numEnemyWeapStructsInRange(player, _tempAAdef.x, _tempAAdef.y, COMBAT_RANGE(), false)
							if _tempDist < _bestDist and _dist > 20 * TILE and _nDefInRange < 1 then
								_bestAAdef = _tempAAdef
								_bestDist = _tempDist
							end
						end
						
						_tempAAdef = enumStruct()
					end
					-- while
					
					_n = _n + 1
				end
			end
		end
		-- while
		
		
		-- struct
		
		_targetPl = _targetPl + 1
		if _targetPl > 7 then
			_targetPl = 0
		end
		_numPl = _numPl + 1
	end
	-- endwhile players
	
	return _bestAAdef
end
-- -----------------------------------------------------------------------------
-- Return a derrick as target for
-- VTOL: _nDefInRange*3 < vtolDefendGr.members
-- DROID: _nDefInRange < 1
function undefendedEnemyDerrick(_bVTOLTarget)
	local _bestDist = 0
	local _tempDist = 0
	local _targetPl = 0
	local _dist = 0
	local _numPl = 0
	local _nDefInRange = 0
	local _derrick = nil
	local _tempDerrick = nil
	local _BaseStruct = nil
	local _struct = nil
	
	_bestDist = 999 * TILE
	_derrick = nil
	-- avoid to start always from player 0
	_numPl = 0
	-- avoid to start always from player 0
	_targetPl = random(MAX_PLAYERS)
	
	while _numPl < MAX_PLAYERS do
		if not friendlyPlayer(_targetPl) and isPlayerStillLive(_targetPl) then
			_dist = 0
			_struct = getStructure(playerHQ, _targetPl)
			if _struct == nil then
				_struct = getStructure(factory, _targetPl)
			end
			if _struct == nil then
				_struct = getStructure(resLab, _targetPl)
			end
			if _struct == nil then
				_struct = getStructure(cybFactory, _targetPl)
			end
			
			if _struct ~= nil then
				if AIstrength < 4 then
					initEnumStruct(false, derrick, _targetPl, player)
				else
					initEnumStruct(false, derrick, _targetPl, _targetPl)
				end
				_tempDerrick = enumStruct()
				while _tempDerrick ~= nil and _struct ~= nil do
					_tempDist = distBetweenTwoPoints(_tempDerrick.x, _tempDerrick.y, baseX, baseY)
					_dist = distBetweenTwoPoints(_struct.x, _struct.y, _tempDerrick.x, _tempDerrick.y)
					
					if _bVTOLTarget then
						_nDefInRange = numEnemyAAInRange(_tempDerrick.x, _tempDerrick.y, AA_THREAT_RANGE())
						if _tempDist < _bestDist and _dist > 20 * TILE and _nDefInRange * 3 < groupCountMembers(vtolDefendGr) then
							_derrick = _tempDerrick
							_bestDist = _tempDist
						end
					else
						_nDefInRange = numEnemyWeapStructsInRange(player, _tempDerrick.x, _tempDerrick.y, COMBAT_RANGE(), false)
						if _tempDist < _bestDist and _dist > 20 * TILE and _nDefInRange < 1 then
							_derrick = _tempDerrick
							_bestDist = _tempDist
						end
					end
					
					_tempDerrick = enumStruct()
				end
			end
		end
		-- while
		-- struct
		
		_targetPl = _targetPl + 1
		if _targetPl > 7 then
			_targetPl = 0
		end
		_numPl = _numPl + 1
	end
	-- endwhile players
	
	return _derrick
end
-- -----------------------------------------------------------------------------
function closestEnemyDerrick(_mustBeHuman, _targetPlayer)
	local _bestDist = 0
	local _tempDist = 0
	local _targetPl = 0
	local _dist = 0
	local _xCoord = 0
	local _yCoord = 0
	local _derrick = nil
	local _tempDerrick = nil
	local _BaseStruct = nil
	local _struct = nil
	
	_bestDist = 999 * TILE
	_derrick = nil
	-- avoid to start always from player 0
	_targetPl = 0
	
	while _targetPl < MAX_PLAYERS do
		boolResult = true
		if _mustBeHuman and not isHumanPlayer(_targetPl) then
			boolResult = false
		end
		-- a target player is required?
		if _targetPlayer >= 0 and _targetPlayer ~= _targetPl then
			boolResult = false
		end
		
		if not friendlyPlayer(_targetPl) and boolResult then
			_dist = 0
			_xCoord = getEnemy_baseCoord(_targetPl, "X")
			_yCoord = getEnemy_baseCoord(_targetPl, "Y")
			
			if _xCoord > 0 and _yCoord > 0 then
				initEnumStruct(false, derrick, _targetPl, player)
				_tempDerrick = enumStruct()
				while _tempDerrick ~= nil and _struct ~= nil do
					_tempDist = distBetweenTwoPoints(_tempDerrick.x, _tempDerrick.y, baseX, baseY)
					_dist = distBetweenTwoPoints(_xCoord, _yCoord, _tempDerrick.x, _tempDerrick.y)
					
					-- displayMsg("closestEnemyDerrick: _targetPl("& _targetPl &") _tempDist("& _tempDist/TILE &")  _dist("& _dist/TILE &")  _tempDerrick("& _tempDerrick.id &") derrick x-y("& _tempDerrick.x/TILE &"-"& _tempDerrick.y/TILE &")");
					if _tempDist < _bestDist and _dist > 20 * TILE then
						_derrick = _tempDerrick
						_bestDist = _tempDist
					end
					_tempDerrick = enumStruct()
				end
			end
		end
		-- while
		
		_targetPl = _targetPl + 1
	end
	-- endwhile players
	
	return _derrick
end

-- -----------------------------------------------------------------------------
--[[Used to pick up the most appropriate Derrick to defend.
 It also check that the Derrick has already enough defences or not.]]--
function closestDerrickToDefend()
	local _bestDist = 0
	local _derrickDist = 0
	local _derrick = nil
	local _tempDerrick = nil
	local _OK1 = false
	local _OK2 = false
	
	_bestDist = 999 * TILE
	_derrick = nil
	
	initEnumStruct(false, derrick, player, player)
	_tempDerrick = enumStruct()
	
	if not isStructureAvailable(pickDefQueue[pickDefQueueDepth], player) then
		return _derrick
	end
	while _tempDerrick ~= nil do
		_OK1 = false
		_OK2 = false
		_derrickDist = distBetweenTwoPoints(_tempDerrick.x, _tempDerrick.y, baseX, baseY)
		if _derrickDist > math.max(nBaseRange, 15 * TILE) then
			if numFriendlyWeapStructsInRange(player, _tempDerrick.x, _tempDerrick.y, TILE * 5, false) < MAX_DEFSTR_DERRICKS then
				if _derrickDist < _bestDist then
					_OK1 = true
				end
			end
			-- displayMsg("closestDerrickToDefend: ("& _tempDerrick.id &") distance ("& _OK1 &")("& _OK2 &") !!");
			-- else { displayMsg("closestDerrickToDefend: derrick ("& _tempDerrick.id &") already with defences in DERRICK AREA" );   }
			
			-- now check the building area
			buildX = _tempDerrick.x
			buildY = _tempDerrick.y
			boolResult, buildX, buildY = pickStructLocation(pickDefQueue[pickDefQueueDepth], buildX, buildY, player)
			if boolResult then
				if numFriendlyWeapStructsInRange(player, buildX, buildY, TILE * 6, false) < MAX_DEFSTR_DERRICKS then
					_OK2 = true
				end
			end
			-- else { displayMsg("closestDerrickToDefend: derrick ("& _tempDerrick.id &") already with defences in BUILD AREA" );   }
			-- else { displayMsg("closestDerrickToDefend: cannor build a def struct around ("& _tempDerrick.id &") " );   }
			
			if _OK1 and _OK2 then
				_derrick = _tempDerrick
				_bestDist = _derrickDist
			end
		end
		
		-- else { //displayMsg("closestDerrickToDefend: derrick ("& _tempDerrick.id &") is in the base" );  }
		_tempDerrick = enumStruct()
	end
	-- endwhile
	return _derrick
end
-- -----------------------------------------------------------------------------
-- Pick up the closest oilRes at given coord and check that oliRes is not already
-- a "target" of another droid
function closestOilRes(_droid, _x, _y)
	local _bestDist = 0
	local _tempDist = 0
	local _nOilResFound = 0
	local _i = 0
	local _ii = 0
	local _player = 0
	local _closestOilRes = nil
	local _tempOilRes = nil
	local _okToProceed = false
	local _hq = nil
	
	_bestDist = 999 * TILE
	_closestOilRes = nil
	_okToProceed = true
	_nOilResFound = 0
	
	_player = 0
	while _player < MAX_PLAYERS do
		initGetFeature(oilRes, -1, player)
		_tempOilRes = getFeature(player)
		_ii = 0
		while _tempOilRes ~= nil and _ii < MAX_WHILE_LOOPS do
			if _droid ~= nil then
				if not droidCanReach(_droid, _tempOilRes.x, _tempOilRes.y) then
					_okToProceed = false
				end
			else
				_okToProceed = false
			end
			-- displayMsg("OilRes ("& _tempOilRes.id &") @("& _tempOilRes.x/TILE &")("& _tempOilRes.y/TILE &") can be reached ("& _okToProceed &") by droid ("& _droid.id &")");
			
			-- check that this OilRes is not already a "target" of a droid
			if C.gameTime < TIME_HARVESTING_PHASE then
				_i = 0
				while _i < 11 do
					if _tempOilRes.id == oilResTargetId[_i] then
						_okToProceed = false
					end
					_i = _i + 1
				end
			end
			
			-- check oilRes is not in range of an Ally base, leave this oilRes to the Ally
			-- OK
			if _okToProceed and (_player ~= player) and allianceExistsBetween(_player, player) then
				_hq = getStructure(playerHQ, _player)
				if _hq ~= nil then
					if distBetweenTwoPoints(_tempOilRes.x, _tempOilRes.y, _hq.x, _hq.y) < 15 * TILE then
						_okToProceed = false
					end
				end
			end
			
			-- check for threats in range
			if C.gameTime > TIME_HARVESTING_PHASE then
				if threatInRange(player, _tempOilRes.x, _tempOilRes.y, THREAT_RANGE_TILES_LONG * 128, false) then
					_okToProceed = false
				end
			else
				if threatInRange(player, _tempOilRes.x, _tempOilRes.y, THREAT_RANGE_TILES_SHORT * 128, false) then
					_okToProceed = false
				end
			end
			
			if _okToProceed then
				_tempDist = distBetweenTwoPoints(_tempOilRes.x, _tempOilRes.y, _x, _y)
				-- displayMsg("Closest Oil Res: oilRes ("& _tempOilRes.id &") dist / best ("& _tempDist/TILE &" / "& _bestDist/TILE &") ("& _tempOilRes.x/TILE &"-"& _tempOilRes.y/TILE &")");
				if _tempDist < _bestDist then
					_closestOilRes = _tempOilRes
					_bestDist = _tempDist
				end
			end
			-- else { displayMsg("Closest Oil Res: player ("& player &") cannot proceed for oilRes ("& _tempOilRes.id &") dist ("& distBetweenTwoPoints(_tempOilRes.x, _tempOilRes.y, _x, _y)/TILE &") ("& _tempOilRes.x/TILE &"-"& _tempOilRes.y/TILE &")");  }
			_tempOilRes = getFeature(player)
			_nOilResFound = _nOilResFound + 1
			_okToProceed = true
			_ii = _ii + 1
		end
		_player = _player + 1
	end
	
	return _closestOilRes
end

-- -----------------------------------------------------------------------------
function getADroid(_theGRP)
	local _tempTruck = nil
	local _returnTruck = nil
	
	_returnTruck = nil
	
	initIterateGroup(_theGRP)
	_tempTruck = iterateGroup(_theGRP)
	while _tempTruck ~= nil do
		_returnTruck = _tempTruck
		_tempTruck = iterateGroup(_theGRP)
	end
	
	return _returnTruck
end
-- -----------------------------------------------------------------------------
function droidOrderIdle(_droid)
	if _droid.order == DORDER_RTB then
		return true
	end
	
	if _droid.order == DORDER_STOP then
		return true
	end
	
	if _droid.order == DORDER_NONE then
		return true
	end
	
	if _droid.order == DORDER_GUARD then
		return true
	end
	
	return false
end
-- -----------------------------------------------------------------------------
function debugCentreView(_droid)
	local _player = 0
	_player = 0
	if debugCenterView == true then
		while _player < 8 do
			if isHumanPlayer(_player) and allianceExistsBetween(_player, player) then
				centreView(_droid)
			end
			_player = _player + 1
		end
	end
end

-- -----------------------------------------------------------------------------
function pickDefTruck(_idleOne)
	local _tempTruck = nil
	local _Truck = nil
	
	_Truck = nil
	
	initIterateGroup(buildDefGroup)
	_tempTruck = iterateGroup(buildDefGroup)
	-- let`s try with really idle one
	while _tempTruck ~= nil and _Truck == nil do
		if droidOrderIdle(_tempTruck) then
			_Truck = _tempTruck
		end
		if not _idleOne and _Truck == nil then
			if _tempTruck.order == DORDER_HELPBUILD or _tempTruck.order == DORDER_REPAIR then
				_Truck = _tempTruck
			end
		end
		_tempTruck = iterateGroup(buildDefGroup)
	end
	
	
	return _Truck
end
-- -----------------------------------------------------------------------------
-- use numFriendlyWeapStructsInRange(player, _struct.x, _struct.y, COMBAT_RANGE, onlycompletedStruct);
function buildGatewayDef(_defTruck, _pos)
	local _x = 0
	local _y = 0
	local _nDefBuilt = 0
	local _tmpl = 0
	local _n = 0
	
	if _defTruck == nil then
		return
	end
	
	-- dbg("dbg->buildGatewayDef(): START numDefStrAtGateway("& numDefStrAtGateway &")  _x/_y("& _x &"-"& _y &")",player);
	if pickWallDefQueueDepth <= 0 and pickDefQueueDepth <= 0 then
		return
	end
	
	_x = aGatewayPosX[_pos]
	_y = aGatewayPosY[_pos]
	if pickWallDefQueueDepth > 0 then
		_n = math.min(pickWallDefQueueDepth, 3)
		_tmpl = pickWallDefQueueDepth - 1 - _random(_n)
		if isStructureAvailable(pickWallDefQueue[_tmpl], player) then
			UNUSED, _x, _y = skDefenseLocationB(_x, _y, wall, pickWallDefQueue[_tmpl], _defTruck, player)
			-- dbg("dbg->buildGatewayDef(): droid ("& _defTruck.id &") build WALL def ["& _tmpl &"], best is ["& pickWallDefQueueDepth &"] - at("& _x/TILE &"-"& _y/TILE &")",player);
			printDebug1("buildGatewayDef():  build WALL def [" .. _tmpl .. "], best is [" .. pickWallDefQueueDepth .. "] - at(" .. _x / TILE .. "-" .. _y / TILE .. ")")
		end
	end
end

-- -----------------------------------------------------------------------------
-- _x and _y are changed per reference
function getSafeBuildCoord(_droid, _struct, _x, _y, _choice)
	local _x1 = 0
	local _y1 = 0
	local _c1 = 0
	local _c2 = 0
	local _c3 = 0
	local _aX[8] = 0
	local _aY[8] = 0
	local _aD[8] = 0
	
	_c3 = 0
	while _c3 < 8 do
		_aX[_c3] = -1
		_aY[_c3] = -1
		_aD[_c3] = -1
		_c3 = _c3 + 1
	end
	
	boolResult, _x, _y = pickStructLocation(_struct, _x, _y, player)
	boolResult2 = droidCanReach(_droid, _x, _y)
	if boolResult and boolResult2 then
		if _choice == 0 then
			return _x
		end
		if _choice == 1 then
			return _y
		end
	end
	
	_x1 = _x
	_y1 = _y
	_c3 = 1
	_c2 = 0
	while _c3 < 3 do
		_x = _x1 + _c3 * TILE
		_y = _y1 + _c3 * TILE
		boolResult, _x, _y = pickStructLocation(_struct, _x, _y, player)
		boolResult2 = droidCanReach(_droid, _x, _y)
		-- dbg("dbg->getSafeBuildCoord: try  x-y("& _x/TILE &"-"& _y/TILE &") from ("& _x1/TILE &"-"& _y1/TILE &")",player);
		if boolResult and boolResult2 then
			_aX[_c2] = _x
			_aY[_c2] = _y
			_aD[_c2] = distBetweenTwoPoints(_x, _y, _x1, _y1)
			-- dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
			_c2 = _c2 + 1
		end
		
		_x = _x1 - _c3 * TILE
		_y = _y1 - _c3 * TILE
		boolResult, _x, _y = pickStructLocation(_struct, _x, _y, player)
		boolResult2 = droidCanReach(_droid, _x, _y)
		if boolResult and boolResult2 then
			_aX[_c2] = _x
			_aY[_c2] = _y
			_aD[_c2] = distBetweenTwoPoints(_x, _y, _x1, _y1)
			-- dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
			_c2 = _c2 + 1
		end
		
		_x = _x1 + _c3 * TILE
		_y = _y1 - _c3 * TILE
		boolResult, _x, _y = pickStructLocation(_struct, _x, _y, player)
		boolResult2 = droidCanReach(_droid, _x, _y)
		if boolResult and boolResult2 then
			_aX[_c2] = _x
			_aY[_c2] = _y
			_aD[_c2] = distBetweenTwoPoints(_x, _y, _x1, _y1)
			-- dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
			_c2 = _c2 + 1
		end
		
		_x = _x1 - _c3 * TILE
		_y = _y1 + _c3 * TILE
		boolResult, _x, _y = pickStructLocation(_struct, _x, _y, player)
		boolResult2 = droidCanReach(_droid, _x, _y)
		if boolResult and boolResult2 then
			_aX[_c2] = _x
			_aY[_c2] = _y
			_aD[_c2] = distBetweenTwoPoints(_x, _y, _x1, _y1)
			-- dbg("dbg->getSafeBuildCoord: added in _c2("& _c2 &")  x-y("& _aX[_c2]/TILE &"-"& _aY[_c2]/TILE &")   dist ("& _aD[_c2]/TILE &"/"& _c1/TILE &")   from ("& _x1/TILE &"-"& _y1/TILE &")",player);
			_c2 = _c2 + 1
		end
		
		_c3 = _c3 + 1
	end
	
	_c3 = 0
	_c1 = 9999 * TILE
	-- find the nearest place to build
	while _c3 < _c2 do
		if _aD[_c3] < _c1 then
			_x = _aX[_c3]
			_y = _aY[_c3]
			_c1 = _aD[_c3]
		end
		_c3 = _c3 + 1
	end
	
	-- dbg("dbg->getSafeBuildCoord: safe build pos found in ("& _x/TILE &"-"& _y/TILE &") dist ("& _c1/TILE &") from ("& _x1/TILE &"-"& _y1/TILE &")",player);
	
	if _choice == 0 then
		return _x
	end
	if _choice == 1 then
		return _y
	end
	
	return -1
end

-- -----------------------------------------------------------------------------
function isDefStrComplete()
	local _defense = nil
	local _i = 0
	
	_i = 0
	_defense = nil
	
	while _i < pickDefQueueDepth do
		initEnumStruct(false, pickDefQueue[_i], player, player)
		_defense = enumStruct()
		while _defense ~= nil do
			if _defense.x == lastBuildDefX and _defense.y == lastBuildDefY then
				if not structureComplete(_defense) then
					return false
				else
					return true
				end
			end
			_defense = enumStruct()
		end
		_i = _i + 1
	end
	-- endwhile
	
	-- displayMsg("isDefStrComplete: OUT OF THE LOOP ");
	return false
end
-- -----------------------------------------------------------------------------
-- sends the defTruck to help building structures.
-- It checks there are no threat in range.
function helpBuild(_group)
	local _idleTruck = nil
	local _structurestat = nil
	local _i = 0
	
	_i = 0
	
	if _group == BUILDDEF_GRP then
		_idleTruck = pickDefTruck(true)
	end
	if _group == CYBENG_GRP then
		_idleTruck = pickCybEng(true)
	end
	if _group == BUILD_GRP then
		_idleTruck = closestIdleDroid(buildGroup, baseX, baseY)
	end
	if _group == HARVEST_GRP then
		_idleTruck = closestIdleDroid(harvesterGroup, baseX, baseY)
	end
	
	if _idleTruck == nil then
		return false
	end
	
	-- look for def structures first
	while _i < pickWallDefQueueDepth do
		initEnumStruct(false, pickWallDefQueue[_i], player, player)
		_structurestat = enumStruct()
		while _structurestat ~= nil do
			if not structureComplete(_structurestat) then
				if not threatInRange(player, _structurestat.x, _structurestat.y, THREAT_RANGE_TILES * 128, false) then
					if droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, _structurestat)
						return true
					end
				end
			end
			-- else {displayMsg("helpBuild: there is some threat in range");}
			_structurestat = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	
	-- look for def structures first
	while _i < pickDefQueueDepth do
		initEnumStruct(false, pickDefQueue[_i], player, player)
		_structurestat = enumStruct()
		while _structurestat ~= nil do
			if not structureComplete(_structurestat) then
				if not threatInRange(player, _structurestat.x, _structurestat.y, THREAT_RANGE_TILES * 128, false) then
					if droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, _structurestat)
						return true
					end
				end
			end
			-- else {displayMsg("helpBuild: there is some threat in range");}
			_structurestat = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	
	-- look for for incendries
	-- numIncendrys	INT					8
	-- incendrys[7]	STRUCTURESTAT		"Emplacement-MortarPit01"
	-- look for def structures first
	_i = 0
	while _i < numIncendrys do
		initEnumStruct(false, incendrys[_i], player, player)
		_structurestat = enumStruct()
		while _structurestat ~= nil do
			if not structureComplete(_structurestat) then
				if not threatInRange(player, _structurestat.x, _structurestat.y, THREAT_RANGE_TILES * 128, false) then
					if droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, _structurestat)
						return true
					end
				end
			end
			-- else {displayMsg("helpBuild: there is some threat in range");}
			_structurestat = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	
	if _idleTruck == nil then
		return false
	end
	-- look for sensor types
	-- numSense	INT					3
	-- sense[0]		STRUCTURESTAT		"Sys-SensoTowerWS"
	_i = 0
	while _i < numSense do
		initEnumStruct(false, sense[_i], player, player)
		_structurestat = enumStruct()
		while _structurestat ~= nil do
			if not structureComplete(_structurestat) then
				if not threatInRange(player, _structurestat.x, _structurestat.y, THREAT_RANGE_TILES * 128, false) then
					if droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, _structurestat)
						return true
					end
				end
			end
			-- else {displayMsg("helpBuild: there is some threat in range");}
			_structurestat = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	
	
	-- look for anti a.
	-- numAA	INT					6
	-- vtolDefStruct[0]	STRUCTURESTAT		"AASite-QuadMg1"			//hurricane
	_i = 0
	while _i < numAA do
		initEnumStruct(false, vtolDefStruct[_i], player, player)
		_structurestat = enumStruct()
		while _structurestat ~= nil do
			if not structureComplete(_structurestat) then
				if not threatInRange(player, _structurestat.x, _structurestat.y, THREAT_RANGE_TILES * 128, false) then
					if droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, _structurestat)
						return true
					end
				end
			end
			-- else {displayMsg("helpBuild: there is some threat in range");}
			_structurestat = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	
	if _idleTruck == nil then
		return false
	end
	
	-- look for Fortresses structs.
	-- numFortressDef
	-- fortressDef[0]
	_i = 0
	while _i < numFortressDef do
		initEnumStruct(false, fortressDef[_i], player, player)
		_structurestat = enumStruct()
		while _structurestat ~= nil do
			if not structureComplete(_structurestat) then
				if not threatInRange(player, _structurestat.x, _structurestat.y, THREAT_RANGE_TILES_SHORT * 128, false) then
					if droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, _structurestat)
						return true
					end
				end
			end
			-- else {displayMsg("helpBuild: there is some threat in range");}
			_structurestat = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	
	-- look for Essential structs.
	-- numStructs
	-- structs[0]
	_i = 0
	while _i < numStructs do
		initEnumStruct(false, baseStructs[_i], player, player)
		_structurestat = enumStruct()
		while _structurestat ~= nil do
			if not structureComplete(_structurestat) then
				if not threatInRange(player, _structurestat.x, _structurestat.y, THREAT_RANGE_TILES_SHORT * 128, false) then
					if droidCanReach(_idleTruck, _structurestat.x, _structurestat.y) then
						orderDroidObj(_idleTruck, DORDER_HELPBUILD, _structurestat)
						return true
					end
				end
			end
			-- else {displayMsg("helpBuild: there is some threat in range");}
			_structurestat = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	
	-- displayMsg("helpBuild: no structs found");
	return false
end

-- -----------------------------------------------------------------------------
-- search for the most damaged structure in the base and repair it
-- if found return true, otherwise return false. Return false also
-- if not idle trucks are found. it checks there are no threats in range
function repairStructs(_group)
	local _mostDamage = 0
	local _tempDamage = 0
	local _i = 0
	local _numStrToCheck = 0
	local _structure = nil
	local _mostDamagedStructure = nil
	local _idleTruck = nil
	
	_mostDamage = 0
	_mostDamagedStructure = nil
	_idleTruck = nil
	
	if _group == BUILDDEF_GRP then
		_idleTruck = pickDefTruck(true)
	end
	if _group == CYBENG_GRP then
		_idleTruck = pickCybEng(true)
	end
	if _group == BUILD_GRP then
		_idleTruck = closestIdleDroid(buildGroup, baseX, baseY)
	end
	if _group == HARVEST_GRP then
		_idleTruck = closestIdleDroid(harvesterGroup, baseX, baseY)
	end
	
	if _idleTruck == nil then
		return false
	end
	
	_i = 0
	_numStrToCheck = (numBaseStructs - 1)
	-- exclude derricks, threated below in this function
	while _i < _numStrToCheck do
		initEnumStruct(false, baseStructs[_i], player, player)
		_structure = enumStruct()
		while _structure ~= nil do
			_tempDamage = 100 - _structure.health
			if _tempDamage >= STRUCT_REPAIR_DAMAGE then
				if _tempDamage > _mostDamage then
					_mostDamage = _tempDamage
					_mostDamagedStructure = _structure
				end
			end
			-- }
			_structure = enumStruct()
		end
		_i = _i + 1
	end
	
	if _mostDamagedStructure ~= nil then
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedStructure)
		return true
	end
	
	initEnumStruct(false, derrick, player, player)
	_structure = enumStruct()
	while _structure ~= nil do
		_tempDamage = 100 - _structure.health
		if _tempDamage >= STRUCT_REPAIR_DAMAGE then
			if not threatInRange(player, _structure.x, _structure.y, THREAT_RANGE_TILES_SHORT * 128, false) and distBetweenTwoPoints(_structure.x, _structure.y, baseX, baseY) < nDefendRange then
				if _tempDamage > _mostDamage then
					_mostDamage = _tempDamage
					_mostDamagedStructure = _structure
				end
			end
		end
		_structure = enumStruct()
	end
	
	if _mostDamagedStructure ~= nil then
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedStructure)
		return true
	end
	
	return false
end

-- -----------------------------------------------------------------------------
-- search for the most damaged sefense in the base and repair it
-- if found return true, otherwise return false. Return false also
-- if not idle trucks are found. it checks there are no threats in range
function repairDefStructs(_group)
	local _mostDamage = 0
	local _tempDamage = 0
	local _i = 0
	local _defense = nil
	local _mostDamagedDefense = nil
	local _idleTruck = nil
	
	_mostDamage = 0
	_mostDamagedDefense = nil
	
	_idleTruck = nil
	
	if _group == BUILDDEF_GRP then
		_idleTruck = pickDefTruck(true)
	end
	if _group == CYBENG_GRP then
		_idleTruck = pickCybEng(true)
	end
	if _group == BUILD_GRP then
		_idleTruck = closestIdleDroid(buildGroup, baseX, baseY)
	end
	if _group == HARVEST_GRP then
		_idleTruck = closestIdleDroid(harvesterGroup, baseX, baseY)
	end
	
	if _idleTruck == nil then
		return false
	end
	
	-- look for vtol def
	_i = 0
	while _i < numAA do
		initEnumStruct(false, vtolDefStruct[_i], player, player)
		_defense = enumStruct()
		while _defense ~= nil do
			if distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange then
				_tempDamage = 100 - _defense.health
				if _tempDamage >= STRUCT_REPAIR_DAMAGE then
					if not threatInRange(player, _defense.x, _defense.y, THREAT_RANGE_TILES * 128, false) then
						if _tempDamage > _mostDamage then
							_mostDamage = _tempDamage
							_mostDamagedDefense = _defense
						end
					end
				end
			end
			_defense = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	if _mostDamagedDefense ~= nil then
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense)
		return true
	end
	
	_i = 0
	-- look for def structures
	while _i < pickWallDefQueueDepth do
		initEnumStruct(false, pickWallDefQueue[_i], player, player)
		_defense = enumStruct()
		while _defense ~= nil do
			if distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange then
				_tempDamage = 100 - _defense.health
				if _tempDamage >= STRUCT_REPAIR_DAMAGE then
					if not threatInRange(player, _defense.x, _defense.y, THREAT_RANGE_TILES * 128, false) then
						if _tempDamage > _mostDamage then
							_mostDamage = _tempDamage
							_mostDamagedDefense = _defense
						end
					end
				end
			end
			_defense = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	if _mostDamagedDefense ~= nil then
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense)
		return true
	end
	
	_i = 0
	-- look for def structures
	while _i < pickDefQueueDepth do
		initEnumStruct(false, pickDefQueue[_i], player, player)
		_defense = enumStruct()
		while _defense ~= nil do
			if distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange then
				_tempDamage = 100 - _defense.health
				if _tempDamage >= STRUCT_REPAIR_DAMAGE then
					if not threatInRange(player, _defense.x, _defense.y, THREAT_RANGE_TILES * 128, false) then
						if _tempDamage > _mostDamage then
							_mostDamage = _tempDamage
							_mostDamagedDefense = _defense
						end
					end
				end
			end
			_defense = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	if _mostDamagedDefense ~= nil then
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense)
		return true
	end
	
	-- double check...
	if _idleTruck == nil then
		return false
	end
	
	-- look for for incendries
	_i = 0
	while _i < numIncendrys do
		initEnumStruct(false, incendrys[_i], player, player)
		_defense = enumStruct()
		while _defense ~= nil do
			if distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange then
				_tempDamage = 100 - _defense.health
				if _tempDamage >= STRUCT_REPAIR_DAMAGE then
					if not threatInRange(player, _defense.x, _defense.y, THREAT_RANGE_TILES * 128, false) then
						if _tempDamage > _mostDamage then
							_mostDamage = _tempDamage
							_mostDamagedDefense = _defense
						end
					end
				end
			end
			_defense = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	if _mostDamagedDefense ~= nil then
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense)
		return true
	end
	
	-- double check...
	if _idleTruck == nil then
		return false
	end
	
	-- look for sensor types
	-- numSense	INT					3
	-- sense[0]		STRUCTURESTAT		"Sys-SensoTowerWS"
	_i = 0
	while _i < numSense do
		initEnumStruct(false, sense[_i], player, player)
		_defense = enumStruct()
		while _defense ~= nil do
			if distBetweenTwoPoints(_defense.x, _defense.y, baseX, baseY) < nDefendRange then
				_tempDamage = 100 - _defense.health
				if _tempDamage >= STRUCT_REPAIR_DAMAGE then
					if not threatInRange(player, _defense.x, _defense.y, THREAT_RANGE_TILES * 128, false) then
						if _tempDamage > _mostDamage then
							_mostDamage = _tempDamage
							_mostDamagedDefense = _defense
						end
					end
				end
			end
			_defense = enumStruct()
		end
		-- while struct
		_i = _i + 1
	end
	-- While _i
	if _mostDamagedDefense ~= nil then
		orderDroidObj(_idleTruck, DORDER_REPAIR, _mostDamagedDefense)
		return true
	end
	return false
end

-- -----------------------------------------------------------------------------
--[[update gateways coordinate
this works for now with maps with at least 2 gateways near the base]]--
function updateGateways()
	local _x = 0
	local _y = 0
	local _tx = 0
	local _ty = 0
	local _i = 0
	local _xx[4] = 0
	local _yy[4] = 0
	local _basecoordX = 0
	local _basecoordY = 0
	local _dist = 0
	
	_x = 0
	_y = 0
	
	_i = 0
	while _i < 4 do
		_xx[_i] = -1
		_yy[_i] = -1
		_i = _i + 1
	end
	
	-- displayMsg("updateGateways:MAP DIMENSIONS("& mapWidth &"-"& mapHeight &")");
	
	-- corner 1
	_tx = math.max(baseX - TILE * 8, 0)
	_ty = math.max(baseY - TILE * 8, 0)
	_basecoordX = _tx / TILE
	_basecoordY = _ty / TILE
	__result, _x, _y = getNearestGateway(_basecoordX, _basecoordY, _x, _y)
	if __result then
		_dist = distBetweenTwoPoints(baseX, baseY, _x * TILE, _y * TILE)
		-- displayMsg("updateGateways:Base coord 1 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
		if _dist < gatewaysRangeTiles * TILE then
			_xx[0] = _x
			_yy[0] = _y
		end
	end
	-- else {displayMsg("updateGateways:Base coord 1 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
	-- else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}
	
	-- corner 2
	_x = 0
	_y = 0
	_tx = math.min(baseX + TILE * 8, C.mapWidth * TILE)
	_ty = math.min(baseY + TILE * 8, C.mapHeight * TILE)
	_basecoordX = _tx / TILE
	_basecoordY = _ty / TILE
	__result, _x, _y = getNearestGateway(_basecoordX, _basecoordY, _x, _y)
	if __result then
		_dist = distBetweenTwoPoints(baseX, baseY, _x * TILE, _y * TILE)
		-- displayMsg("updateGateways:Base coord 2 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
		if _dist < gatewaysRangeTiles * TILE then
			if (_xx[0] + _yy[0] ~= _x + _y) then
				_xx[1] = _x
				_yy[1] = _y
			end
		end
	end
	-- else {displayMsg("updateGateways:Base coord 2 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
	-- else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}
	
	-- corner 3
	_x = 0
	_y = 0
	_tx = math.min(baseX + TILE * 8, C.mapWidth * TILE)
	_ty = math.max(baseY - TILE * 8, 0)
	_basecoordX = _tx / TILE
	_basecoordY = _ty / TILE
	__result, _x, _y = getNearestGateway(_basecoordX, _basecoordY, _x, _y)
	if __result then
		_dist = distBetweenTwoPoints(baseX, baseY, _x * TILE, _y * TILE)
		-- displayMsg("updateGateways:Base coord 3 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
		if _dist < gatewaysRangeTiles * TILE then
			if (_xx[0] + _yy[0] ~= _x + _y) and (_xx[1] + _yy[1] ~= _x + _y) then
				_xx[2] = _x
				_yy[2] = _y
			end
		end
	end
	-- else {displayMsg("updateGateways:Base coord 3 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
	-- else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}
	
	-- corner 4
	_x = 0
	_y = 0
	_tx = math.max(baseX - TILE * 8, 0)
	_ty = math.min(baseY + TILE * 8, C.mapHeight * TILE)
	_basecoordX = _tx / TILE
	_basecoordY = _ty / TILE
	__result, _x, _y = getNearestGateway(_basecoordX, _basecoordY, _x, _y)
	if __result then
		_dist = distBetweenTwoPoints(baseX, baseY, _x * TILE, _y * TILE)
		-- displayMsg("updateGateways:Base coord 4 dist("& _dist/TILE &") - ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways found at ("& _x &")-("& _y &") ");
		if _dist < gatewaysRangeTiles * TILE then
			if (_xx[0] + _yy[0] ~= _x + _y) and (_xx[1] + _yy[1] ~= _x + _y) and (_xx[2] + _yy[2] ~= _x + _y) then
				_xx[3] = _x
				_yy[3] = _y
			end
		end
	end
	-- else {displayMsg("updateGateways:Base coord 4 ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways ("& _x &")-("& _y &") NOT IN RANGE ("& gatewaysRangeTiles*128 &")");}
	-- else {displayMsg("Base coord ("& (int)_basecoordX &")-("& (int)_basecoordY &") gateways NOT found ");}
	
	-- find out how many gateways have been found
	_i = 0
	while _i < 4 do
		if _xx[_i] > 0 and _yy[_i] > 0 then
			aGatewayPosX[nRealGatewaysFound] = _xx[_i] * TILE
			aGatewayPosY[nRealGatewaysFound] = _yy[_i] * TILE
			_dist = distBetweenTwoPoints(baseX, baseY, aGatewayPosX[nRealGatewaysFound], aGatewayPosY[nRealGatewaysFound])
			nRealGatewaysFound = nRealGatewaysFound + 1
			printDebug1("gateway #" .. nRealGatewaysFound .. " coord x-y" .. _xx[_i] .. "-" .. _yy[_i] .. " dist from base(" .. _dist / TILE .. ") defend range(" .. nDefendRange / TILE .. ")")
		end
		_i = _i + 1
	end
	
	numDefStrAtGateway = 1
	-- reSortGateways - put the gateways near to the enemy on the top of the array.
	-- reSortGateways();
	-- displayMsg("*** updateGateways: tot REAL gateways found: ("& nRealGatewaysFound &")" );
	
	-- default is 0
	return nRealGatewaysFound
end

-- -----------------------------------------------------------------------------
function initAssignUnitToGrp()
	local xGRP = Group()
	local _droid = nil
	local cc = 0
	local _tot = 0
	
	cc = 0
	groupAddArea(xGRP, player, 0, 0, (C.mapWidth * 128), (C.mapHeight * 128))
	initIterateGroup(xGRP)
	droid = iterateGroup(xGRP)
	while droid ~= nil do
		assignDroidToGrp(droid)
		droid = iterateGroup(xGRP)
	end
	
	-- in assignDroidToGrp all trcks are assigned as default to buildGroup
	_tot = groupCountMembers(buildGroup)
	if _tot == 2 or _tot == 3 then
		_droid = getADroid(buildGroup)
		if _droid ~= nil then
			groupAddDroid(harvesterGroup, _droid)
		end
	end
	if _tot > 3 then
		_droid = getADroid(buildGroup)
		if _droid ~= nil then
			groupAddDroid(harvesterGroup, _droid)
		end
		_droid = getADroid(buildGroup)
		if _droid ~= nil then
			groupAddDroid(harvesterGroup, _droid)
		end
	end
end

-- -----------------------------------------------------------------------------
function updateBaseRange()
	local _baseRange = 0
	local _i = 0
	local _result = 0
	
	maxy = 0
	maxx = 0
	miny = (C.mapHeight * 128)
	minx = (C.mapWidth * 128)
	
	-- avoid possible div by 0
	_baseRange = 1
	aaRange = 1
	
	_i = 0
	-- need +1 to exclude the derricks!!!
	while _i + 1 < numBaseStructs do
		initEnumStruct(false, baseStructs[_i], player, player)
		structure = enumStruct()
		while structure ~= nil do
			if structure.x < minx then
				minx = structure.x
			end
			if structure.x > maxx then
				maxx = structure.x
			end
			if structure.y < miny then
				miny = structure.y
			end
			if structure.y > maxy then
				maxy = structure.y
			end
			
			_result = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y)
			if _result > _baseRange then
				_baseRange = _result
			end
			
			structure = enumStruct()
		end
		_i = _i + 1
	end
	
	_result = 7 * TILE
	
	minx = minx - _result
	maxx = maxx + _result
	miny = miny - _result
	maxy = maxy + _result
	
	if minx < 0 then
		minx = TILE
	end
	if miny < 0 then
		miny = TILE
	end
	if maxx > (C.mapWidth * TILE) then
		maxx = (C.mapWidth * TILE) - TILE
	end
	if maxy > (C.mapHeight * TILE) then
		maxy = (C.mapHeight * TILE) - TILE
	end
	
	-- between the base and _baseRange
	aaRange = _baseRange + TILE
	
	nBaseRange = _baseRange + (5 * TILE)
end

-- -----------------------------------------------------------------------------
function updateDefendRange()
	local _n = 0
	local _g = 0
	
	-- Update nDefendRange
	_n = 0
	_g = 999 * TILE
	while _n < MAX_PLAYERS do
		if not friendlyPlayer(_n) then
			structure = getStructure(playerHQ, _n)
			if structure == nil then
				structure = getStructure(factory, _n)
			end
			if structure == nil then
				structure = getStructure(powGen, _n)
			end
			if structure == nil then
				structure = getStructure(vtolFactory, _n)
			end
			if structure == nil then
				structure = getStructure(cybFactory, _n)
			end
			if structure == nil then
				structure = getStructure(uplinkCenter, _n)
			end
			if structure == nil then
				structure = getStructure(resLab, _n)
			end
			if structure ~= nil then
				if distBetweenTwoPoints(baseX, baseY, structure.x, structure.y) < _g then
					_g = distBetweenTwoPoints(baseX, baseY, structure.x, structure.y)
				end
			end
		end
		_n = _n + 1
	end
	if _g ~= 999 * TILE then
		nDefendRange = _g / 2
	else
		if nPlayersInGame > 1 then
			if nPlayersInGame < 5 then
				nDefendRange = ((math.max(C.mapWidth, C.mapHeight) * TILE) / 2)
			else
				if nPlayersInGame < 8 then
					nDefendRange = ((math.max(C.mapWidth, C.mapHeight) * TILE) / 4)
				end
			end
			nDefendRange = ((nDefendRange) * 0.7)
		end
	end
	
	
	-- double check...
	if nDefendRange < nBaseRange then
		nDefendRange = nBaseRange + 8 * TILE
	end
	
	-- do not make it too big
	if nDefendRange > MAX_DEFEND_RANGETILES * TILE then
		nDefendRange = MAX_DEFEND_RANGETILES * TILE
	end
end
-- -----------------------------------------------------------------------------
-- update base coordinates dinamically
function updateBaseCoord()
	local _structure = nil
	local _truck = nil
	local _bHaveBaseStructs = false
	local _index = 0
	local _baseX = 0
	local _baseY = 0
	local _numBaseStructs = 0
	local _bucket = 0
	
	_bHaveBaseStructs = false
	
	-- Go through all structures
	_index = 0
	_numBaseStructs = 0
	_baseX = 0
	_baseY = 0
	-- +1 to exclude derricks!!
	while _index + 1 < numBaseStructs do
		initEnumStruct(false, baseStructs[_index], player, player)
		_structure = enumStruct()
		while _structure ~= nil do
			_baseX = _baseX + _structure.x / TILE
			_baseY = _baseY + _structure.y / TILE
			
			_numBaseStructs = _numBaseStructs + 1
			_structure = enumStruct()
		end
		_index = _index + 1
	end
	
	if _numBaseStructs > 0 then
		baseX = (_baseX / _numBaseStructs) * TILE
		baseY = (_baseY / _numBaseStructs) * TILE
	else
		_truck = getADroid(buildGroup)
		if _truck == nil then
			_truck = getADroid(harvesterGroup)
		end
		if _truck == nil then
			_truck = getADroid(buildDefGroup)
		end
		
		if _truck ~= nil then
			baseX = _truck.x
			baseY = _truck.y
		else
			baseX = (TILE * C.mapWidth) / 2
			baseY = (TILE * C.mapHeight) / 2
			displayMsg("### Couldn't find base location for " .. getPlayerName(player))
		end
	end
end

-- perform a research o resLab _resFac on the  _lastResIndex+1 item
-- returns -1 if no researches have started
-- -----------------------------------------------------------------------------
function do_CheapResearch(_resFac, _lastResIndex)
	local _bStarted = false
	local _tech = 0
	local _nn = 0
	local _ii = 0
	
	-- current tech tree
	-- 0=tank
	_tech = 0
	_nn = 0
	
	-- this res lab idle for now
	_bStarted = false
	while not _bStarted and _nn < 100 do
		_lastResIndex = find_Research(_lastResIndex, _tech, 2)
		-- found research
		if _lastResIndex > -1 then
			_bStarted = pursueResearch(_resFac, player, researchCheap[_tech][_lastResIndex])
			if _bStarted then
				tLastResearch = C.gameTime
				-- displayMsg("*** do_CheapResearch : pursue: ["& _tech &"]["& _lastResIndex &"] steps left ("& numResearchLeft(player,researchCheap[_tech][_lastResIndex]) &") researchFinished("& researchFinished(researchCheap[_tech][_lastResIndex],player)&") researchStarted("& researchStarted(researchCheap[_tech][_lastResIndex],player)&") lStopResearch("& lStopResearch &") nProdSelect("& nProdSelect &") lStopCheapResearch("& lStopCheapResearch &") pow("& playerPower(player) &")");
				printDebug1("do_CheapResearch : pursue [" .. _tech .. "][" .. _lastResIndex .. "] steps left (" .. numResearchLeft(player, researchCheap[_tech][_lastResIndex]) .. ") nProdSelect(" .. nProdSelect .. ") power(" .. playerPower(player) .. ")")
			end
		else
			_bStarted = true
		end
		
		_nn = _nn + 1
	end
	
	if not _bStarted then
		return -1
	end
	return _lastResIndex
end
-- perform a research o resLab _resFac on the  _lastResIndex+1 item
-- returns -1 if no researches have started
-- -----------------------------------------------------------------------------
function do_Research(_resFac, _lastResIndex)
	local _bStarted = false
	local _tech = 0
	local _nn = 0
	local _VTOLprob = 0
	
	-- current tech tree
	-- 0=tank 1=VTOL research
	_tech = 0
	_nn = 0
	
	-- VTOL AI
	if AIPersonality == AI_VTOL then
		if C.gameTime > TIME_START_VTOLRESEARCH then
			if not skVtolEnableCheck(player) then
				_VTOLprob = 99
			else
				_VTOLprob = 40
			end
		else
			if not skVtolEnableCheck(player) then
				_VTOLprob = 50
			else
				_VTOLprob = 40
			end
		end
	end
	
	-- Other AIs
	if C.gameTime > TIME_START_VTOLRESEARCH then
		if not skVtolEnableCheck(player) then
			_VTOLprob = 50
		else
			_VTOLprob = 25
		end
	else
		_VTOLprob = 20
	end
	
	if random(100) > _VTOLprob then
		_tech = 0
	else
		_tech = 9
	end
	
	-- this res lab idle for now
	_bStarted = false
	while not _bStarted and _nn < 100 do
		_lastResIndex = find_Research(_lastResIndex, _tech, 1)
		if _lastResIndex > -1 then
			_bStarted = pursueResearch(_resFac, player, research[_tech][_lastResIndex])
			if _bStarted then
				printDebug1("do_Research : pursue [" .. _tech .. "][" .. _lastResIndex .. "] steps left (" .. numResearchLeft(player, research[_tech][_lastResIndex]) .. ") nProdSelect(" .. nProdSelect .. ") power(" .. playerPower(player) .. ") _VTOLprob(" .. _VTOLprob .. "%)")
				tLastResearch = C.gameTime
			end
		else
			if _tech == 0 then
				_tech = 1
				-- 1=standard Research
				_lastResIndex = find_Research(_lastResIndex, _tech, 1)
				if _lastResIndex > -1 then
					_bStarted = pursueResearch(_resFac, player, research[_tech][_lastResIndex])
					if _bStarted then
						printDebug1("do_Research : pursue [" .. _tech .. "][" .. _lastResIndex .. "] steps left (" .. numResearchLeft(player, research[_tech][_lastResIndex]) .. ") nProdSelect(" .. nProdSelect .. ") power(" .. playerPower(player) .. ") _VTOLprob(" .. _VTOLprob .. "%)")
						tLastResearch = C.gameTime
					end
				else
					_bStarted = true
				end
			else
				_bStarted = true
			end
		end
		
		_nn = _nn + 1
	end
	
	if not _bStarted then
		return -1
	end
	
	return _lastResIndex
end
-- -----------------------------------------------------------------------------
-- return the _resIndex to be used for pursueResearch(_resFac,me,research[_tech][_resIndex])
-- if not research is found returns -1
function find_Research(_searchStart, _techTree, whichArray)
	local _retInt = 0
	
	ASSERT(_searchStart >= 0, "findResearch: _searchStart < 0", player)
	ASSERT(_techTree >= 0, "findResearch: _techTree < 0", player)
	
	-- =============== STANDARD RESEARCH ==================
	if whichArray == 1 then
		_retInt = _searchStart
		while _retInt < numRes[_techTree] do
			if (not researchFinished(research[_techTree][_retInt], player)) and (not researchStarted(research[_techTree][_retInt], player)) then
				return _retInt
			end
			_retInt = _retInt + 1
		end
	else
		while _retInt < numCheapRes[0] do
			if (not researchFinished(researchCheap[_techTree][_retInt], player)) and (not researchStarted(researchCheap[_techTree][_retInt], player)) then
				return _retInt
			end
			-- else {displayMsg("Cheap Research index ("& _retInt &") cannot be researched ");   }
			_retInt = _retInt + 1
		end
	end
	
	
	-- not found
	_retInt = -1
	return (_retInt)
end
-- -----------------------------------------------------------------------------
function numStructsByType(_structure, _player)
	local _str = nil
	local _count = 0
	
	_count = 0
	
	initEnumStruct(false, _structure, _player, _player)
	_str = enumStruct()
	while _str ~= nil do
		_count = _count + 1
		_str = enumStruct()
	end
	return _count
end
-- -----------------------------------------------------------------------------
function nearestDroidToBeRepaired(_group, _x, _y)
	local _droid = nil
	local _damagedUnit = nil
	local _tmpDist = 0
	
	_tmpDist = 999 * TILE
	_damagedUnit = nil
	
	initIterateGroup(_group)
	_droid = iterateGroup(_group)
	while _droid ~= nil do
		if _droid.health < MIN_HEALT_REPAIR_BASE then
			if distBetweenTwoPoints(_droid.x, _droid.y, _x, _y) < _tmpDist then
				_tmpDist = distBetweenTwoPoints(_droid.x, _droid.y, _x, _y)
				_damagedUnit = _droid
			end
		end
		-- else{	displayMsg("*** unitToBeRepaired: damaged unit ("& _droid.id &") with damage ("& _droid.health &") not in basereange  "); }
		_droid = iterateGroup(_group)
	end
	
	-- check for damaged units _droid.health < 95
	if _damagedUnit == nil then
		initIterateGroup(_group)
		_droid = iterateGroup(_group)
		while _droid ~= nil do
			if _droid.health < 95 then
				if distBetweenTwoPoints(_droid.x, _droid.y, _x, _y) < _tmpDist then
					_tmpDist = distBetweenTwoPoints(_droid.x, _droid.y, _x, _y)
					_damagedUnit = _droid
				end
			end
			-- else{	displayMsg("*** unitToBeRepaired: damaged unit ("& _droid.id &") with damage ("& _droid.health &") not in basereange  "); }
			_droid = iterateGroup(_group)
		end
	end
	
	return _damagedUnit
end
-- -----------------------------------------------------------------------------
function unitToBeRepaired(_group)
	local _droid = nil
	local _damagedUnit = nil
	local _tmpDamage = 0
	local _damage = 0
	
	_tmpDamage = 0
	_damagedUnit = nil
	
	initIterateGroup(_group)
	_droid = iterateGroup(_group)
	while _droid ~= nil do
		_damage = 100 - _droid.health
		if _droid.health < MIN_HEALT_REPAIR_BASE and _damage > _tmpDamage then
			if distBetweenTwoPoints(_droid.x, _droid.y, baseX, baseY) < nBaseRange then
				_tmpDamage = _damage
				_damagedUnit = _droid
			end
		end
		-- else{	displayMsg("*** unitToBeRepaired: damaged unit ("& _droid.id &") with damage ("& _droid.health &") not in basereange  "); }
		_droid = iterateGroup(_group)
	end
	
	return _damagedUnit
end
-- -----------------------------------------------------------------------------
-- check if the repair droid itself has to be repaired or not.
function idleRepairDroid(_x, _y)
	local _closestTruck = nil
	local _tempTruck = nil
	local _closestDist = 0
	local _tempDist = 0
	
	_closestTruck = nil
	_closestDist = 999 * TILE
	
	initIterateGroup(repairGroup)
	_tempTruck = iterateGroup(repairGroup)
	while _tempTruck ~= nil do
		if _tempTruck.health > MIN_HEALT_REPAIR_BASE then
			if _tempTruck.order ~= DORDER_DROIDREPAIR then
				_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y)
				if _tempDist < _closestDist then
					_closestDist = _tempDist
					_closestTruck = _tempTruck
				end
			end
		end
		_tempTruck = iterateGroup(repairGroup)
	end
	return _closestTruck
end
-- -----------------------------------------------------------------------------
function moveUnitsBetweenGRPs(_toGRP, _fromGRP, _unitsToMove, _bNoTrucks)
	local _c = 0
	local _tempTruck = nil
	
	_c = 0
	
	-- If requested, leave trucked droids in defend group
	if _bNoTrucks then
		initIterateGroup(_fromGRP)
		_tempTruck = iterateGroup(_fromGRP)
		while _c < _unitsToMove and _tempTruck ~= nil do
			if _tempTruck.propulsion ~= TrackedProp then
				groupAddDroid(_toGRP, _tempTruck)
				_c = _c + 1
			end
			_tempTruck = iterateGroup(_fromGRP)
		end
	end
	
	-- move the remaining units
	initIterateGroup(_fromGRP)
	_tempTruck = iterateGroup(_fromGRP)
	while _c < _unitsToMove do
		groupAddDroid(_toGRP, _tempTruck)
		_c = _c + 1
		_tempTruck = iterateGroup(_fromGRP)
	end
end

-- -----------------------------------------------------------------------------
function attackedByDroid(_droid)
	local _nEnNewWeapDroids = 0
	local _nOldEnWeapDroids = 0
	local _nNewAlertDistFromBase = 0
	local _nOldAlertDistFromBase = 0
	local _nEnWeapDroids = 0
	local _nFrWeapStructs = 0
	local _nFrWeapDroids = 0
	local _nTotFriendlyWapons = 0
	
	if _droid == nil then
		return
	end
	
	boolResult = true
	_nOldAlertDistFromBase = 9999 * TILE
	_nOldEnWeapDroids = 0
	
	if _droid.player < 0 or _droid.player > 7 then
		return
	end
	if isVtol(_droid) then
		if defTargetVTOL == nil then
			defTargetVTOL = _droid
			targetPlayerVTOL = _droid.player
			bVTOLTargetIsDerrick = false
		end
		return
	end
	
	_nNewAlertDistFromBase = distBetweenTwoPoints(_droid.x, _droid.y, baseX, baseY)
	
	-- get VTOL target
	if _nNewAlertDistFromBase < nDefendRange and groupCountMembers(vtolDefendGr) > 0 and defTargetVTOL == nil and attTargetVTOL == nil then
		defTargetVTOL = objDroidTargetInRange(_droid.x, _droid.y, TILE * 12, true)
		if defTargetVTOL == nil then
			defTargetVTOL = _droid
			bVTOLTargetIsDerrick = false
			if targetPlayerVTOL < 0 then
				targetPlayerVTOL = _droid.player
			end
		end
	end
	-- else {  displayMsg("AIAttacked: SUCCESSFUL to get a Target in defend range for VTOLs"); }
	
	_nEnWeapDroids = numEnemyWeapDroidsInRange(player, _droid.x, _droid.y, COMBAT_RANGE(), false)
	_nFrWeapStructs = numFriendlyWeapStructsInRange(player, _droid.x, _droid.y, COMBAT_RANGE(), false)
	_nFrWeapDroids = groupCountMembers(tankDefGroup) + groupCountMembers(cyborgDefGroup)
	_nTotFriendlyWapons = _nFrWeapStructs + _nFrWeapDroids
	
	-- if it is a new second alert check which one is the nearest to the base
	if alertIsOn and alertX > 0 and alertY > 0 then
		_nOldAlertDistFromBase = distBetweenTwoPoints(alertX, alertY, baseX, baseY)
		-- check if new threat is bigger then the older one
		_nOldEnWeapDroids = numEnemyWeapDroidsInRange(player, alertX, alertY, COMBAT_RANGE(), false)
		if _nOldEnWeapDroids > _nEnNewWeapDroids then
			boolResult = false
		end
		-- if new alert is within the base this has priority 1!!
		if boolResult and _nNewAlertDistFromBase > nBaseRange and _nOldAlertDistFromBase < nBaseRange then
			boolResult = false
		end
	end
	
	if boolResult then
		if _nEnWeapDroids >= _nTotFriendlyWapons then
			alertLevel = RED_ALERT
		end
		if _nEnWeapDroids >= _nTotFriendlyWapons * 0.7 and _nEnWeapDroids < _nTotFriendlyWapons then
			alertLevel = YELLOW_ALERT
		end
		if _nEnWeapDroids < _nTotFriendlyWapons * 0.7 then
			alertLevel = GREEN_ALERT
		end
		
		-- move all untis in tankDefGrp
		if alertLevel == RED_ALERT then
			if groupCountMembers(tankGroup) > 0 then
				groupAddGroup(tankDefGroup, tankGroup)
				deactivateTankAttack()
			end
			if groupCountMembers(cyborgAttGroup) > 0 then
				groupAddGroup(cyborgDefGroup, cyborgAttGroup)
				deactivateCybAttack()
			end
			if groupCountMembers(helpGroup) > 0 then
				msg("My base is in trouble recalling " .. groupCountMembers(helpGroup) .. " helping units back", player, nAllyBeingHelped)
				if AIPersonality == AI_CYBORG then
					groupAddGroup(cyborgDefGroup, helpGroup)
				else
					groupAddGroup(tankDefGroup, helpGroup)
				end
				deactivateHelp()
			end
			-- ask for help, recalculate my units
			_nFrWeapDroids = groupCountMembers(tankDefGroup) + groupCountMembers(cyborgDefGroup)
		end
	end
end


-- endif boolResult
-- -----------------------------------------------------------------------------
function attackedByStruct(_struct)
	local _nEnNewWeapDroids = 0
	local _nOldEnWeapDroids = 0
	local _nNewAlertDistFromBase = 0
	local _nOldAlertDistFromBase = 0
	local _nEnWeapDroids = 0
	local _nFrWeapStructs = 0
	local _nFrWeapDroids = 0
	local _nTotFriendlyWapons = 0
	
	if _struct == nil then
		return
	end
	
	boolResult = true
	if _struct.player < 0 or _struct.player > 7 then
		return
	end
	
	-- set as VTOL target
	defTargetVTOL = _struct
	targetPlayerVTOL = _struct.player
	bVTOLTargetIsDerrick = false
	
	-- // IF targetPl NOT SET - PUNISH THE OFFENDER
	_nNewAlertDistFromBase = distBetweenTwoPoints(_struct.x, _struct.y, baseX, baseY)
	_nEnWeapDroids = numEnemyWeapStructsInRange(player, _struct.x, _struct.y, COMBAT_RANGE(), false)
	_nFrWeapStructs = numFriendlyWeapStructsInRange(player, _struct.x, _struct.y, COMBAT_RANGE(), false)
	_nFrWeapDroids = groupCountMembers(tankDefGroup) + groupCountMembers(cyborgDefGroup)
	_nTotFriendlyWapons = _nFrWeapStructs + _nFrWeapDroids
	
	-- if it is a new second alert check which one is the nearest to the base
	if alertIsOn and alertX > 0 and alertY > 0 then
		_nOldAlertDistFromBase = distBetweenTwoPoints(alertX, alertY, baseX, baseY)
		-- check if new threat is bigger then the older one
		_nOldEnWeapDroids = numEnemyWeapDroidsInRange(player, alertX, alertY, COMBAT_RANGE(), false)
		if _nOldEnWeapDroids > _nEnWeapDroids then
			boolResult = false
		end
		-- if new alert is uin the base this has priority 1!!
		if (_nNewAlertDistFromBase < nBaseRange) and (_nOldAlertDistFromBase > nBaseRange) then
			boolResult = true
		end
	end
	
	if boolResult then
		if _nEnWeapDroids >= _nTotFriendlyWapons then
			alertLevel = RED_ALERT
		end
		if _nEnWeapDroids >= _nTotFriendlyWapons * 0.7 and _nEnWeapDroids < _nTotFriendlyWapons then
			alertLevel = YELLOW_ALERT
		end
		if _nEnWeapDroids < _nTotFriendlyWapons * 0.7 then
			alertLevel = GREEN_ALERT
		end
		
		if groupCountMembers(tankGroup) > 0 and alertLevel == RED_ALERT then
			groupAddGroup(tankDefGroup, tankGroup)
		end
		if groupCountMembers(cyborgAttGroup) > 0 and alertLevel == RED_ALERT then
			groupAddGroup(cyborgDefGroup, cyborgAttGroup)
		end
	end
end

-- displayMsg("______________________________________________________________________________________");

-- endif boolResult
-- -----------------------------------------------------------------------------
function getNumStructNotIdle(_structToCheck)
	local _struct = nil
	local _tot = 0
	
	_tot = 0
	
	initEnumStruct(false, _structToCheck, player, player)
	_struct = enumStruct()
	while _struct ~= nil do
		if structureComplete(_struct) then
			if not structureIdle(_struct) then
				_tot = _tot + 1
			end
		end
		_struct = enumStruct()
	end
	
	return _tot
end
-- -----------------------------------------------------------------------------
function numRemainingOilRes()
	local _tempOilRes = nil
	local _nTot = 0
	_nTot = 0
	
	initGetFeature(oilRes, -1, player)
	_tempOilRes = getFeature(player)
	while _tempOilRes ~= nil and _nTot < MAX_WHILE_LOOPS do
		_nTot = _nTot + 1
		_tempOilRes = getFeature(player)
	end
	
	return _nTot
end
-- -----------------------------------------------------------------------------
function bAnyOilResLeft()
	local _droid = nil
	boolResult = true
	
	initEnumDroids(player, player)
	_droid = enumDroid()
	while _droid ~= nil and boolResult do
		if _droid ~= nil then
			boolResult = false
		end
		_droid = enumDroid()
	end
	
	if _droid == nil then
		return false
	end
	
	initGetFeature(oilRes, -1, player)
	feature = getFeature(player)
	while feature ~= nil do
		if droidCanReach(_droid, feature.x, feature.y) then
			return true
		end
		feature = getFeature(player)
	end
	
	return false
end
-- -----------------------------------------------------------------------------
function getTotDerricksMap()
	local _player = 0
	local _totDerricks = 0
	_player = 0
	_totDerricks = 0
	
	while _player < MAX_PLAYERS do
		_totDerricks = _totDerricks + getNumDerricks(_player)
		_player = _player + 1
	end
	return _totDerricks
end

-- -----------------------------------------------------------------------------
function sendIdleBackToTheBase(_group)
	local _idleTruck = nil
	local _stop = false
	local _c = 0
	
	-- _c=0;
	-- _stop = false;
	_idleTruck = nil
	
	if _group == BUILDDEF_GRP then
		_idleTruck = pickDefTruck(true)
	end
	if _group == CYBENG_GRP then
		_idleTruck = pickCybEng(true)
	end
	if _group == BUILD_GRP then
		_idleTruck = closestIdleDroid(buildGroup, baseX, baseY)
	end
	if _group == HARVEST_GRP then
		_idleTruck = closestIdleDroid(harvesterGroup, baseX, baseY)
	end
	
	if _idleTruck ~= nil then
		_c = distBetweenTwoPoints(_idleTruck.x, _idleTruck.y, baseX, baseY)
		if _c > nBaseRange and _idleTruck.order ~= DORDER_RTB then
			orderDroid(_idleTruck, DORDER_RTB)
		end
	end
end

-- else {
-- dbg("sendIdleBackToTheBase: ("& _group &") NOT send droid ("& _idleTruck.id &") back to the base _c("& _c/TILE &")("& nBaseRange/TILE &")",player);
-- }

-- end while
-- _c++;
-- }
-- -----------------------------------------------------------------------------
-- returns _nWhichCooord(x or y) such that they are _nDist distance away from _x1/_y1 direction _x2,_y2
function getCoordRelated(_x1, _y1, _x2, _y2, _nWhichCooord, _nDist)
	local _xx = 0
	local _yy = 0
	local _return = 0
	local _droid = nil
	
	_droid = getADroid(harvesterGroup)
	if _droid == nil then
		_droid = getADroid(buildGroup)
	end
	if _droid == nil then
		_droid = getADroid(buildDefGroup)
	end
	if _droid == nil then
		_droid = getADroid(tankDefGroup)
	end
	if _droid == nil then
		_droid = getADroid(cyborgDefGroup)
	end
	if _droid == nil then
		_droid = getADroid(cyborgConstructGroup)
	end
	if _droid == nil then
		_droid = getADroid(tankGroup)
	end
	if _droid == nil then
		_droid = getADroid(cyborgAttGroup)
	end
	if _droid == nil then
		_droid = getADroid(toBeRepairedCyborgGroup)
	end
	if _droid == nil then
		_droid = getADroid(toBeRepairedTankGroup)
	end
	if _droid == nil then
		_droid = getADroid(helpGroup)
	end
	if _droid ~= nil then
		if _x1 > _x2 then
			_xx = _x1 - _nDist
			if _xx < _x2 then
				_xx = _x1 - (_x1 - _x2) / 2
			end
		else
			_xx = _x1 + _nDist
			if _xx > _x2 then
				_xx = _x1 + (_x2 - _x1) / 2
			end
		end
		if _y1 > _y2 then
			_yy = _y1 - _nDist
			if _yy < _y2 then
				_yy = _y2 - (_y1 - _y2) / 2
			end
		else
			_yy = _y1 + _nDist
			if _yy > _y2 then
				_yy = _y1 + (_y2 - _y1) / 2
			end
		end
		-- printDebug1("getCoordRelated-1, _nDist("& _nDist/TILE &") from("& _x1/TILE  &"-"& _y1/TILE &") to("& _x2/TILE  &"-"& _y2/TILE &") result("& _xx/TILE  &"-"& _yy/TILE &")");
		
		__result, _xx, _yy = pickStructLocation(vtolPad, _xx, _yy, player)
		if __result then
			if droidCanReach(_droid, _xx, _yy) then
				if _nWhichCooord == 1 then
					return _xx
				end
				if _nWhichCooord == 2 then
					return _yy
				end
			end
		end
	end
	return -1
end

-- -----------------------------------------------------------------------------
-- _targetPlayer == -1 as default
function findEnemyOBJ(_mustBeHuman, _targetPlayer)
	local _attackObject = nil
	local _targetPl = 0
	local _xCoord = 0
	local _yCoord = 0
	
	_attackObject = nil
	_targetPl = -1
	
	-- if big maps, pick up nearest enemy
	if (C.mapWidth + C.mapHeight) / 2 > BIG_MAP then
		if _targetPlayer >= 0 then
			_targetPl = _targetPlayer
		else
			_targetPl = getNearestEnemyPlayer(_mustBeHuman)
		end
	else
		if _targetPlayer >= 0 then
			_targetPl = _targetPlayer
		end
	end
	
	-- target player not found!!!
	if _targetPl < 0 then
		_targetPl = getRandomEnemyPlayer(_mustBeHuman)
	end
	if _targetPl == -1 then
		return _attackObject
	end
	-- else { dbg("dbg -> findEnemyOBJ(): found a target player player("& _targetPl &") _mustBeHuman("& _mustBeHuman &")",player); }
	
	_xCoord = getEnemy_baseCoord(_targetPl, "X")
	_yCoord = getEnemy_baseCoord(_targetPl, "Y")
	if _xCoord > 0 and _yCoord > 0 then
		_attackObject = objStrTargetInRange(_xCoord, _yCoord, 15 * TILE)
	end
	if _attackObject == nil then
		_attackObject = skLocateEnemy(_targetPl)
	end
	
	return _attackObject
end

-- -----------------------------------------------------------------------------
function gameType()
	if nHumanPlayers == 1 then
		if nPlayersInGame == 2 then
			return GT_2PLAYERS_1HP
		end
		if nPlayersInGame == 3 or nPlayersInGame == 4 then
			if nTeam == 2 then
				return GT_4PLAYERS_1HP_2T
			end
			if nTeam > 2 then
				return GT_4PLAYERS_1HP_34T
			end
		end
		if nPlayersInGame > 4 then
			if nTeam < 4 then
				return GT_8PLAYERS_1HP_23T
			end
			if nTeam >= 4 then
				return GT_8PLAYERS_1HP_4567T
			end
		end
	else
		
		if nHumanPlayers == 2 then
			if nPlayersInGame == 3 or nPlayersInGame == 4 then
				if nTeam == 2 then
					return GT_4PLAYERS_2HP_2T
				end
				if nTeam > 2 then
					return GT_4PLAYERS_2HP_34T
				end
			end
			if nPlayersInGame > 4 then
				if nTeam < 4 then
					return GT_8PLAYERS_2HP_23T
				end
				if nTeam >= 4 then
					return GT_8PLAYERS_2HP_4567T
				end
			end
		else
			
			if nHumanPlayers == 3 then
				return GT_8PLAYERS_3HP_23T
			else
				return GT_STANDARD
			end
		end
	end
	
	return GT_STANDARD
end
-- -----------------------------------------------------------------------------
--
function getTargetEnemy(_dbg)
	local _nMyUnitsTot = 0
	local _nMyUnitsPower = 0
	local _nMyUnitsHP = 0
	local _nEnUnitsTot = 0
	local _nEnUnitsPower = 0
	local _nEnUnitsHP = 0
	local _nAvUnitsTot = 0
	local _nAvUnitsPower = 0
	local _nAvUnitsHP = 0
	local _nTotUnitsTot = 0
	local _nTotUnitsPower = 0
	local _nTotUnitsHP = 0
	local _player = 0
	local _tempPlayer = 0
	local _c2 = 0
	local _c3 = 0
	local _nMyPowerIndex = 0
	local _nEnPowerIndex = 0
	local _nAvPowerIndex = 0
	local _nTotPowerIndex = 0
	
	_tempPlayer = -1
	
	_nMyUnitsTot = groupCountMembers(tankDefGroup) + groupCountMembers(cyborgDefGroup) + groupCountMembers(cyborgAttGroup)
	_nMyUnitsPower = getWeaponUnitsInfo(player, WUI_POWER)
	_nMyUnitsHP = getWeaponUnitsInfo(player, WUI_HP)
	_nMyPowerIndex = getPowerIndex(player)
	
	-- find average values first
	_player = 0
	while _player < MAX_PLAYERS do
		if isPlayerStillLive(_player) then
			_nEnUnitsTot = getWeaponUnitsInfo(_player, WUI_TOTUNITS)
			_nEnUnitsPower = getWeaponUnitsInfo(_player, WUI_POWER)
			_nEnUnitsHP = getWeaponUnitsInfo(_player, WUI_HP)
			_nEnPowerIndex = getPowerIndex(_player)
			_nTotUnitsTot = _nTotUnitsTot + _nEnUnitsTot
			_nTotUnitsPower = _nTotUnitsPower + _nEnUnitsPower
			_nTotUnitsHP = _nTotUnitsHP + _nEnUnitsHP
			_nTotPowerIndex = _nTotPowerIndex + _nEnPowerIndex
		end
		_player = _player + 1
	end
	_nAvUnitsTot = _nTotUnitsTot / nPlayersInGame
	_nAvUnitsPower = _nTotUnitsPower / nPlayersInGame
	_nAvUnitsHP = _nTotUnitsHP / nPlayersInGame
	_nAvPowerIndex = _nTotPowerIndex / nPlayersInGame
	
	-- dbg("dbg->getTargetEnemy: pl("& getPlayerName(player) &") avUnTot("& _nAvUnitsTot &") avCost("& _nAvUnitsPower &") avHP("& _nAvUnitsHP &") avPowInd("& _nAvPowerIndex &")",player);
	-- dbg("dbg->getTargetEnemy: pl("& getPlayerName(player) &") myUnTot("& _nMyUnitsTot &") myCost("& _nMyUnitsPower &") myHP("& _nMyUnitsHP &") myPowInd("& _nMyPowerIndex &")",player);
	
	-- search for enemies which are too strong
	_player = 0
	while _player < MAX_PLAYERS do
		if not friendlyPlayer(_player) and isPlayerStillLive(_player) then
			boolResult = true
			if _tempPlayer >= 0 and isHumanPlayer(_tempPlayer) then
				boolResult = false
			end
			if boolResult or _tempPlayer == -1 then
				_nEnUnitsTot = getWeaponUnitsInfo(_player, WUI_TOTUNITS)
				_nEnUnitsPower = getWeaponUnitsInfo(_player, WUI_POWER)
				_nEnUnitsHP = getWeaponUnitsInfo(_player, WUI_HP)
				_nEnPowerIndex = getPowerIndex(_player)
				if _nEnUnitsTot >= 2 * _nAvUnitsTot then
					_tempPlayer = _player
				end
				if _nEnUnitsPower >= 2 * _nAvUnitsPower then
					_tempPlayer = _player
				end
				if _nEnUnitsHP >= 2 * _nAvUnitsHP then
					_tempPlayer = _player
				end
				if _nEnPowerIndex >= 1.4 * _nAvPowerIndex then
					_tempPlayer = _player
				end
			end
		end
		-- endif !friendlyPlayer()
		_player = _player + 1
	end
	
	-- search for enemies which are too weak
	if _tempPlayer == -1 then
		if _dbg then
			printDebug1("getTargetEnemy: pl(" .. getPlayerName(player) .. ") too strong enemy not found")
		end
		_player = 0
		while _player < MAX_PLAYERS do
			if not friendlyPlayer(_player) and isPlayerStillLive(_player) then
				boolResult = true
				if _tempPlayer >= 0 and isHumanPlayer(_tempPlayer) then
					boolResult = false
				end
				if boolResult or _tempPlayer == -1 then
					_nEnUnitsTot = getWeaponUnitsInfo(_player, WUI_TOTUNITS)
					_nEnUnitsPower = getWeaponUnitsInfo(_player, WUI_POWER)
					_nEnUnitsHP = getWeaponUnitsInfo(_player, WUI_HP)
					_nEnPowerIndex = getPowerIndex(_player)
					if 2 * _nEnUnitsTot < _nAvUnitsTot then
						_tempPlayer = _player
					end
					if 2 * _nEnUnitsPower < _nAvUnitsPower then
						_tempPlayer = _player
					end
					if 2 * _nEnUnitsHP < _nAvUnitsHP then
						_tempPlayer = _player
					end
					if 1.5 * _nEnPowerIndex < _nAvPowerIndex then
						_tempPlayer = _player
					end
				end
			end
			-- endif !friendlyPlayer()
			_player = _player + 1
		end
		if _tempPlayer == -1 then
			if _dbg then
				printDebug1("getTargetEnemy: too weak enemy not found")
			end
		else
			if _dbg then
				printDebug1("getTargetEnemy: too weak enemy found: (" .. getPlayerName(_tempPlayer) .. ") isHuman(" .. isHumanPlayer(_tempPlayer) .. ")")
			end
			
			-- check we do not attack weak human player too often! unless this is the strong AI
			if isHumanPlayer(_tempPlayer) and AIstrength < 4 then
				if nAttHumanPlayer > nAttAIPlayer * 2 then
					printDebug1("getTargetEnemy-1/2: too weak human enemy was attacked too often Hum_Pl/AI_Pl (" .. nAttHumanPlayer .. "/" .. nAttAIPlayer .. "), try to changed target to AI player")
					-- get an AI enemy as target, if possible...maybe there are only enemy human players???
					_c2 = random(MAX_PLAYERS)
					_c3 = 0
					boolResult = true
					while _c3 < MAX_PLAYERS and boolResult do
						if not isHumanPlayer(_c2) and isPlayerStillLive(_c2) and not friendlyPlayer(_c2) then
							boolResult = false
							_tempPlayer = _c2
						end
						_c2 = _c2 + 1
						_c3 = _c3 + 1
						if _c2 == 8 then
							_c2 = 0
						end
					end
					if not boolResult then
						printDebug1("getTargetEnemy-2/2: changed target to AI player: (" .. getPlayerName(_tempPlayer) .. ") isHuman(" .. isHumanPlayer(_tempPlayer) .. ")")
					else
						printDebug1("getTargetEnemy-2/2: not able to change target to AI player")
					end
				else
					printDebug1("getTargetEnemy: too weak human enemy was attacked NOT too often Hum_Pl/AI_Pl (" .. nAttHumanPlayer .. "/" .. nAttAIPlayer .. "), DyDo attacks him again!!")
				end
			end
		end
	else
		if _dbg then
			printDebug("getTargetEnemy: pl(" .. getPlayerName(player) .. ") too strong enemy found: (" .. getPlayerName(_tempPlayer) .. ") isHuman(" .. isHumanPlayer(_tempPlayer) .. ")")
		end
	end
	
	return _tempPlayer
end
-- -----------------------------------------------------------------------------
--[[//  TankAttack/CyborgAttack events
//     --> getTargetObj
//         --> getTargetEnemy()
//         --> findEnemyOBJ()
//]]--
function getTargetObj()
	local _nGameType = 0
	local nPerc_HP_Target = 0
	local _tempTargetPlayer = 0
	local _rnd = 0
	local _mustBeHuman = false
	
	_mustBeHuman = false
	nPerc_HP_Target = -1
	
	-- search for primary enemy player target
	-- search for too strong or too weak enemies
	_targetPlayer = getTargetEnemy(false)
	if _targetPlayer >= 0 then
		printDebug1("dbg->getTargetObj: Very strong or weak enemy found:'" .. getPlayerName(_targetPlayer) .. "'")
	end
	
	_nGameType = gameType()
	if _nGameType == GT_4PLAYERS_1HP_2T then
		nPerc_HP_Target = 40 + random(10) + AIstrength * 10
	end
	if _nGameType == GT_4PLAYERS_1HP_34T then
		nPerc_HP_Target = 30 + random(20) + AIstrength * 10
	end
	if _nGameType == GT_4PLAYERS_2HP_2T then
		nPerc_HP_Target = 40 + random(10) + AIstrength * 10
	end
	if _nGameType == GT_4PLAYERS_2HP_34T then
		nPerc_HP_Target = 30 + random(20) + AIstrength * 10
	end
	if _nGameType == GT_8PLAYERS_1HP_23T then
		nPerc_HP_Target = 20 + random(20) + AIstrength * 10
	end
	if _nGameType == GT_8PLAYERS_1HP_4567T then
		nPerc_HP_Target = 15 + random(25) + AIstrength * 10
	end
	if _nGameType == GT_8PLAYERS_2HP_23T then
		nPerc_HP_Target = 25 + random(25) + AIstrength * 10
	end
	if _nGameType == GT_8PLAYERS_2HP_4567T then
		nPerc_HP_Target = 25 + random(20) + AIstrength * 10
	end
	if _nGameType == GT_8PLAYERS_3HP_23T then
		nPerc_HP_Target = 25 + random(20) + AIstrength * 10
	end
	if nPerc_HP_Target == -1 then
		nPerc_HP_Target = 25 + random(20) + AIstrength * 10
	end
	
	-- select the type of target
	_rnd = random(100)
	if _rnd <= nPerc_HP_Target then
		_mustBeHuman = true
	end
	-- dbg("dbg: getTargetObj-> pl("& getPlayerName(player) &") target must be human _rnd/perc("& _rnd &"/"& nPerc_HP_Target &") AIstrength("& AIstrength &")" , player);
	-- else { dbg("dbg: getTargetObj-> pl("& getPlayerName(player) &") target can be human or AI _rnd/perc("& _rnd &"/"& nPerc_HP_Target &") AIstrength("& AIstrength &")" , player);}
	
	-- test or debug game
	if bRunning or not bHasHumanEnemies(player) then
		_mustBeHuman = false
	end
	
	-- check if big map and if derricks are required
	_rnd = random(10)
	if bNeedDerrick or (_rnd < 7 and (C.mapWidth + C.mapHeight) / 2 > BIG_MAP) then
		printDebug1("getTargetObj-> _targetPlayer forced to (" .. -1 .. ") target is derrick, big map or derricks required _rnd(" .. _rnd .. "/7) bNeedDerrick(" .. bNeedDerrick .. ") mapSize(" .. (C.mapWidth + C.mapHeight) / 2 .. ") bigMap(" .. BIG_MAP .. ") _mustBeHuman(" .. _mustBeHuman .. ")")
		attackTankObj = closestEnemyDerrick(_mustBeHuman, -1)
	else
		printDebug1("getTargetObj-> target will not be a derrick; _targetPlayer(" .. _targetPlayer .. ") _rnd(" .. _rnd .. "/7) bNeedDerrick(" .. bNeedDerrick .. ") mapSize(" .. (C.mapWidth + C.mapHeight) / 2 .. ") bigMap(" .. BIG_MAP .. ")")
	end
	
	if attackTankObj == nil then
		printDebug1("getTargetObj-> derrick not found, try with base _targetPlayer(" .. _targetPlayer .. ") _mustBeHuman(" .. _mustBeHuman .. ")")
		attackTankObj = findEnemyOBJ(_mustBeHuman, _targetPlayer)
	end
	-- attackTankObj = findEnemyOBJ(_mustBeHuman);
	
	if attackTankObj ~= nil then
		printDebug1("getTargetObj-> target found: player #(" .. attackTankObj.player .. ") '" .. getPlayerName(attackTankObj.player) .. "' human(" .. isHumanPlayer(attackTankObj.player) .. ") ")
	else
		printDebug1("getTargetObj-> NO target found !")
	end
	return attackTankObj
end

-- -----------------------------------------------------------------------------
function bHasHumanEnemies(_player)
	local _c = 0
	_c = 0
	while _c < MAX_PLAYERS do
		if isHumanPlayer(_c) and not allianceExistsBetween(_player, _c) then
			return true
		end
		_c = _c + 1
	end
	return false
end
-- -----------------------------------------------------------------------------
function getRandomEnemyPlayer(_mustBeHuman)
	local _c2 = 0
	local _c3 = 0
	_c2 = random(MAX_PLAYERS)
	_c3 = 0
	while _c3 < MAX_PLAYERS do
		boolResult = true
		if _mustBeHuman and not isHumanPlayer(_c2) then
			boolResult = false
		end
		if boolResult and not friendlyPlayer(_c2) and isPlayerStillLive(_c2) then
			return _c2
		end
		_c2 = _c2 + 1
		_c3 = _c3 + 1
		if _c2 == 8 then
			_c2 = 0
		end
	end
	return -1
end
-- -----------------------------------------------------------------------------
function getNearestEnemyPlayer(_humanPlayer)
	local _struct = nil
	local _player = 0
	local _targetPlayer = 0
	local _bestDist = 0
	local _dist = 0
	local _ii = 0
	
	_struct = nil
	_player = 0
	_targetPlayer = -1
	_bestDist = 9999999
	
	while _player < MAX_PLAYERS do
		boolResult = true
		if _humanPlayer and not isHumanPlayer(_player) then
			boolResult = false
		end
		if not isPlayerStillLive(_player) then
			boolResult = false
		end
		-- OK
		if not friendlyPlayer(_player) and boolResult then
			_struct = getStructure(playerHQ, _player)
			if _struct == nil then
				_struct = getStructure(factory, _player)
			end
			if _struct == nil then
				_struct = getStructure(cybFactory, _player)
			end
			if _struct == nil then
				_struct = getStructure(resLab, _player)
			end
			if _struct == nil then
				_struct = getStructure(powGen, _player)
			end
			if _struct == nil then
				_struct = getStructure(vtolFactory, _player)
			end
			if _struct == nil then
				_ii = 0
				while _ii < numStructs and _struct == nil do
					_struct = getStructure(structs[_ii], _player)
					_ii = _ii + 1
				end
			end
			if _struct ~= nil then
				_dist = distBetweenTwoPoints(_struct.x, _struct.y, baseX, baseY)
				if _dist < _bestDist then
					_bestDist = _dist
					_targetPlayer = _player
				end
			end
		end
		
		-- player check
		
		_player = _player + 1
	end
	-- while
	return _targetPlayer
end

-- -----------------------------------------------------------------------------
function getEnemy_baseCoord(_player, sCoord)
	local _structure = nil
	local _index = 0
	local _baseX = 0
	local _baseY = 0
	local _numBaseStructs = 0
	-- Go through all structures
	_index = 0
	_numBaseStructs = 0
	_baseX = 0
	_baseY = 0
	-- +1 to exclude derricks!!
	while _index + 1 < numBaseStructs do
		initEnumStruct(false, baseStructs[_index], _player, _player)
		_structure = enumStruct()
		
		while _structure ~= nil do
			_baseX = _baseX + _structure.x / TILE
			_baseY = _baseY + _structure.y / TILE
			_numBaseStructs = _numBaseStructs + 1
			_structure = enumStruct()
		end
		_index = _index + 1
	end
	
	if _numBaseStructs > 0 then
		_baseX = (_baseX / _numBaseStructs) * TILE
		_baseY = (_baseY / _numBaseStructs) * TILE
	else
		_index = 0
		_numBaseStructs = 0
		-- +1 to exclude derricks!!
		while _index + 1 < numBaseStructs do
			_structure = getStructure(baseStructs[_index], _player)
			if _structure ~= nil then
				_baseX = _baseX + _structure.x / TILE
				_baseY = _baseY + _structure.y / TILE
				_numBaseStructs = _numBaseStructs + 1
			end
			_index = _index + 1
		end
		if _numBaseStructs > 0 then
			_baseX = (_baseX / _numBaseStructs) * TILE
			_baseY = (_baseY / _numBaseStructs) * TILE
		else
			printDebug1("#### getEnemy_baseCoord: not able to find any struct for player (" .. _player .. ") ")
			return -1
		end
	end
	
	if sCoord == "X" or sCoord == "x" then
		return _baseX
	else
		return _baseY
	end
	return -1
end

-- -----------------------------------------------------------------------------
function friendlyPlayer(_playerToCheck)
	if allianceExistsBetween(_playerToCheck, player) or (_playerToCheck == player) then
		return true
	end
	
	return false
end
-- -----------------------------------------------------------------------------
function objHumanDerrick(bVTOLTarget, _numDef, _distInTiles)
	local _objTarget = nil
	local _targetPlayer = 0
	local _dist = 0
	local _tmpDist = 0
	local _defences = 0
	local _mapSize = 0
	local _tempDerrick = nil
	
	_targetPlayer = 0
	_objTarget = nil
	_dist = 9999 * TILE
	
	while _targetPlayer < MAX_PLAYERS and _objTarget == nil do
		if _targetPlayer ~= player and not friendlyPlayer(_targetPlayer) and isHumanPlayer(_targetPlayer) then
			initEnumStruct(false, derrick, _targetPlayer, _targetPlayer)
			_tempDerrick = enumStruct()
			while _tempDerrick ~= nil do
				boolResult = true
				if bVTOLTarget then
					_defences = numEnemyAAInRange(_tempDerrick.x, _tempDerrick.y, AA_THREAT_RANGE())
				else
					_defences = numEnemyWeapDroidsInRange(player, _tempDerrick.x, _tempDerrick.y, _distInTiles * TILE, false)
					_defences = _defences + numEnemyWeapStructsInRange(player, _tempDerrick.x, _tempDerrick.y, _distInTiles * TILE, false)
				end
				_tmpDist = distBetweenTwoPoints(baseX, baseY, _tempDerrick.x, _tempDerrick.y)
				if not bVTOLTarget and _tmpDist > ((C.mapWidth * TILE + C.mapHeight * TILE) / 6 * 2) then
					boolResult = false
				end
				if boolResult and _tmpDist < _dist and _defences <= _numDef then
					_objTarget = _tempDerrick
					_dist = _tmpDist
				end
				_tempDerrick = enumStruct()
			end
		end
		
		_targetPlayer = _targetPlayer + 1
	end
	return _objTarget
end
-- -----------------------------------------------------------------------------
function objStrTargetInRange(_xCoord, _yCoord, _Range)
	local _objTarget = nil
	local _x = 0
	local _y = 0
	local _x1 = 0
	local _y1 = 0
	local _xx = 0
	local _yy = 0
	local _targetPlayer = 0
	
	resetStructTargets()
	setStructTarIgnore(ST_WALL)
	setStructTarPref(ST_DEF_GROUND)
	setStructTarPref(ST_FACTORY)
	setStructTarPref(ST_CYBORG_FACTORY)
	setStructTarPref(ST_VTOL_FACTORY)
	setStructTarPref(ST_POWER_GEN)
	-- setStructTarPref(ST_SENSOR);
	setStructTarPref(ST_RESOURCE_EXTRACTOR)
	setStructTarPref(ST_DEF_AIR)
	setStructTarPref(ST_RESEARCH)
	setStructTarPref(ST_HQ)
	setStructTarPref(ST_REARM_PAD)
	setStructTarPref(ST_SENSOR)
	
	_objTarget = nil
	_Range = _Range / 2
	
	_xx = (C.mapWidth * 128) - (128 * 2)
	_yy = (C.mapHeight * 128) - (128 * 2)
	
	_x = math.min(_xCoord + _Range, _xx)
	_y = math.min(_yCoord + _Range, _yy)
	_x1 = math.max(_xCoord - _Range, 256)
	_y1 = math.max(_yCoord - _Range, 256)
	
	_targetPlayer = 0
	while _targetPlayer < MAX_PLAYERS and _objTarget == nil do
		if _targetPlayer ~= player and not friendlyPlayer(_targetPlayer) then
			_objTarget = structTargetInArea(_targetPlayer, player, _x, _y, _x1, _y1)
			if _objTarget ~= nil then
				if distBetweenTwoPoints(_xCoord, _yCoord, _objTarget.x, _objTarget.y) > _Range then
					_objTarget = nil
				end
			end
		end
		_targetPlayer = _targetPlayer + 1
	end
	return _objTarget
end
-- -----------------------------------------------------------------------------
function objDroidTargetInRange(_xCoord, _yCoord, _Range, bIsVTOL)
	local _objTarget = nil
	local _x = 0
	local _y = 0
	local _x1 = 0
	local _y1 = 0
	local _xx = 0
	local _yy = 0
	local _n = 0
	local _bestHitPoints = 0
	
	resetDroidTargets()
	setDroidTarIgnore(ST_WALL)
	if bIsVTOL then
		setDroidTarPref(DT_SUPER_HEAVY)
		setDroidTarPref(DT_HEAVY)
		setDroidTarPref(DT_MEDIUM)
		setDroidTarPref(DT_LIGHT)
		setDroidTarPref(DT_LEGS)
		setDroidTarPref(DT_VTOL)
	else
		setDroidTarPref(DT_SENSOR)
		setDroidTarPref(DT_CONSTRUCT)
		setDroidTarPref(DT_COMMAND)
		setDroidTarPref(DT_REPAIR)
		setDroidTarPref(DT_WEAP_GROUND)
		setDroidTarPref(DT_WEAP_AIR)
		-- Ground,air,idf units
		setDroidTarPref(DT_WEAP_ALL)
	end
	
	_objTarget = nil
	
	_xx = (C.mapWidth * 128) - (128 * 2)
	_yy = (C.mapHeight * 128) - (128 * 2)
	
	_Range = _Range / 2
	
	_x = math.min(_xCoord + _Range, _xx)
	_y = math.min(_yCoord + _Range, _yy)
	_x1 = math.max(_xCoord - _Range, 256)
	_y1 = math.max(_yCoord - _Range, 256)
	
	if bIsVTOL and targetPlayerVTOL > -1 then
		_n = 0
		_bestHitPoints = 0
		initEnumDroids(targetPlayerVTOL, player)
		droid = enumDroid()
		while droid ~= nil do
			if not isVtol(droid) and distBetweenTwoPoints(droid.x, droid.y, _xCoord, _yCoord) < 15 * TILE then
				if numEnemyAAInRange(droid.x, droid.y, AA_THREAT_RANGE()) < 2 then
					if droid.hitPoints > _bestHitPoints then
						_objTarget = droid
						_bestHitPoints = droid.hitPoints
					end
				end
			end
			_n = _n + 1
			droid = enumDroid()
		end
	end
	
	_bestHitPoints = 0
	if _objTarget == nil then
		count = 0
		while count < MAX_PLAYERS and _objTarget == nil do
			if count ~= player and not friendlyPlayer(count) then
				_objTarget = droidTargetInArea(count, player, _x, _y, _x1, _y1)
				if _objTarget ~= nil then
					if not isVtol(objToDroid(_objTarget)) then
						if distBetweenTwoPoints(_xCoord, _yCoord, _objTarget.x, _objTarget.y) > _Range then
							_objTarget = nil
						end
					end
				end
			end
			-- _bestHitPoints  = _objTarget.hitPoints;
			-- }
			count = count + 1
		end
	else
		if bIsVTOL then
			displayMsg("objDroidTargetInRange: ***** best target for VTOL found: Id(" .. _objTarget.id .. ") hitPoints(" .. _objTarget.hitPoints .. ")")
		end
	end
	return _objTarget
end
-- -----------------------------------------------------------------------------
function orderGroupMoveCMD(_grp, _x, _y)
	local _c = 0
	local _tempTruck = nil
	
	_c = 0
	
	initIterateGroup(_grp)
	_tempTruck = iterateGroup(_grp)
	while _tempTruck ~= nil do
		if droidCanReach(_tempTruck, _x, _y) then
			orderDroidLoc(_tempTruck, DORDER_MOVE, _x, _y)
		end
		_tempTruck = iterateGroup(_grp)
		_c = _c + 1
	end
	return
end

-- -----------------------------------------------------------------------------
function orderGroupScoutCMD(_grp, _x, _y)
	local _c = 0
	local _tempTruck = nil
	
	_c = 0
	
	initIterateGroup(_grp)
	_tempTruck = iterateGroup(_grp)
	while _tempTruck ~= nil do
		if distBetweenTwoPoints(_tempTruck.x, _tempTruck.y, _x, _y) > 2 * TILE and droidCanReach(_tempTruck, _x, _y) then
			orderDroidLoc(_tempTruck, DORDER_SCOUT, _x, _y)
		end
		_tempTruck = iterateGroup(_grp)
		_c = _c + 1
	end
	return
end
-- -----------------------------------------------------------------------------
function SetDyDoPersonality(nPersonality, _player)
	local cc = 0
	local _c = 0
	local _nAdd = 0
	local _nAddVTOL = 0
	cc = 0
	
	if _player ~= player then
		return
	end
	
	-- random personality
	_c = nPersonality
	if nPersonality == 0 or nPersonality > 4 then
		if random(100) < 75 then
			_c = 1
		else
			_c = 2 + random(6)
			if _c > 4 then
				if _c == 5 then
					_c = 2
				end
				if _c == 6 then
					_c = 3
				end
				if _c == 7 then
					_c = 4
				end
			end
		end
		AIPersonality = _c
		_c = _c - 1
		nAI_Pers = _c
	else
		AIPersonality = nPersonality
		nPersonality = nPersonality - 1
		nAI_Pers = nPersonality
	end
	
	-- ____________________General 2____________________________
	if AIPersonality == AI_VTOL then
		cc = 0
		while cc < numCheapResGen2[0] do
			researchCheap[0][cc] = general2Cheap[0][cc]
			cc = cc + 1
		end
		cc = 0
		-- Standard Researches
		while cc < numResGen2[0] do
			research[0][cc] = general2[0][cc]
			cc = cc + 1
		end
		cc = 0
		-- Standard Researches
		while cc < numResGen2[1] do
			research[0][cc] = general2[1][cc]
			cc = cc + 1
		end
		cc = 0
		while cc < numResGen2[9] do
			research[9][cc] = general2[9][cc]
			cc = cc + 1
		end
		numRes[0] = numResGen2[0]
		numRes[1] = numResGen2[1]
		numRes[9] = numResGen2[9]
	end
	
	-- ____________________General 3____________________________
	if AIPersonality == AI_TURTLE then
		while cc < numCheapResGen3[0] do
			researchCheap[0][cc] = general3Cheap[0][cc]
			cc = cc + 1
		end
		cc = 0
		-- Standard Researches
		while cc < numResGen3[0] do
			research[0][cc] = general3[0][cc]
			cc = cc + 1
		end
		cc = 0
		-- Standard Researches
		while cc < numResGen3[1] do
			research[0][cc] = general3[1][cc]
			cc = cc + 1
		end
		cc = 0
		while cc < numResGen3[9] do
			research[9][cc] = general3[9][cc]
			cc = cc + 1
		end
		numRes[0] = numResGen3[0]
		numRes[1] = numResGen3[1]
		numRes[9] = numResGen3[9]
	end
	
	-- ____________________General 4____________________________
	if AIPersonality == AI_CYBORG then
		while cc < numCheapResGen4[0] do
			researchCheap[0][cc] = general4Cheap[0][cc]
			cc = cc + 1
		end
		cc = 0
		-- Standard Researches
		while cc < numResGen4[0] do
			research[0][cc] = general4[0][cc]
			cc = cc + 1
		end
		cc = 0
		-- Standard Researches
		while cc < numResGen4[1] do
			research[0][cc] = general4[1][cc]
			cc = cc + 1
		end
		cc = 0
		while cc < numResGen4[9] do
			research[9][cc] = general4[9][cc]
			cc = cc + 1
		end
		numRes[0] = numResGen4[0]
		numRes[1] = numResGen4[1]
		numRes[9] = numResGen4[9]
	end
	
	-- update struct to be built
	count = nDerricksAtStart + (nFreeOilRes / nPlayersInGame)
	printDebug1("derricks/player=(" .. count .. "); initial derricks(" .. nDerricksAtStart .. ") free oilRes (" .. nFreeOilRes .. ") players in game(" .. nPlayersInGame .. ")")
	
	-- determine numb if additinal structs and type of mapPower
	_nAdd = 0
	if count < 4 then
		printDebug1("Build standard quantity of structures -1")
		_nAdd = -1
		_nAddVTOL = -1
		nMapPower = VERY_LOW_POWER_MAP
	else
		if count >= 4 and count < 7 then
			printDebug1("Build standard quantity of structures")
			_nAdd = 0
			_nAddVTOL = 0
			nMapPower = LOW_POWER_MAP
		else
			if count >= 7 and count < 11 then
				printDebug1("Build standard quantity of structures + 1")
				_nAdd = 1
				_nAddVTOL = 0
				nMapPower = NORMAL_POWER_MAP
			else
				if count >= 11 then
					printDebug1("Build standard quantity of structures + 2")
					_nAdd = 2
					_nAddVTOL = 1
					nMapPower = HIGH_POWER_MAP
				end
			end
		end
	end
	
	-- print off standard stats
	count2 = 0
	while count2 < 4 do
		if nAI_Pers == count2 then
			printDebug1(" Standard building: Fact-Res-Cyb-VTOL(" .. structsLimits[count2][STR_TANK_FACTORY] .. "-" .. structsLimits[count2][STR_RESLAB] .. "-" .. structsLimits[count2][STR_CYB_FACTORY] .. "-" .. structsLimits[count2][STR_VTOL_FACTORY] .. ") mapPowerType (" .. nMapPower .. ") _nAdd(" .. _nAdd .. ") _nAddVTOL(" .. _nAddVTOL .. ")")
		end
		count2 = count2 + 1
	end
	
	-- update array
	count2 = 0
	while count2 < 4 do
		structsBuildLimits[count2][STR_TANK_FACTORY] = _nAdd + structsLimits[count2][STR_TANK_FACTORY]
		structsBuildLimits[count2][STR_RESLAB] = _nAdd + structsLimits[count2][STR_RESLAB]
		structsBuildLimits[count2][STR_CYB_FACTORY] = _nAdd + structsLimits[count2][STR_CYB_FACTORY]
		structsBuildLimits[count2][STR_VTOL_FACTORY] = _nAddVTOL + structsLimits[count2][STR_VTOL_FACTORY]
		count2 = count2 + 1
	end
	-- set to 5 if too high.
	count2 = 0
	while count2 < 4 do
		if structsBuildLimits[count2][STR_TANK_FACTORY] > 5 then
			structsBuildLimits[count2][STR_TANK_FACTORY] = 5
		end
		if structsBuildLimits[count2][STR_RESLAB] > 5 then
			structsBuildLimits[count2][STR_RESLAB] = 5
		end
		if structsBuildLimits[count2][STR_CYB_FACTORY] > 5 then
			structsBuildLimits[count2][STR_CYB_FACTORY] = 5
		end
		if structsBuildLimits[count2][STR_VTOL_FACTORY] > 5 then
			structsBuildLimits[count2][STR_VTOL_FACTORY] = 5
		end
		count2 = count2 + 1
	end
	-- set to 1 if less then 1.
	count2 = 0
	while count2 < 4 do
		if structsBuildLimits[count2][STR_TANK_FACTORY] < 1 then
			structsBuildLimits[count2][STR_TANK_FACTORY] = 1
		end
		if structsBuildLimits[count2][STR_RESLAB] < 1 then
			structsBuildLimits[count2][STR_RESLAB] = 1
		end
		if structsBuildLimits[count2][STR_CYB_FACTORY] < 1 then
			structsBuildLimits[count2][STR_CYB_FACTORY] = 1
		end
		if structsBuildLimits[count2][STR_VTOL_FACTORY] < 1 then
			structsBuildLimits[count2][STR_VTOL_FACTORY] = 1
		end
		count2 = count2 + 1
	end
	
	-- print off stats
	count2 = 0
	while count2 < 4 do
		if nAI_Pers == count2 then
			printDebug1(" Selected building: General " .. (count2 + 1) .. " Fact-ResLab-CybFact-VTOLFact = (" .. structsBuildLimits[count2][STR_TANK_FACTORY] .. "-" .. structsBuildLimits[count2][STR_RESLAB] .. "-" .. structsBuildLimits[count2][STR_CYB_FACTORY] .. "-" .. structsBuildLimits[count2][STR_VTOL_FACTORY] .. ") mapPowerType (" .. nMapPower .. ") _nAdd(" .. _nAdd .. ")")
		end
		count2 = count2 + 1
	end
end

-- -----------------------------------------------------------------------------
function aiResponsibleForPlayer(_player)
	if _player == C.selectedPlayer or not myResponsibility(_player) then
		return false
	end
	
	return true
end
-- -----------------------------------------------------------------------------
function _random(x)
	local _c = 0
	local _d = 0
	_c = 0
	while _c < (player + 1) * 2 do
		_d = random(x)
		_c = _c + 1
	end
	return _d
end
-- -----------------------------------------------------------------------------
function assignDroidToGrp(droid)
	if droid == nil then
		return
	end
	if droid.player ~= player then
		return
	end
	
	if droid.droidType == DROID_WEAPON and droid.propulsion ~= cyborgPropulsion then
		groupAddDroid(tankDefGroup, droid)
	end
	
	-- TANK REPAIR
	if droid.droidType == DROID_REPAIR and droid.propulsion ~= cyborgPropulsion then
		groupAddDroid(repairGroup, droid)
	end
	
	-- VTOL/CYBORG/TANK TRUCK
	if droid.droidType == DROID_CONSTRUCT and droid.propulsion ~= cyborgPropulsion then
		groupAddDroid(buildGroup, droid)
	end
	
	-- CYBORG
	if droid.propulsion == cyborgPropulsion then
		if droid.droidType == DROID_CYBORG_CONSTRUCT then
			groupAddDroid(cyborgConstructGroup, droid)
		else
			nTotCyborgBuilt = nTotCyborgBuilt + 1
			if AIPersonality == AI_CYBORG then
				groupAddDroid(cyborgDefGroup, droid)
			else
				if nTotCyborgBuilt > 2 then
					groupAddDroid(tankDefGroup, droid)
					nTotCyborgBuilt = 0
				else
					groupAddDroid(cyborgDefGroup, droid)
				end
			end
		end
	end
	
	-- VTOL
	boolResult = false
	if (isVtol(droid)) and (droid.droidType ~= DROID_CONSTRUCT) then
		groupAddDroid(vtolDefendGr, droid)
	end
	
	-- debug check
	if not hasGroup(droid) then
		groupAddDroid(tankDefGroup, droid)
	end
	
	setDroidSecondary(droid, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER)
	if droid.droidType == DROID_WEAPON or droid.droidType == DROID_CYBORG then
		setDroidSecondary(droid, DSO_HALTTYPE, DSS_HALT_PERSUE)
		setDroidSecondary(droid, DSO_ATTACK_RANGE, DSS_ARANGE_LONG)
		setDroidSecondary(droid, DSO_ATTACK_LEVEL, DSS_ALEV_ALWAYS)
	end
end

function manageVeryLowPower()
	if nProdSelect == 0 then
		if nWorkingLab >= 2 then
			lStopResearch = true
		end
		-- lStopCheapResearch   = true;
		if nWorkingFact >= 2 then
			lStopTankProduction = true
		end
		if nWorkingCybFac >= 2 then
			lStopCybProduction = true
		end
		if nWorkingVTOLFac >= 1 then
			lStopVTOLProduction = true
		end
		lStopBuildDef = true
		lStopBuildDefDerricks = true
		lStopBuildRepFacility = true
		lStopBuildDefGateway = true
	end
	-- ok defences and upgrades
	if nProdSelect == 1 then
		if nWorkingLab >= 1 then
			lStopResearch = true
		end
		-- lStopCheapResearch   = true;
		lStopTankProduction = true
		lStopCybProduction = true
		lStopVTOLProduction = true
		-- lStopBuildDefGateway     = true;
		-- lStopBuildDef            = true;
		-- lStopBuildDefDerricks    = true;
		lStopBuildRepFacility = true
	end
	-- ok units production
	if nProdSelect == 2 then
		lStopResearch = true
		lStopCheapResearch = true
		-- lStopTankProduction      = true;
		-- lStopCybProduction       = true;
		-- lStopVTOLProduction      = true;
		lStopBuildDef = true
		lStopBuildDefDerricks = true
		lStopBuildRepFacility = true
		lStopBuildDefGateway = true
	end
	if nProdSelect == 3 then
		if nWorkingLab >= 1 then
			lStopResearch = true
		end
		lStopCheapResearch = true
		if nWorkingFact >= 1 or nTotTanks > 10 then
			lStopTankProduction = true
		end
		if nWorkingCybFac >= 1 or nTotCyborgs > 10 then
			lStopCybProduction = true
		end
		lStopVTOLProduction = true
		lStopBuildDef = true
		lStopBuildDefDerricks = true
		-- lStopBuildRepFacility    = true;
		lStopBuildDefGateway = true
	end
	-- stop all but cheap researches!!
	if nProdSelect == 4 then
		lStopResearch = true
		-- lStopCheapResearch       = true;
		if nWorkingFact >= 1 or nTotTanks > 10 then
			lStopTankProduction = true
		end
		if nWorkingCybFac >= 1 or nTotCyborgs > 10 then
			lStopCybProduction = true
		end
		lStopVTOLProduction = true
		lStopBuildDef = true
		lStopBuildDefGateway = true
		lStopBuildDefDerricks = true
		lStopBuildRepFacility = true
	end
	-- stop all but researches, def and RepFac
	if nProdSelect == 5 then
		lStopTankProduction = true
		lStopCybProduction = true
		lStopVTOLProduction = true
		-- lStopBuildDef            = true;
		lStopBuildDefDerricks = true
		lStopBuildDefGateway = true
	end
	-- lStopBuildRepFacility    = true;
	-- stop upgrades only
	if nProdSelect == 6 then
		if nWorkingFact >= 1 then
			lStopTankProduction = true
		end
		if nWorkingCybFac >= 1 then
			lStopCybProduction = true
		end
		if nWorkingVTOLFac >= 1 then
			lStopVTOLProduction = true
		end
		if nWorkingLab >= 1 then
			lStopResearch = true
		end
	end
	-- lStopCheapResearch       = true;
	-- lStopBuildDef            = true;
	-- lStopBuildDefGateway     = true;
	-- lStopBuildDefDerricks    = true;
	-- lStopBuildRepFacility    = true;
	-- allow upgrades and researches stop defences and units prod
	if nProdSelect == 7 then
		lStopTankProduction = true
		lStopCybProduction = true
		lStopVTOLProduction = true
		if nWorkingLab >= 2 then
			lStopResearch = true
		end
		lStopCheapResearch = true
		lStopBuildDef = true
		lStopBuildDefGateway = true
		lStopBuildDefDerricks = true
		lStopBuildRepFacility = true
	end
	
	-- activate VTOL production if min droids has been reached
	if groupCountMembers(vtolDefendGr) < MIN_VTOLS and nVTOLFactories > 0 then
		lStopVTOLProduction = false
		if (nTotCyborgs + nTotTanks) > 15 then
			lStopTankProduction = true
			lStopCybProduction = true
		end
	end
end

-- ==================================================
-- Personality General 2
function manageVeryLowPower2()
	if nProdSelect < 3 then
		if groupCountMembers(vtolDefendGr) < MIN_VTOLS_PERS2 and nVTOLFactories > 0 then
			lStopVTOLProduction = false
			lStopTankProduction = true
			lStopCybProduction = true
			lStopResearch = true
			lStopCheapResearch = true
			lStopBuildDef = true
			lStopBuildDefDerricks = true
			lStopBuildRepFacility = false
			lStopBuildDefGateway = true
		else
			if nWorkingVTOLFac >= 2 then
				lStopVTOLProduction = true
			end
			if nWorkingFact >= 0 then
				lStopTankProduction = true
			end
			if nWorkingCybFac >= 0 then
				lStopCybProduction = true
			end
			if nWorkingLab >= 2 then
				lStopResearch = true
			end
			lStopCheapResearch = false
			lStopBuildDef = true
			lStopBuildDefDerricks = true
			lStopBuildRepFacility = true
			lStopBuildDefGateway = true
		end
	end
	
	if nProdSelect >= 3 and nProdSelect < 6 then
		if groupCountMembers(vtolDefendGr) < MIN_VTOLS_PERS2 and nVTOLFactories > 0 then
			lStopVTOLProduction = false
			lStopTankProduction = true
			lStopCybProduction = true
			if nWorkingLab >= 1 then
				lStopResearch = true
			end
			lStopCheapResearch = true
			lStopBuildDef = true
			lStopBuildDefDerricks = true
			lStopBuildRepFacility = true
			lStopBuildDefGateway = true
		else
			if nWorkingVTOLFac >= 1 then
				lStopVTOLProduction = true
			end
			if nWorkingFact >= 2 then
				lStopTankProduction = true
			end
			if nWorkingCybFac >= 2 then
				lStopCybProduction = true
			end
			if nWorkingLab >= 2 then
				lStopResearch = true
			end
			lStopCheapResearch = false
			lStopBuildDef = false
			lStopBuildDefDerricks = false
			lStopBuildRepFacility = false
			lStopBuildDefGateway = false
		end
	end
	
	if nProdSelect >= 6 and nProdSelect < 8 then
		if groupCountMembers(vtolDefendGr) < MIN_VTOLS_PERS2 and nVTOLFactories > 0 then
			lStopVTOLProduction = false
			lStopTankProduction = true
			lStopCybProduction = true
			lStopResearch = true
			lStopCheapResearch = true
			lStopBuildDef = false
			lStopBuildDefDerricks = true
			lStopBuildRepFacility = true
			lStopBuildDefGateway = true
		else
			if nWorkingVTOLFac >= 2 then
				lStopVTOLProduction = true
			end
			if nWorkingFact >= 1 then
				lStopTankProduction = true
			end
			if nWorkingCybFac >= 1 then
				lStopCybProduction = true
			end
			if nWorkingLab >= 0 then
				lStopResearch = true
			end
			lStopCheapResearch = true
			lStopBuildDef = false
			lStopBuildDefDerricks = false
			lStopBuildRepFacility = true
			lStopBuildDefGateway = true
		end
	end
	
	
	if C.gameTime > TIME_START_VTOLRESEARCH then
		if not skVtolEnableCheck(player) then
			if nWorkingLab < 2 then
				lStopResearch = false
			else
				lStopResearch = true
			end
		end
	end
end

-- ==================================================
-- Personality General 3
function manageVeryLowPower3()
	if nProdSelect < 3 then
		if nWorkingVTOLFac >= 0 then
			lStopVTOLProduction = true
		end
		if nWorkingFact >= 1 then
			lStopTankProduction = true
		end
		if nWorkingCybFac >= 1 then
			lStopCybProduction = true
		end
		if nWorkingLab >= 2 then
			lStopResearch = true
		end
		lStopCheapResearch = false
		lStopBuildDef = false
		lStopBuildDefDerricks = true
		lStopBuildRepFacility = true
		lStopBuildDefGateway = false
	end
	if nProdSelect >= 3 and nProdSelect < 6 then
		if nWorkingVTOLFac >= 0 then
			lStopVTOLProduction = true
		end
		if nWorkingFact >= 1 then
			lStopTankProduction = true
		end
		if nWorkingCybFac >= 2 then
			lStopCybProduction = true
		end
		if nWorkingLab >= 2 then
			lStopResearch = true
		end
		lStopCheapResearch = false
		lStopBuildDef = false
		lStopBuildDefDerricks = false
		lStopBuildRepFacility = true
		lStopBuildDefGateway = false
	end
	if nProdSelect >= 6 then
		if nWorkingVTOLFac >= 1 then
			lStopVTOLProduction = true
		end
		if nWorkingFact >= 0 then
			lStopTankProduction = true
		end
		if nWorkingCybFac >= 0 then
			lStopCybProduction = true
		end
		if nWorkingLab >= 4 then
			lStopResearch = true
		end
		lStopCheapResearch = false
		lStopBuildDef = false
		lStopBuildDefDerricks = false
		lStopBuildRepFacility = true
		lStopBuildDefGateway = true
	end
	
	-- stop events
	-- 20 min
	if nTotTanks >= 12 and C.gameTime > 15 * TIME_MINUTE then
		lStopTankProduction = true
	end
	
	-- activate VTOL production if min droids has been reached
	if groupCountMembers(vtolDefendGr) < MIN_VTOLS and nVTOLFactories > 0 and ((nTotCyborgs + nTotTanks) > MIN_TOT_UNITS) then
		lStopVTOLProduction = false
		lStopTankProduction = true
		lStopCybProduction = true
	end
end

-- ==================================================
-- Personality General 4
function manageVeryLowPower4()
	if nProdSelect < 3 then
		if nWorkingVTOLFac >= 1 then
			lStopVTOLProduction = true
		end
		lStopTankProduction = false
		if nWorkingCybFac >= 2 then
			lStopCybProduction = true
		end
		if nWorkingLab >= 3 then
			lStopResearch = true
		end
		lStopCheapResearch = true
		lStopBuildDef = false
		lStopBuildDefDerricks = true
		lStopBuildRepFacility = true
		lStopBuildDefGateway = true
	end
	if nProdSelect >= 3 and nProdSelect < 6 then
		if nWorkingVTOLFac >= 0 then
			lStopVTOLProduction = true
		end
		lStopTankProduction = false
		if nWorkingCybFac >= 3 then
			lStopCybProduction = true
		end
		if nWorkingLab >= 2 then
			lStopResearch = true
		end
		lStopCheapResearch = false
		lStopBuildDef = false
		lStopBuildDefDerricks = false
		lStopBuildRepFacility = false
		lStopBuildDefGateway = false
	end
	if nProdSelect >= 6 then
		if nWorkingVTOLFac >= 0 then
			lStopVTOLProduction = true
		end
		lStopTankProduction = false
		lStopCybProduction = false
		if nWorkingLab >= 1 then
			lStopResearch = true
		end
		lStopCheapResearch = false
		lStopBuildDef = true
		lStopBuildDefDerricks = true
		lStopBuildRepFacility = true
		lStopBuildDefGateway = true
	end
	
	-- activate VTOL production if min droids has been reached
	if groupCountMembers(vtolDefendGr) < MIN_VTOLS and nVTOLFactories > 0 and ((nTotCyborgs + nTotTanks) > MIN_TOT_UNITS) then
		lStopVTOLProduction = false
		lStopTankProduction = true
		lStopCybProduction = true
	end
end


-- -----------------------------------------------------------------------------
function getVTOLstructTarget()
	local _player = 0
	local _aa = 0
	local _bestAA = 0
	local _ii = 0
	local _struct = nil
	local _structTarget = nil
	
	_structTarget = nil
	
	-- search for enemy def structs not protected by AA
	-- ------------ attack def structs or AA def ----------------
	if _random(10) < 6 then
		if _random(10) < 5 then
			_aa = 0
			_bestAA = 999
			_ii = 0
			while _ii < numDefStructs do
				_struct = getStructure(defStructs[_ii], targetPlayerVTOL)
				if _struct ~= nil then
					_aa = numEnemyAAInRange(_struct.x, _struct.y, AA_THREAT_RANGE())
					if _aa < _bestAA then
						_bestAA = _aa
						_structTarget = _struct
					end
				end
				_ii = _ii + 1
			end
			_aa = 0
			_bestAA = 999
			_ii = 0
			while _ii < numWallWeaps do
				_struct = getStructure(wallWeaps[_ii], targetPlayerVTOL)
				if _struct ~= nil then
					_aa = numEnemyAAInRange(_struct.x, _struct.y, AA_THREAT_RANGE())
					if _aa < _bestAA then
						_bestAA = _aa
						_structTarget = _struct
					end
				end
				_ii = _ii + 1
			end
		else
			_aa = 0
			_bestAA = 999
			_ii = 0
			while _ii < numGenAA do
				_struct = getStructure(vtolGenStruct[_ii], targetPlayerVTOL)
				if _struct ~= nil then
					_aa = numEnemyAAInRange(_struct.x, _struct.y, AA_THREAT_RANGE())
					if _aa < _bestAA then
						_bestAA = _aa
						_structTarget = _struct
					end
				end
				-- displayMsg("_________ getVTOLstructTarget AA ("& _struct.id &")("& _aa &")__________");
				_ii = _ii + 1
			end
		end
	else
		_aa = 0
		_bestAA = 999
		_ii = 0
		while _ii < numStructs do
			_struct = getStructure(structs[_ii], targetPlayerVTOL)
			if _struct ~= nil then
				_aa = numEnemyAAInRange(_struct.x, _struct.y, AA_THREAT_RANGE())
				if _aa < _bestAA then
					_bestAA = _aa
					_structTarget = _struct
				end
			end
			_ii = _ii + 1
		end
		if _structTarget == nil or _bestAA * 3 > groupCountMembers(vtolDefendGr) then
			_aa = 0
			_bestAA = 999
			_ii = 0
			while _ii < numWallWeaps do
				_struct = getStructure(wallWeaps[_ii], targetPlayerVTOL)
				if _struct ~= nil then
					_aa = numEnemyAAInRange(_struct.x, _struct.y, AA_THREAT_RANGE())
					if _aa < _bestAA then
						_bestAA = _aa
						_structTarget = _struct
					end
				end
				_ii = _ii + 1
			end
		end
		if _structTarget == nil or _bestAA * 2 > groupCountMembers(vtolDefendGr) then
			_aa = 0
			_bestAA = 999
			_ii = 0
			while _ii < numDefStructs do
				_struct = getStructure(defStructs[_ii], targetPlayerVTOL)
				if _struct ~= nil then
					_aa = numEnemyAAInRange(_struct.x, _struct.y, AA_THREAT_RANGE())
					if _aa < _bestAA then
						_bestAA = _aa
						_structTarget = _struct
					end
				end
				_ii = _ii + 1
			end
		end
	end
	return _structTarget
end

-- -----------------------------------------------------------------------------
function numEnemyAAInRange(_x, _y, _range)
	local _enemy = 0
	local _numAA = 0
	
	_numAA = 0
	_enemy = 0
	while _enemy < MAX_PLAYERS do
		if not friendlyPlayer(_enemy) then
			_numAA = _numAA + numAAinRange(_enemy, player, _x, _y, _range)
		end
		_enemy = _enemy + 1
	end
	
	return _numAA
end
-- -----------------------------------------------------------------------------
function updatePlayersStats()
	local _player = 0
	local _range = 0
	local _temp = 0
	local _nFact = 0
	local _nCybFact = 0
	local _nVTOLFact = 0
	local _c2 = 0
	local _c3 = 0
	
	_range = math.max(C.mapWidth, C.mapHeight) * TILE * 2
	
	nPlayersInGame = 0
	nEnemyPlayers = 0
	nHumanPlayers = 0
	nLastEnemyPlayer = -1
	_c2 = 0
	_c3 = 0
	while _c2 < MAX_PLAYERS do
		if isPlayerStillLive(_c2) then
			if isHumanPlayer(_c2) then
				nHumanPlayers = nHumanPlayers + 1
			end
			
			nPlayersInGame = nPlayersInGame + 1
			if not friendlyPlayer(_c2) then
				nEnemyPlayers = nEnemyPlayers + 1
				nLastEnemyPlayer = _c2
			end
			aPlayers[PLAYER_NUMBER][_c3] = _c2
			_c3 = _c3 + 1
		end
		_c2 = _c2 + 1
	end
	
	-- reset teams, just in case alliances changed.
	count = 0
	while count < MAX_PLAYERS do
		aPlayers[TEAM_NUMBER][count] = -1
		count = count + 1
	end
	
	count = 0
	_c2 = 0
	nTeam = 0
	while count < MAX_PLAYERS do
		if aPlayers[TEAM_NUMBER][count] < 0 and isPlayerStillLive(count) then
			nTeam = nTeam + 1
			aPlayers[TEAM_NUMBER][count] = nTeam
			
			-- loop
			_c2 = 0
			while _c2 < MAX_PLAYERS do
				if allianceExistsBetween(count, _c2) and count ~= _c2 and isPlayerStillLive(_c2) then
					if aPlayers[TEAM_NUMBER][_c2] < 0 then
						aPlayers[TEAM_NUMBER][_c2] = aPlayers[TEAM_NUMBER][count]
					end
				end
				_c2 = _c2 + 1
			end
		end
		count = count + 1
	end
	
	_player = 0
	while _player < MAX_PLAYERS do
		if isPlayerStillLive(_player) then
			aStat[OC_DERRICKS][_player] = getNumDerricks(_player)
			aStat[OC_RESLABS][_player] = numStructsByType(resLab, _player)
			aStat[OC_CYBORGS][_player] = getDroidsInfo(_player, 0)
			aStat[OC_TANKS][_player] = getDroidsInfo(_player, 1)
			aStat[OC_VTOLS][_player] = getDroidsInfo(_player, 2)
			aStat[OC_CYB_POWER][_player] = getDroidsInfo(_player, 3)
			aStat[OC_TK_POWER][_player] = getDroidsInfo(_player, 4)
			aStat[OC_VTOL_POWER][_player] = getDroidsInfo(_player, 5)
			aStat[OC_CYB_HP][_player] = getDroidsInfo(_player, 6)
			aStat[OC_TK_HP][_player] = getDroidsInfo(_player, 7)
			aStat[OC_VTOL_HP][_player] = getDroidsInfo(_player, 8)
		end
		_player = _player + 1
	end
end


-- -----------------------------------------------------------------------------
-- not used
function getTeamNumber(_player)
	return aPlayers[TEAM_NUMBER][_player]
end
-- -----------------------------------------------------------------------------
function getDroidsInfo(_player, _choice)
	local _droid = nil
	local _grp[8] = Group()
	local _cyb = 0
	local _tk = 0
	local _vtol = 0
	local _powCYB = 0
	local _powTK = 0
	local _powVTOL = 0
	local _hpCYB = 0
	local _hpTK = 0
	local _hpVTOL = 0
	
	_tk = 0
	_cyb = 0
	_vtol = 0
	_powCYB = 0
	_powTK = 0
	_powVTOL = 0
	_hpCYB = 0
	_hpTK = 0
	_hpVTOL = 0
	
	initEnumDroids(_player, _player)
	_droid = enumDroid()
	while _droid ~= nil do
		if _droid.droidType == DROID_WEAPON and _droid.propulsion ~= cyborgPropulsion then
			_powTK = _powTK + calcDroidPower(_droid)
			_hpTK = _hpTK + _droid.hitPoints
			_tk = _tk + 1
		end
		if _droid.droidType == DROID_CYBORG then
			_powCYB = _powCYB + calcDroidPower(_droid)
			_hpCYB = _hpCYB + _droid.hitPoints
			_cyb = _cyb + 1
		end
		if isVtol(_droid) then
			_powVTOL = _powVTOL + calcDroidPower(_droid)
			_hpVTOL = _hpVTOL + _droid.hitPoints
			_vtol = _vtol + 1
		end
		-- power cost
		_droid = enumDroid()
	end
	
	if _choice == 0 then
		return _cyb
	end
	if _choice == 1 then
		return _tk
	end
	if _choice == 2 then
		return _vtol
	end
	if _choice == 3 then
		return _powCYB
	end
	if _choice == 4 then
		return _powTK
	end
	if _choice == 5 then
		return _powVTOL
	end
	if _choice == 6 then
		return _hpCYB
	end
	if _choice == 7 then
		return _hpTK
	end
	if _choice == 8 then
		return _hpVTOL
	end
	return -1
end

-- -----------------------------------------
function deactivateHelp()
	nAllyBeingHelped = -1
	tHelpAction = -1
	nHelpX = -1
	nHelpY = -1
	lastHelpPlayer = -1
	objTargetHelpTeam = nil
	if groupCountMembers(helpGroup) > 0 then
		if AIPersonality == AI_CYBORG then
			groupAddGroup(cyborgDefGroup, helpGroup)
			orderGroup(cyborgDefGroup, DORDER_RTB)
		else
			groupAddGroup(tankDefGroup, helpGroup)
			orderGroup(tankDefGroup, DORDER_RTB)
		end
	end
	deactivateEvent(manageHelpTeam)
end
-- -----------------------------------------------------------------------------
function bHelpingAnyAlly()
	if nAllyBeingHelped == -1 then
		return false
	end
	return true
end
-- -----------------------------------------------------------------------------
function canHelpAlly(_sender)
	local _tank = 0
	local _cyb = 0
	
	_tank = groupCountMembers(tankDefGroup) - minDefDroids[nAI_Pers][MINDEF_TANKS]
	_cyb = groupCountMembers(cyborgDefGroup) - minDefDroids[nAI_Pers][MINDEF_CYBORGS]
	
	dbg("dbg->canHelpAlly: Player (" .. getPlayerName(player) .. ") has tk (" .. _tank .. ") and cyb (" .. _cyb .. ") availabe for help, alert (" .. alertIsOn .. ") alertLevel (" .. alertLevel .. ") _sender(" .. _sender .. ") lastHelpPlayer(" .. lastHelpPlayer .. ")", player)
	
	if lastHelpPlayer ~= _sender and lastHelpPlayer ~= -1 then
		return false
	end
	if alertLevel == RED_ALERT then
		return false
	end
	if _tank + _cyb < MIN_HELPING_UNITS then
		return false
	end
	return true
end

-- -----------------------------------------------------------------------------
function helpAlly(_ally)
	local _tank = 0
	local _cyb = 0
	
	_tank = groupCountMembers(tankDefGroup) - minDefDroids[nAI_Pers][MINDEF_TANKS]
	_cyb = groupCountMembers(cyborgDefGroup) - minDefDroids[nAI_Pers][MINDEF_CYBORGS]
	
	printDebug1("helpAlly: has tk(" .. groupCountMembers(tankDefGroup) .. "/" .. _tank .. ") cyb(" .. groupCountMembers(cyborgDefGroup) .. "/" .. _cyb .. ") availabe for help, alert (" .. alertIsOn .. ") alertLevel (" .. alertLevel .. ")")
	if _tank > MAX_HELPING_UNITS then
		_tank = MAX_HELPING_UNITS
	end
	if _cyb > MAX_HELPING_UNITS then
		_cyb = MAX_HELPING_UNITS
	end
	
	moveUnitsBetweenGRPs(helpGroup, tankDefGroup, _tank, true)
	moveUnitsBetweenGRPs(helpGroup, cyborgDefGroup, _cyb, false)
	
	tLastHelp = C.gameTime
	nHelpX = beaconX[_ally]
	nHelpY = beaconY[_ally]
	nAllyBeingHelped = _ally
	
	-- helping droids never repair themselves
	initIterateGroup(helpGroup)
	droid = iterateGroup(helpGroup)
	while droid ~= nil do
		setDroidSecondary(droid, DSO_REPAIR_LEVEL, DSS_REPLEV_NEVER)
		droid = iterateGroup(helpGroup)
	end
	
	msg("Sending " .. groupCountMembers(helpGroup) .. " units to beacon point coord: " .. (nHelpX / TILE) .. "-" .. (nHelpY / TILE), player, _ally)
	printDebug1("helpAlly: Sending " .. groupCountMembers(helpGroup) .. " units to beacon point coord: " .. (nHelpX / TILE) .. "-" .. (nHelpY / TILE) .. " helping (" .. getPlayerName(_ally) .. ")")
	
	orderGroupMoveCMD(helpGroup, nHelpX, nHelpY)
	repeatingEvent(manageHelpTeam, 3.0)
end


-- ======================================================================
--
-- DyDo Communcation Functions & Events
--
-- ======================================================================
-- (CALL_CONSOLE, ref sender, ref message);
function consoleEv(_sender, _message)
	sender, message = _sender, _message -- wz2lua: probably these can be used as function arguments directly
	if (sender ~= player) and (message == "are you dydo?" or message == "are you DyDo?" or message == "who are you?") then
		if allianceExistsBetween(_sender, player) then
			msg("I am (" .. DYDOBP_RELEASE .. "), player " .. player .. ", General " .. AIPersonality .. " [" .. AIstrength .. "] (ally)", player, sender)
		else
			msg("I am (" .. DYDOBP_RELEASE .. "), player " .. player .. ", General " .. AIPersonality .. " [" .. AIstrength .. "] (enemy)", player, sender)
		end
	end
	
	if message == "/debug0 on" and player == 0 then
		msg("Debug turned on", player, sender)
		dbgMsgOn(player, true)
	end
	
	if message == "/debug1 on" and player == 1 then
		msg("Debug turned on", player, sender)
		dbgMsgOn(player, true)
	end
	
	if message == "/debug2 on" and player == 2 then
		msg("Debug turned on", player, sender)
		dbgMsgOn(player, true)
	end
	
	if message == "/debug3 on" and player == 3 then
		msg("Debug turned on", player, sender)
		dbgMsgOn(player, true)
	end
	
	if message == "/debug on" then
		msg("Debug turned on", player, sender)
		dbgMsgOn(player, true)
	end
	
	if message == "/debug off" then
		msg("Debug turned off", player, sender)
		dbgMsgOn(player, false)
	end
	
	if message == "/stats" then
		count = getTargetEnemy(false)
	end
	
	if message == "/stats1" then
		displayStats(1)
	end
	
	if message == "/stats2" then
		displayStats(2)
	end
	
	if message == "/stats3" then
		displayStats(3)
	end
	
	if C.gameTime < 2 * TIME_MINUTE then
		if message == "/set dydo gen1" then
			SetDyDoPersonality(AI_STANDARD, player)
			console(getPlayerName(player) .. " is now DyDo Standard AI")
		end
		if message == "/set dydo gen2" then
			SetDyDoPersonality(AI_VTOL, player)
			console(getPlayerName(player) .. " is now DyDo VTOL AI")
		end
		if message == "/set dydo gen3" then
			SetDyDoPersonality(AI_TURTLE, player)
			console(getPlayerName(player) .. " is now DyDo Turtle AI")
		end
		if message == "/set dydo gen4" then
			SetDyDoPersonality(AI_CYBORG, player)
			console(getPlayerName(player) .. " is now DyDo Cyborg AI")
		end
		if message == "/set dydo random" then
			SetDyDoPersonality(0, player)
			console(getPlayerName(player) .. " is now DyDo random AI")
		end
		
		if message == "/set player0 gen1" then
			SetDyDoPersonality(AI_STANDARD, 0)
			if player == 3 then
				console(getPlayerName(0) .. " is now DyDo Standard AI")
			end
		end
		if message == "/set player1 gen1" then
			SetDyDoPersonality(AI_STANDARD, 1)
			if player == 3 then
				console(getPlayerName(1) .. " is now DyDo Standard AI")
			end
		end
		if message == "/set player2 gen1" then
			SetDyDoPersonality(AI_STANDARD, 2)
			if player == 3 then
				console(getPlayerName(2) .. " is now DyDo Standard AI")
			end
		end
		if message == "/set player3 gen1" then
			SetDyDoPersonality(AI_STANDARD, 3)
			if player == 3 then
				console(getPlayerName(3) .. " is now DyDo Standard AI")
			end
		end
		
		if message == "/set player0 gen2" then
			SetDyDoPersonality(AI_VTOL, 0)
			if player == 0 then
				console(getPlayerName(0) .. " is now DyDo VTOL AI")
			end
		end
		if message == "/set player1 gen2" then
			SetDyDoPersonality(AI_VTOL, 1)
			if player == 1 then
				console(getPlayerName(1) .. " is now DyDo VTOL AI")
			end
		end
		if message == "/set player2 gen2" then
			SetDyDoPersonality(AI_VTOL, 2)
			if player == 2 then
				console(getPlayerName(2) .. " is now DyDo VTOL AI")
			end
		end
		if message == "/set player3 gen2" then
			SetDyDoPersonality(AI_VTOL, 3)
			if player == 3 then
				console(getPlayerName(3) .. " is now DyDo VTOL AI")
			end
		end
		
		if message == "/set player0 gen3" then
			SetDyDoPersonality(AI_TURTLE, 0)
			if player == 0 then
				console(getPlayerName(0) .. " is now DyDo Turtle AI")
			end
		end
		if message == "/set player1 gen3" then
			SetDyDoPersonality(AI_TURTLE, 1)
			if player == 1 then
				console(getPlayerName(1) .. " is now DyDo Turtle AI")
			end
		end
		if message == "/set player2 gen3" then
			SetDyDoPersonality(AI_TURTLE, 2)
			if player == 2 then
				console(getPlayerName(2) .. " is now DyDo Turtle AI")
			end
		end
		if message == "/set player3 gen3" then
			SetDyDoPersonality(AI_TURTLE, 3)
			if player == 3 then
				console(getPlayerName(3) .. " is now DyDo Turtle AI")
			end
		end
		
		if message == "/set player0 gen4" then
			SetDyDoPersonality(AI_CYBORG, 0)
			if player == 0 then
				console(getPlayerName(0) .. " is now DyDo Cyborg AI")
			end
		end
		if message == "/set player1 gen4" then
			SetDyDoPersonality(AI_CYBORG, 1)
			if player == 1 then
				console(getPlayerName(1) .. " is now DyDo Cyborg AI")
			end
		end
		if message == "/set player2 gen4" then
			SetDyDoPersonality(AI_CYBORG, 2)
			if player == 2 then
				console(getPlayerName(2) .. " is now DyDo Cyborg AI")
			end
		end
		if message == "/set player3 gen4" then
			SetDyDoPersonality(AI_CYBORG, 3)
			if player == 3 then
				console(getPlayerName(3) .. " is now DyDo Cyborg AI")
			end
		end
	end
	
	if message == "/autogame on" and (sender == player) then
		if myResponsibility(player) then
			if not bRunning then
				console(getPlayerName(player) .. " is now active")
				bRunning = true
				activateAI()
			end
		end
	end
	
	if message == "/autogame off" and (sender == player) then
		if myResponsibility(player) then
			if bRunning then
				console(getPlayerName(player) .. " AI has been deactivated")
				bRunning = false
				shutDownThisAI()
			end
		end
	end
end
callbackEvent(consoleEv, CALL_CONSOLE)

-- ========================================================================
-- Deal with beacons
-- (CALL_BEACON, player, ref sender, ref x, ref y, ref message);
function beaconEv(_player, _sender, _x, _y, _message)
	if _player ~= player then return end
	sender, x, y, message = _sender, _x, _y, _message -- wz2lua: probably these can be used as function arguments directly
	local _players = 0
	local _processedString = nil
	
	--[[if( !aiResponsibleForPlayer(player) )
		{
			setEventTrigger(beaconEv, inactive);
		}
		else
		{]]--
	ASSERT(sender >= 0 and sender < 8, "beaconEv: sender out of bounds: " .. sender, player)
	
	updateBeacons()
	
	beaconX[sender] = x
	beaconY[sender] = y
	tBeacon[sender] = C.gameTime / 10
	
	processCommand(message, sender, true)
end
callbackEvent(beaconEv, CALL_BEACON)
-- }

-- -----------------------------------------------------------------------------
function haveAnyBeacon()
	local _c = 0
	_c = 0
	while _c < MAX_PLAYERS do
		if (tBeacon[_c] > 0) and (not beaconTimeout(_c)) then
			return true
		end
		_c = _c + 1
	end
	
	return false
end
-- -----------------------------------------------------------------------------
function haveBeacon(_player)
	if (tBeacon[_player] > 0) and (not beaconTimeout(_player)) then
		return true
	end
	
	return false
end
-- -----------------------------------------------------------------------------
function beaconTimeout(_player)
	if (tBeacon[_player] > 0) and ((tBeacon[_player] + tBeaconTimeout) < GAME_TIME_IN_SECS()) then
		return true
	end
	
	return false
end
-- -----------------------------------------------------------------------------
function updateBeacons()
	local _c = 0
	_c = 0
	while _c < MAX_PLAYERS do
		if beaconTimeout(_c) then
			tBeacon[_c] = -1
			beaconX[_c] = -1
			beaconY[_c] = -1
		end
		_c = _c + 1
	end
end
-- -----------------------------------------------------------------------------
-- Deal with a chat message
-- (CALL_AI_MSG, player, ref sender, ref message);
function multiMsgEv(_player, _sender, _message)
	if _player ~= player then return end
	sender, message = _sender, _message -- wz2lua: probably these can be used as function arguments directly
	if sender == player or not allianceExistsBetween(sender, player) then
		return
	end
	processCommand(message, sender, false)
end
callbackEvent(multiMsgEv, CALL_AI_MSG)
-- }
-- -----------------------------------------------------------------------------
function processCommand(_message, _sender, _bBlipMessage)
	local _numMsgs = 0
	local _curMsg = 0
	local _addressedPlayers = 0
	local _x = 0
	local _y = 0
	local _player = 0
	local _msg = nil
	local _processedString = nil
	local _enWeap = 0
	local _myWeap = 0
	local _myWeapSTR = 0
	local _enemyCost = 0
	local _friendCost = 0
	local _tDG = 0
	local _bg = 0
	local _hg = 0
	local _cAt = 0
	local _tg = 0
	local _bdg = 0
	local _cG = 0
	local _ccG = 0
	local _rg = 0
	local _HelpG = 0
	local _strTeams = nil
	local _sWallDef = nil
	local _sDef = nil
	local _sRes = nil
	local _sRes2 = nil
	local _str0 = nil
	local _str1 = nil
	local _str2 = nil
	local _str3 = nil
	local _str4 = nil
	
	-- Extract semantic information
	_curMsg = 0
	_numMsgs = processChatMsg(_message)
	
	-- boolResult=false;
	-- dbg("processCommand A: player("& getPlayerName(player) &") num messages("& _numMsgs &") _message(" & _message & ") from " & _sender, player);
	
	-- if (_message == "/debug_on" or _message == "/debug_on_player0" and player == 0 or   _message == "/debug_on_player1" and player == 1 or   _message == "/debug_on_player2" and player == 2 or   _message == "/debug_on_player3" and player == 3 or   _message == "/debug_on_player4" and player == 4 or _message == "/debug_on_player5" and player == 5 or _message == "/debug_on_player6" and player == 6 or _message == "/debug_on_player7" and player == 7  )
	
	if not allianceExistsBetween(_sender, player) then
		return
	end
	
	while _curMsg < _numMsgs do
		if chatCmdIsPlayerAddressed(_curMsg, player) then
			if _message == "stop" or _message == "Stop" then
				_msg = "xxx"
			else
				_msg = getChatCmdDescription(_curMsg)
			end
			
			-- dbg("Player ("& player &") addressed with : ("& _msg &")", player);
			-- go
			if _msg == "help" or _msg == "help me" or _msg == "go!" or _msg == "go" then
				boolResult = true
				if not haveBeacon(_sender) then
					msg("Drop a beacon please (Alt+H), I need to know where to send the units", player, _sender)
					return
				else
					if nAllyBeingHelped == -1 then
						if canHelpAlly(_sender) then
							lastHelpPlayer = _sender
							-- dbg("dbg: Ally can help", _sender);
							helpAlly(_sender)
						else
							msg("I am sorry. I have no enough units to send or I am in trouble", player, _sender)
						end
					else
						if nAllyBeingHelped == _sender then
							msg(getPlayerName(nAllyBeingHelped) .. ", I am coming!", player, _sender)
						else
							msg("I am sorry but I am already helping player # " .. nAllyBeingHelped .. " (" .. getPlayerName(nAllyBeingHelped) .. " colour)", player, _sender)
						end
					end
				end
			else
				
				if _msg == "status?" or _msg == "Status?" or _msg == "status" then
					boolResult = true
					-- dbg("Got a status request :" & _msg, _sender );
					notifyStatus(1, _sender)
				else
					
					if _msg == "xxx" then
						boolResult = true
						if not bHelpingAnyAlly() then
							msg("There is nothing to stop!", player, _sender)
						else
							if nAllyBeingHelped == _sender then
								deactivateHelp()
								msg("Action deactivated!", player, _sender)
							end
						end
					else
						
						if _msg == "power?" or _msg == "power" then
							boolResult = true
							msg("I have (" .. playerPower(player) .. ") power available", player, _sender)
						else
							
							if _msg == "/status" then
								count = (groupCountMembers(tankDefGroup) - minDefDroids[nAI_Pers][MINDEF_TANKS]) + (groupCountMembers(cyborgDefGroup) - minDefDroids[nAI_Pers][MINDEF_CYBORGS]) - MIN_HELPING_UNITS
								msg("Have a Beacon(" .. haveAnyBeacon() .. ") Player Helped(" .. nAllyBeingHelped .. ") Helping Droids(" .. groupCountMembers(helpGroup) .. ") Help Countdown(" .. count .. "/" .. MIN_HELPING_UNITS .. ")", player, _sender)
								_enWeap = numEnemyWeapDroidsInRange(player, baseX, baseY, nDefendRange, false)
								_myWeap = numPlayerWeapDroidsInRange(player, player, baseX, baseY, nDefendRange, true)
								_myWeapSTR = numFriendlyWeapStructsInRange(player, baseX, baseY, nDefendRange, true)
								_enemyCost = enemyWeapObjCostInRange(player, baseX, baseY, nDefendRange, false, true)
								_friendCost = friendlyWeapObjCostInRange(player, baseX, baseY, nDefendRange, false, true)
								msg("Defend Range: _enWeap (" .. _enWeap .. ") _myWeap (" .. _myWeap .. ") _myWeapSTR (" .. _myWeapSTR .. ") _enemyCost(" .. _enemyCost .. ") _friendCost(" .. _friendCost .. ")", player, _sender)
								_enWeap = numEnemyWeapDroidsInRange(player, baseX, baseY, nBaseRange, false)
								_myWeap = numPlayerWeapDroidsInRange(player, player, baseX, baseY, nBaseRange, true)
								_myWeapSTR = numFriendlyWeapStructsInRange(player, baseX, baseY, nBaseRange, true)
								_enemyCost = enemyWeapObjCostInRange(player, baseX, baseY, nBaseRange, false, true)
								_friendCost = friendlyWeapObjCostInRange(player, baseX, baseY, nBaseRange, false, true)
								msg("Base Range: _enWeap (" .. _enWeap .. ") _myWeap (" .. _myWeap .. ") _myWeapSTR (" .. _myWeapSTR .. ") _enemyCost(" .. _enemyCost .. ") _friendCost(" .. _friendCost .. ")", player, _sender)
								_bg = groupCountMembers(buildGroup)
								_hg = groupCountMembers(harvesterGroup)
								_rg = groupCountMembers(repairGroup)
								_tg = groupCountMembers(tankGroup)
								_bdg = groupCountMembers(buildDefGroup)
								_ccG = groupCountMembers(cyborgConstructGroup)
								_cG = groupCountMembers(cyborgDefGroup)
								_tDG = groupCountMembers(tankDefGroup)
								_cAt = groupCountMembers(cyborgAttGroup)
								_HelpG = groupCountMembers(helpGroup)
								msg(" build(" .. _bg .. "), harv(" .. _hg .. "), buildDef(" .. _bdg .. "), cybConst(" .. _ccG .. "), repair(" .. _rg .. "), tkDef(" .. _tDG .. "), tkAttack(" .. _tg .. "), cybDef(" .. _cG .. "), cybAtt(" .. _cAt .. "), help(" .. _HelpG .. ") ", player, _sender)
								
								count = 0
								while count < numWallWeaps do
									_sWallDef = _sWallDef .. " [" .. count .. "](" .. isStructureAvailable(wallWeaps[count], player) .. ") "
									count = count + 1
								end
								count = 0
								while count < numDefStructs do
									_sDef = _sDef .. " [" .. count .. "](" .. isStructureAvailable(defStructs[count], player) .. ") "
									count = count + 1
								end
								count = 0
								while count < 20 do
									_str0 = _str0 .. " [" .. count .. "]" .. numResearchLeft(player, research[0][count]) .. " "
									count = count + 1
								end
								while count < 40 do
									_str1 = _str1 .. " [" .. count .. "]" .. numResearchLeft(player, research[0][count]) .. " "
									count = count + 1
								end
								-- displayMsg("________ (3) _________");
								while count < 60 do
									_str2 = _str2 .. " [" .. count .. "]" .. numResearchLeft(player, research[0][count]) .. " "
									count = count + 1
								end
								
								count = 0
								while count < numCheapRes[0] do
									_sRes2 = _sRes2 .. " [" .. count .. "]" .. numResearchLeft(player, researchCheap[0][count]) .. " "
									count = count + 1
								end
								
								count = 0
								while count < numRes[9] do
									_str4 = _str4 .. " [" .. count .. "]" .. numResearchLeft(player, research[9][count]) .. " "
									count = count + 1
								end
								count = 0
								while count < MAX_PLAYERS do
									if isPlayerStillLive(count) then
										_strTeams = _strTeams .. " " .. getPlayerName(count) .. " (" .. count .. ") [" .. aPlayers[TEAM_NUMBER][count] .. "] "
									end
									count = count + 1
								end
								msg("STDdef:   (" .. pickDefQueueDepth .. ") - " .. _sDef, player, _sender)
								msg("WALLdef: (" .. pickWallDefQueueDepth .. ") - " .. _sWallDef, player, _sender)
								msg("A: " .. _str0, player, _sender)
								msg("B: " .. _str1, player, _sender)
								msg("C: " .. _str2, player, _sender)
								msg("Cheap:  TOT:" .. numCheapRes[0] .. " " .. _sRes2, player, _sender)
								msg("VTOL: VTOL_PAD(" .. numResearchLeft(player, research[9][0]) .. ") Hurricane(" .. numResearchLeft(player, HurricaneAASite) .. ")Cyclone(" .. numResearchLeft(player, CycloneAASite) .. ")Whirlwind(" .. numResearchLeft(player, WhirlwindAASite) .. ") " .. _str4, player, _sender)
							end
						end
					end
				end
			end
		end
		
		-- if(chatCmdIsPlayerAddressed(_curMsg, player))/
		_curMsg = _curMsg + 1
	end
end

-- -----------------------------------------------------------------------------
function notifyAll(_cstr)
	local _player = 0
	
	_player = 0
	while _player < MAX_PLAYERS do
		if player ~= _player then
			msg(_cstr, player, _player)
		end
		_player = _player + 1
	end
end

-- -----------------------------------------------------------------------------
function notifyStatus(_choice, _player)
	local _f = 0
	local _c = 0
	local _r = 0
	local _v = 0
	local _h = 0
	local _l = 0
	local _cc = 0
	
	_f = nFactories
	_r = nResLabs
	_c = nCybFact
	_v = nVTOLFactories
	_h = numStructsByType(playerHQ, player)
	_l = numStructsByType(lassat, player)
	_cc = numStructsByType(derrick, player)
	
	msg("Player #(" .. player .. ") colour(" .. getPlayerName(player) .. ") Game Time(" .. C.gameTime / 10 / 60 .. " min) Map Size(" .. C.mapWidth .. "-" .. C.mapHeight .. ") Defend Range(" .. nDefendRange / TILE .. ") Under attack(" .. alertIsOn .. ")", player, _player)
	msg("Power:" .. playerPower(player) .. " Derricks:" .. _cc .. "  Min base structures buit:" .. lMinBaseStructBuilt .. " alert is on(" .. alertIsOn .. ") alert level(" .. alertLevel .. ")", player, _player)
	msg("Droids: Tot(" .. nTotTanks + nTotCyborgs .. ") Defending(" .. groupCountMembers(tankDefGroup) + groupCountMembers(cyborgDefGroup) .. ") Attacking(" .. groupCountMembers(tankGroup) + groupCountMembers(cyborgAttGroup) .. ") Helping(" .. groupCountMembers(helpGroup) .. ") To be Repaired(" .. groupCountMembers(toBeRepairedCyborgGroup) + groupCountMembers(toBeRepairedTankGroup) .. ") ", player, _player)
	msg("Structs: Factories(" .. _f .. ") ResLabs(" .. _r .. ") CybFactories(" .. _c .. ") VTOLFactories(" .. _v .. ") Lassat(" .. _l .. ") HQ(" .. _h .. ") ", player, _player)
	msg("Team1 attack active(" .. bTankAttIsOn .. ") Team 1 target player (" .. targetPlayerTank .. ") Team 2 attack active(" .. bCybAttIsOn .. ") Team 2 target player(" .. targetPlayerCyb .. ") ", player, _player)
	msg("Have a beacon(" .. haveAnyBeacon() .. ") Player Helped(" .. nAllyBeingHelped .. ") Helping Droids(" .. groupCountMembers(helpGroup) .. ")", player, _player)
end

-- -----------------------------------------------------------------------------
function displayStats(_choice)
	local _sPlPow = nil
	local _sPlInf1 = nil
	local _sPlInf2 = nil
	local _sPlInf3 = nil
	local _strTeams = nil
	local _sWallDef = nil
	local _sDef = nil
	local _sRes = nil
	local _sRes2 = nil
	local _str0 = nil
	local _str1 = nil
	local _str2 = nil
	local _str3 = nil
	local _str4 = nil
	local _str5 = nil
	local _sFort = nil
	local _totTanks = 0
	local _HQx = 0
	local _HQy = 0
	local _tDG = 0
	local _bg = 0
	local _hg = 0
	local _tg = 0
	local _bdg = 0
	local _ccG = 0
	local _rg = 0
	local _HelpG = 0
	local _cG = 0
	local _totHarv = 0
	local _enWeap = 0
	local _myWeap = 0
	local _myWeapSTR = 0
	local _enemyCost = 0
	local _friendCost = 0
	local _count = 0
	local _count2 = 0
	
	ASSERT(player >= 0 and player < 8, "player out of bounds: showPlayerInfo " .. player, player)
	
	_count = 0
	while _count < 11 do
		if oilResTargetId[_count] > -1 then
			_totHarv = _totHarv + 1
		end
		_count = _count + 1
	end
	
	_bg = groupCountMembers(buildGroup)
	_hg = groupCountMembers(harvesterGroup)
	_rg = groupCountMembers(repairGroup)
	_tg = groupCountMembers(tankGroup)
	_bdg = groupCountMembers(buildDefGroup)
	_ccG = groupCountMembers(cyborgConstructGroup)
	_cG = groupCountMembers(cyborgDefGroup)
	_tDG = groupCountMembers(tankDefGroup)
	_HelpG = groupCountMembers(helpGroup)
	_totTanks = MIN_ATTACKING_TANKS + nAttackingUnitsToAdd + minDefDroids[nAI_Pers][MINDEF_TANKS]
	
	_enWeap = numEnemyWeapDroidsInRange(player, baseX, baseY, nBaseRange, false)
	_myWeap = numPlayerWeapDroidsInRange(player, player, baseX, baseY, nBaseRange, true)
	_myWeapSTR = numFriendlyWeapStructsInRange(player, baseX, baseY, nBaseRange, true)
	
	structure = getStructure(playerHQ, player)
	if structure ~= nil then
		_HQx = structure.x
		_HQy = structure.y
	else
		_HQx = 0
		_HQy = 0
	end
	
	_count = 0
	while _count < numWallWeaps do
		_sWallDef = _sWallDef .. " [" .. _count .. "](" .. isStructureAvailable(wallWeaps[_count], player) .. ") "
		_count = _count + 1
	end
	_count = 0
	while _count < numDefStructs do
		_sDef = _sDef .. " [" .. _count .. "](" .. isStructureAvailable(defStructs[_count], player) .. ") "
		_count = _count + 1
	end
	
	_count = 0
	while _count < numFortressDef do
		_sFort = _sFort .. " [" .. _count .. "](" .. isStructureAvailable(fortressDef[_count], player) .. ") "
		_count = _count + 1
	end
	
	_count = 0
	while _count < 20 do
		_str0 = _str0 .. " [" .. _count .. "]" .. numResearchLeft(player, research[0][_count]) .. " "
		_count = _count + 1
	end
	while _count < 40 do
		_str1 = _str1 .. " [" .. _count .. "]" .. numResearchLeft(player, research[0][_count]) .. " "
		_count = _count + 1
	end
	while _count < numRes[0] do
		_str2 = _str2 .. " [" .. _count .. "]" .. numResearchLeft(player, research[0][_count]) .. " "
		_count = _count + 1
	end
	
	_count = 0
	while _count < 23 do
		_str3 = _str3 .. " [" .. _count .. "]" .. numResearchLeft(player, research[1][_count]) .. " "
		_count = _count + 1
	end
	while _count < numRes[1] do
		_str4 = _str4 .. " [" .. _count .. "]" .. numResearchLeft(player, research[1][_count]) .. " "
		_count = _count + 1
	end
	
	_count = 0
	while _count < numCheapRes[0] do
		_sRes2 = _sRes2 .. " [" .. _count .. "]" .. numResearchLeft(player, researchCheap[0][_count]) .. " "
		_count = _count + 1
	end
	
	_count = 0
	while _count < numRes[9] do
		_str5 = _str5 .. " [" .. _count .. "]" .. numResearchLeft(player, research[9][_count]) .. " "
		_count = _count + 1
	end
	
	_count = 0
	while _count < MAX_PLAYERS do
		if isPlayerStillLive(_count) then
			_strTeams = _strTeams .. " '" .. getPlayerName(_count) .. "'' #" .. _count .. " [" .. aPlayers[TEAM_NUMBER][_count] .. "] "
		end
		_count = _count + 1
	end
	
	_count = 0
	while _count < MAX_PLAYERS and _count < 3 do
		if isPlayerStillLive(_count) then
			_sPlInf1 = _sPlInf1 .. " *[" .. getPlayerName(_count) .. "] RL(" .. aStat[OC_RESLABS][_count] .. ") Der(" .. aStat[OC_DERRICKS][_count] .. ") Cy-Tk-VTOL(" .. aStat[OC_CYBORGS][_count] .. "-" .. aStat[OC_TANKS][_count] .. "-" .. aStat[OC_VTOLS][_count] .. ") Pow(" .. aStat[OC_CYB_POWER][_count] .. "-" .. aStat[OC_TK_POWER][_count] .. "-" .. aStat[OC_VTOL_POWER][_count] .. ") hp(" .. aStat[OC_CYB_HP][_count] .. "-" .. aStat[OC_TK_HP][_count] .. "-" .. aStat[OC_VTOL_HP][_count] .. ")"
		end
		_count = _count + 1
	end
	while _count < MAX_PLAYERS and _count < 6 do
		if isPlayerStillLive(_count) then
			_sPlInf2 = _sPlInf2 .. " *[" .. getPlayerName(_count) .. "] RL(" .. aStat[OC_RESLABS][_count] .. ") Der(" .. aStat[OC_DERRICKS][_count] .. ") Cy-Tk-VTOL(" .. aStat[OC_CYBORGS][_count] .. "-" .. aStat[OC_TANKS][_count] .. "-" .. aStat[OC_VTOLS][_count] .. ") Pow(" .. aStat[OC_CYB_POWER][_count] .. "-" .. aStat[OC_TK_POWER][_count] .. "-" .. aStat[OC_VTOL_POWER][_count] .. ") hp(" .. aStat[OC_CYB_HP][_count] .. "-" .. aStat[OC_TK_HP][_count] .. "-" .. aStat[OC_VTOL_HP][_count] .. ")"
		end
		_count = _count + 1
	end
	while _count < MAX_PLAYERS and _count < 8 do
		if isPlayerStillLive(_count) then
			_sPlInf3 = _sPlInf3 .. " *[" .. getPlayerName(_count) .. "] RL(" .. aStat[OC_RESLABS][_count] .. ") Der(" .. aStat[OC_DERRICKS][_count] .. ") Cy-Tk-VTOL(" .. aStat[OC_CYBORGS][_count] .. "-" .. aStat[OC_TANKS][_count] .. "-" .. aStat[OC_VTOLS][_count] .. ") Pow(" .. aStat[OC_CYB_POWER][_count] .. "-" .. aStat[OC_TK_POWER][_count] .. "-" .. aStat[OC_VTOL_POWER][_count] .. ") hp(" .. aStat[OC_CYB_HP][_count] .. "-" .. aStat[OC_TK_HP][_count] .. "-" .. aStat[OC_VTOL_HP][_count] .. ")"
		end
		_count = _count + 1
	end
	
	_count2 = 0
	while _count2 < MAX_PLAYERS do
		if isPlayerStillLive(_count2) then
			_sPlPow = _sPlPow .. " __" .. getPlayerName(_count2) .. " (" .. getPowerIndex(_count2) .. ")"
		end
		_count2 = _count2 + 1
	end
	
	_count = player
	if _choice == 1 then
		dbg("dbg-> GameTime(" .. C.gameTime .. ") General(" .. AIPersonality .. ") AIstrength(" .. AIstrength .. ") gameType(" .. gameType() .. ") gameTime(" .. C.gameTime .. ") MAP(" .. C.mapWidth .. "-" .. C.mapHeight .. ") nBasRg(" .. nBaseRange / TILE .. ") gatRange(" .. gatewaysRangeTiles .. ") DefRange(" .. nDefendRange / TILE .. ") HQ(" .. _HQx / TILE .. "-" .. _HQy / TILE .. ") Base(" .. baseX / TILE .. "-" .. baseY / TILE .. ") arHarv(" .. _totHarv .. ") ", _count)
		dbg("dbg-> Plyers: " .. _strTeams .. " nTeam(" .. nTeam .. ") nLastEnemyPlayer (" .. nLastEnemyPlayer .. ") nEnemyPlayers (" .. nEnemyPlayers .. ") nHumanPlayers(" .. nHumanPlayers .. ") nPlayersInGame(" .. nPlayersInGame .. ") nTotEnemyDroids(" .. nTotEnemyDroids .. ")", _count)
		dbg("dbg-> bAnyOilResLeft(" .. bOilResLeft .. ") Harv(" .. _hg .. ") build(" .. _bg .. ") bDef" .. _bdg .. ") cybConst(" .. _ccG .. ") _HelpG (" .. _HelpG .. ") Tank(" .. _tg .. ") TankDef(" .. _tDG .. ") cybDef(" .. _cG .. ")  cybAtt(" .. groupCountMembers(cyborgAttGroup) .. ")  CybRep(" .. groupCountMembers(toBeRepairedCyborgGroup) .. ") TankRep(" .. groupCountMembers(toBeRepairedTankGroup) .. ") VTOLdef(" .. groupCountMembers(vtolDefendGr) .. ") VTOLatt(" .. groupCountMembers(vtolAttGr) .. ")", _count)
		dbg("dbg-> CybAttReq(" .. minDefDroids[nAI_Pers][MINDEF_CYBORGS] + MIN_ATT_CYBORGS + nCybAttUnitsToAdd .. ") TotCyb(" .. nTotCyborgs .. ") TankAttReq(" .. _totTanks .. ") TotTank(" .. nTotTanks .. ") help(" .. groupCountMembers(helpGroup) .. ") alertIsOn (" .. alertIsOn .. ")  realGatew(" .. nRealGatewaysFound .. ") nAllyBeingHelped(" .. nAllyBeingHelped .. ") ", _count)
		dbg("dbg-> Cyborgs Built: (AR-AT-AP-KK)(Error) (" .. nTotCybAR .. " - " .. nTotCybAT .. " - " .. nTotCybAP .. " - " .. nTotCybKK .. ")(" .. nTotCybErr .. ")", player)
		dbg("dbg-> POWER (" .. playerPower(0) .. ") (" .. playerPower(1) .. ") (" .. playerPower(2) .. ") (" .. playerPower(3) .. ") (" .. playerPower(4) .. ") (" .. playerPower(5) .. ") (" .. playerPower(6) .. ") (" .. playerPower(7) .. ") DROID-LEFT (" .. anyDroidsLeft(0) .. ")(" .. anyDroidsLeft(1) .. ")(" .. anyDroidsLeft(2) .. ")(" .. anyDroidsLeft(3) .. ")(" .. anyDroidsLeft(4) .. ")(" .. anyDroidsLeft(5) .. ")(" .. anyDroidsLeft(6) .. ")(" .. anyDroidsLeft(7) .. ") defSpotX/Y (" .. defSpotX .. "-" .. defSpotY .. ") nTotOilInAtStart (" .. nTotOilInAtStart .. ") ", _count)
	end
	
	if _choice == 2 then
		dbg("dbg-> Power:  bNeedDerrick (" .. bNeedDerrick .. ") bForceResPowUp(" .. bForceResPowUp .. ") numRemainingOilRes()(" .. nFreeOilRes .. ") " .. _sPlPow, _count)
		dbg("dbg-> Info : " .. _sPlInf1, _count)
		dbg("dbg-> Info : " .. _sPlInf2, _count)
		dbg("dbg-> Info : " .. _sPlInf3, _count)
		dbg("dbg-> Tank Attack: tTKSentToGath (" .. tTanksSentToGathering .. ")  bTankAttIsOn (" .. bTankAttIsOn .. ") lTKSentToGathPt (" .. lTankSentToGatheringPoint .. ") bTKAlreadyGathered (" .. bTankAlreadyGathered .. ") tankAttackX-Y (" .. tankAttackY / TILE .. "-" .. tankAttackY / TILE .. ") targetPlTK (" .. targetPlayerTank .. ") targetPlCyb(" .. targetPlayerCyb .. ") AttHumanPl(" .. nAttHumanPlayer .. ") AttAI(" .. nAttAIPlayer .. ")", _count)
	end
	if _choice == 3 then
		dbg("dbg-> Standard Defe: Depth(" .. pickDefQueueDepth .. ") - " .. _sDef, _count)
		dbg("dbg-> Wall Defences: Depth(" .. pickWallDefQueueDepth .. ") - " .. _sWallDef, _count)
		dbg("dbg-> Fortresses: Depth(" .. pickFortQueueDepth .. ") - " .. _sFort, _count)
		dbg("dbg-> Res: " .. _str0, _count)
		dbg("dbg-> Res: " .. _str1, _count)
		dbg("dbg-> Res: " .. _str2, _count)
		dbg("dbg-> Res: " .. _str3, _count)
		dbg("dbg-> Res: " .. _str4, _count)
		dbg("dbg-> Cheap Res: " .. numCheapRes[0] .. " " .. _sRes2, _count)
		dbg("dbg-> VTOL Res: " .. _str5, _count)
		dbg("dbg-> lMinBaseStructBuilt(" .. lMinBaseStructBuilt .. ") Working Lab(" .. nWorkingLab .. ") Fact(" .. nWorkingFact .. ") Cyb(" .. nWorkingCybFac .. ") ", _count)
	end
end

-- -----------------------------------------------------------------------------
function isPlayerStillLive(_player)
	if anyDroidsLeft(_player) or anyFactoriesLeft(_player) then
		return true
	end
	return false
end
-- -----------------------------------------------------------------------------
function checkIfDroidIsStuck(_group)
	local _x = 0
	local _y = 0
	local _dist = 0
	local _rnd = 0
	-- Search for stucked droids
	initIterateGroup(_group)
	droid = iterateGroup(_group)
	while droid ~= nil do
		if not droidOrderIdle(droid) then
			if not hasCoordStored(droid) then
				storeDroidCoord(droid)
			else
				if coordChanged(droid) then
					_dist = distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery)
					-- displayMsg("checkIfDroidIsStuck: droid ("& droid.id &") MOVES dist("& _dist/TILE &") pos("& droid.x/TILE &"-"& droid.y/TILE &") build("& droid.orderx/TILE &"-"& droid.ordery/TILE &") time("& gameTime &")");
					updateDroidCoord(droid)
				else
					_dist = distBetweenTwoPoints(droid.x, droid.y, droid.orderx, droid.ordery)
					if _dist < 3 * TILE then
						cleanDroidPos(droid.id)
					else
						if incrementDroidCounter(droid.id) then
							orderDroid(droid, DORDER_RUN)
						end
					end
				end
			end
		else
			cleanDroidPos(droid.id)
		end
		droid = iterateGroup(_group)
	end
	return
end
-- -----------------------------------------------------------------------------
function incrementDroidCounter(droid_id)
	local _c = 0
	_c = 0
	while _c < num_aDroid do
		if aDroid_Id[_c] == droid_id then
			aDroid_counter[_c] = aDroid_counter[_c] + 1
			if aDroid_counter[_c] > 1 then
				return true
			else
				return false
			end
		end
		_c = _c + 1
	end
	
	-- dbg("dbg->incrementDroidCounter: Error! droid ("& droid_id &") not found",player);
	return false
end
-- -----------------------------------------------------------------------------
function cleanDroidCoordArray()
	local _c = 0
	_c = 0
	while _c < num_aDroid do
		boolResult = false
		initIterateGroup(buildGroup)
		droid = iterateGroup(buildGroup)
		while droid ~= nil do
			if aDroid_Id[_c] == droid.id then
				boolResult = true
			end
			droid = iterateGroup(buildGroup)
		end
		
		initIterateGroup(buildDefGroup)
		droid = iterateGroup(buildDefGroup)
		while droid ~= nil do
			if aDroid_Id[_c] == droid.id then
				boolResult = true
			end
			droid = iterateGroup(buildDefGroup)
		end
		
		initIterateGroup(harvesterGroup)
		droid = iterateGroup(harvesterGroup)
		while droid ~= nil do
			if aDroid_Id[_c] == droid.id then
				boolResult = true
			end
			droid = iterateGroup(harvesterGroup)
		end
		
		if not boolResult then
			cleanDroidPos(aDroid_Id[_c])
		end
		
		_c = _c + 1
	end
	
	return
end
-- -----------------------------------------------------------------------------
function cleanDroidPos(_droidId)
	local _c = 0
	_c = 0
	while _c < num_aDroid do
		if aDroid_Id[_c] == _droidId then
			aDroid_Id[_c] = -1
			aDroid_X[_c] = -1
			aDroid_Y[_c] = -1
			aDroid_counter[_c] = 0
		end
		_c = _c + 1
	end
end

-- -----------------------------------------------------------------------------
function storeDroidCoord(_droid)
	local _c = 0
	_c = getFreePosDroid()
	-- hack
	if _c == -1 then
		_c = 49 - random(10)
	end
	aDroid_Id[_c] = droid.id
	aDroid_X[_c] = droid.x
	aDroid_Y[_c] = droid.y
end
-- -----------------------------------------------------------------------------
function updateDroidCoord(_droid)
	local _c = 0
	_c = 0
	while count < num_aDroid do
		if aDroid_Id[_c] == _droid.id then
			aDroid_Id[_c] = droid.id
			aDroid_X[_c] = droid.x
			aDroid_Y[_c] = droid.y
			return
		end
		_c = _c + 1
	end
	-- it is ok if the droid has not been found because positions are resetted
	-- for droid not idle
	storeDroidCoord(_droid)
	return
end

-- -----------------------------------------------------------------------------
function coordChanged(_droid)
	local _c = 0
	local _c2 = 0
	_c = 0
	while _c < num_aDroid do
		if aDroid_Id[_c] == _droid.id then
			_c2 = distBetweenTwoPoints(_droid.x, _droid.y, aDroid_X[_c], aDroid_Y[_c])
			if _c2 > 2 * TILE then
				return true
			else
				return false
			end
		end
		_c = _c + 1
	end
	-- dbg("dbg->coordChanged: Error! droid ("& _droid.id &") not found",player);
	return true
end
-- -----------------------------------------------------------------------------
function hasCoordStored(_droid)
	local _c = 0
	_c = 0
	while _c < num_aDroid do
		if aDroid_Id[_c] == _droid.id then
			return true
		end
		_c = _c + 1
	end
	return false
end
-- -----------------------------------------------------------------------------
function getFreePosDroid()
	local _c = 0
	_c = 0
	while _c < num_aDroid do
		if aDroid_Id[_c] == -1 then
			return _c
		end
		_c = _c + 1
	end
	-- dbg("dbg->getFreePosDroid: player("& player &") free pos not found!! ("& _c &")",player);
	return -1
end
-- --------------------------------------------------------------------
function numStructinRange(_struct, _player, _xCoord, _yCoord, _Range)
	local _nTot = 0
	local _structure = nil
	
	_nTot = 0
	
	initEnumStruct(false, _struct, _player, _player)
	_structure = enumStruct()
	while _structure ~= nil do
		if distBetweenTwoPoints(_xCoord, _yCoord, _structure.x, _structure.y) <= _Range then
			_nTot = _nTot + 1
		end
		_structure = enumStruct()
	end
	
	return _nTot
end

-- --------------------------------------------------------------------
function printDebug(_message)
	if _DEBUG then
		debugFile(GAME_TIME_IN_MIN() .. "min; " .. getPlayerName(player) .. " #" .. player .. " [" .. AIPersonality .. "-" .. AIstrength .. "] ;0 ;" .. _message)
	end
end
-- --------------------------------------------------------------------
function printDebug1(_message)
	if _DEBUG1 then
		debugFile(GAME_TIME_IN_MIN() .. "min; " .. getPlayerName(player) .. " #" .. player .. " [" .. AIPersonality .. "-" .. AIstrength .. "] ;1 ;" .. _message)
	end
end
-- --------------------------------------------------------------------
-- form alliances between AIs
function createAIalliance(_player1, _player2)
	if not isPlayerStillLive(_player1) or not isPlayerStillLive(_player2) then
		return false
	end
	
	if isHumanPlayer(_player1) or isHumanPlayer(_player1) then
		return false
	end
	
	if allianceExistsBetween(_player1, _player2) then
		return false
	end
	
	createAlliance(_player1, _player2)
	notifyAll("-----------------------------------------------")
	notifyAll("Alliance created between AIs: '" .. getPlayerName(_player1) .. "' '" .. getPlayerName(_player2) .. "'")
	notifyAll("-----------------------------------------------")
	
	printDebug1("createAIalliance: Alliance created between AIs '" .. getPlayerName(_player1) .. "' '" .. getPlayerName(_player2) .. "'")
	
	return true
end
-- --------------------------------------------------------------------
function getDefStruct()
	local _defstruct = nil
	local _nDef = 0
	local _n = 0
	local _rnd = 0
	
	_n = math.min(pickDefQueueDepth, 3)
	-- best 3 defences
	_nDef = pickDefQueueDepth - 1 - random(_n)
	_defstruct = pickDefQueue[_nDef]
	
	-- =========== STANDARD DEFENCES ==================================
	if random(100) < 35 or pickWallDefQueueDepth < 2 then
		if pickDefQueueDepth < 7 then
			_rnd = _random(100)
			-- build mainly HMGhardPoint/MGbunker, LancerTower/miniRocketTower
			if _rnd < 40 then
				if isStructureAvailable(HMGhardPoint, player) then
					_defstruct = HMGhardPoint
				else
					if isStructureAvailable(MGbunker, player) then
						_defstruct = MGbunker
					end
				end
			end
			if _rnd >= 40 and _rnd < 70 then
				if isStructureAvailable(LancerTower, player) then
					_defstruct = LancerTower
				else
					if isStructureAvailable(miniRocketTower, player) then
						_defstruct = miniRocketTower
					else
						if isStructureAvailable(MGbunker, player) then
							_defstruct = MGbunker
						end
					end
				end
			end
		end
	else
		if pickWallDefQueueDepth > 0 then
			_n = math.min(pickWallDefQueueDepth, 4)
			_nDef = pickWallDefQueueDepth - 1 - _random(_n)
			_defstruct = pickWallDefQueue[_nDef]
		end
	end
	
	
	return _defstruct
end
-- -----------------------------------------------------------------------------
-- only droids with order != build are taken into account
function closestDroidCanBuild(_group, _x, _y)
	local _closestTruck = nil
	local _tempTruck = nil
	local _closestDist = 0
	local _tempDist = 0
	
	_closestTruck = nil
	_closestDist = 999 * TILE
	
	if groupCountMembers(_group) == 0 then
		return _closestTruck
	end
	
	initIterateGroup(_group)
	_tempTruck = iterateGroup(_group)
	while _tempTruck ~= nil do
		if _tempTruck.order ~= DORDER_BUILD then
			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y)
			if _tempDist < _closestDist then
				_closestDist = _tempDist
				_closestTruck = _tempTruck
			end
		end
		_tempTruck = iterateGroup(_group)
	end
	return _closestTruck
end
-- -----------------------------------------------------------------------------
function closestIdleDroid(_group, _x, _y)
	local _closestTruck = nil
	local _tempTruck = nil
	local _closestDist = 0
	local _tempDist = 0
	
	_closestTruck = nil
	_closestDist = 999 * TILE
	
	if groupCountMembers(_group) == 0 then
		return _closestTruck
	end
	
	initIterateGroup(_group)
	_tempTruck = iterateGroup(_group)
	while _tempTruck ~= nil do
		if droidOrderIdle(_tempTruck) then
			_tempDist = distBetweenTwoPoints(_x, _y, _tempTruck.x, _tempTruck.y)
			if _tempDist < _closestDist then
				_closestDist = _tempDist
				_closestTruck = _tempTruck
			end
		end
		_tempTruck = iterateGroup(_group)
	end
	return _closestTruck
end
-- ------------------------------------------------------------------------
function buildHeavyTank(_nWeapon, _struct)
	local _n = 0
	local _pos = 0
	local _nChoice = 0
	local _tmpl[15] = 0
	
	_n = 0
	while _n < 15 do
		_tmpl[_n] = -1
		_n = _n + 1
	end
	
	_n = 0
	_pos = -1
	
	if _nWeapon == WEAPON_AP then
		if skCanBuildTemplate(player, _struct, tmpl0[46]) then
			_tmpl[_n] = 46
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[44]) then
			_tmpl[_n] = 44
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[21]) then
			_tmpl[_n] = 21
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[20]) then
			_tmpl[_n] = 20
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[9]) then
			_tmpl[_n] = 9
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[8]) then
			_tmpl[_n] = 8
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[3]) then
			_tmpl[_n] = 3
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[2]) then
			_tmpl[_n] = 2
			_n = _n + 1
		end
	end
	if _nWeapon == WEAPON_AT then
		if skCanBuildTemplate(player, _struct, tmpl0[48]) then
			_tmpl[_n] = 48
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[47]) then
			_tmpl[_n] = 47
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[23]) then
			_tmpl[_n] = 23
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[22]) then
			_tmpl[_n] = 22
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[11]) then
			_tmpl[_n] = 11
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[10]) then
			_tmpl[_n] = 10
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[5]) then
			_tmpl[_n] = 5
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[4]) then
			_tmpl[_n] = 4
			_n = _n + 1
		end
	end
	if _nWeapon == WEAPON_AR then
		if skCanBuildTemplate(player, _struct, tmpl0[43]) then
			_tmpl[_n] = 43
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[42]) then
			_tmpl[_n] = 42
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[41]) then
			_tmpl[_n] = 41
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[40]) then
			_tmpl[_n] = 40
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[36]) then
			_tmpl[_n] = 36
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[35]) then
			_tmpl[_n] = 35
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[34]) then
			_tmpl[_n] = 34
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[19]) then
			_tmpl[_n] = 19
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[18]) then
			_tmpl[_n] = 18
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[7]) then
			_tmpl[_n] = 7
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[6]) then
			_tmpl[_n] = 6
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[1]) then
			_tmpl[_n] = 1
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[0]) then
			_tmpl[_n] = 0
			_n = _n + 1
		end
	end
	
	-- dbg("buildHeavyTank:  _tmpl[0]("& _tmpl[0] &") _tmpl[1]("& _tmpl[1] &") _tmpl[2]("& _tmpl[2] &") _n("& _n &") < 0 !!! ",player);
	printDebug1("buildHeavyTank:  _tmpl[0](" .. _tmpl[0] .. ") _tmpl[1](" .. _tmpl[1] .. ") _tmpl[2](" .. _tmpl[2] .. ") _n(" .. _n .. ") < 0 !!! ")
	if _n == 0 then
		printDebug1("#### buildHeavyTank:  error ! _nWeapon(" .. _nWeapon .. ") _n(" .. _n .. ") < 0 !!! ")
		return false
	end
	
	if _n > 2 then
		_pos = (_n - 1) - random(3)
	end
	if _n == 2 then
		_pos = random(2)
	end
	if _n == 1 then
		_pos = 0
	end
	
	_nChoice = _tmpl[_pos]
	
	if skCanBuildTemplate(player, _struct, tmpl0[_nChoice]) then
		printDebug1("buildHeavyTank: build template _nWeapon(" .. _nWeapon .. ") _nChoice(" .. _nChoice .. ") _pos(" .. _pos .. ") _n(" .. _n .. ")")
		buildDroid(tmpl0[_nChoice], _struct, player, 1)
		return true
	else
		printDebug1("#### buildHeavyTank: could not build template _nWeapon(" .. _nWeapon .. ") _nChoice(" .. _nChoice .. ") _pos(" .. _pos .. ") _n(" .. _n .. ")")
		return false
	end
	return false
end
-- ------------------------------------------------------------------------
function buildMediumTank(_nWeapon, _struct)
	local _n = 0
	local _pos = 0
	local _nChoice = 0
	local _tmpl[15] = 0
	
	_n = 0
	while _n < 15 do
		_tmpl[_n] = -1
		_n = _n + 1
	end
	
	_n = 0
	_pos = -1
	
	if _nWeapon == WEAPON_AP then
		if skCanBuildTemplate(player, _struct, tmpl0[53]) then
			_tmpl[_n] = 53
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[50]) then
			_tmpl[_n] = 50
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[49]) then
			_tmpl[_n] = 49
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[38]) then
			_tmpl[_n] = 38
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[27]) then
			_tmpl[_n] = 27
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[26]) then
			_tmpl[_n] = 26
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[15]) then
			_tmpl[_n] = 15
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[14]) then
			_tmpl[_n] = 14
			_n = _n + 1
		end
	end
	if _nWeapon == WEAPON_AT then
		if skCanBuildTemplate(player, _struct, tmpl0[56]) then
			_tmpl[_n] = 56
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[55]) then
			_tmpl[_n] = 55
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[54]) then
			_tmpl[_n] = 54
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[39]) then
			_tmpl[_n] = 39
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[29]) then
			_tmpl[_n] = 29
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[28]) then
			_tmpl[_n] = 28
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[17]) then
			_tmpl[_n] = 17
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[16]) then
			_tmpl[_n] = 16
			_n = _n + 1
		end
	end
	if _nWeapon == WEAPON_AR then
		if skCanBuildTemplate(player, _struct, tmpl0[52]) then
			_tmpl[_n] = 52
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[51]) then
			_tmpl[_n] = 51
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[37]) then
			_tmpl[_n] = 37
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[25]) then
			_tmpl[_n] = 25
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[24]) then
			_tmpl[_n] = 24
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[13]) then
			_tmpl[_n] = 13
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[12]) then
			_tmpl[_n] = 12
			_n = _n + 1
		end
	end
	
	-- dbg("buildMediumTank: _tmpl[0]("& _tmpl[0] &") _tmpl[1]("& _tmpl[1] &") _tmpl[2]("& _tmpl[2] &") _n("& _n &") < 0 !!! ",player);
	printDebug1("buildMediumTank:  _tmpl[0](" .. _tmpl[0] .. ") _tmpl[1](" .. _tmpl[1] .. ") _tmpl[2](" .. _tmpl[2] .. ") _n(" .. _n .. ") < 0 !!! ")
	if _n == 0 then
		printDebug1("#### buildMediumTank:  error ! _nWeapon(" .. _nWeapon .. ") _n(" .. _n .. ") < 0 !!! ")
		return false
	end
	
	if _n > 2 then
		_pos = (_n - 1) - random(3)
	end
	if _n == 2 then
		_pos = random(2)
	end
	if _n == 1 then
		_pos = 0
	end
	
	_nChoice = _tmpl[_pos]
	
	if skCanBuildTemplate(player, _struct, tmpl0[_nChoice]) then
		printDebug1("buildMediumTank: build template _nWeapon(" .. _nWeapon .. ") _nChoice(" .. _nChoice .. ") _pos(" .. _pos .. ") _n(" .. _n .. ")")
		buildDroid(tmpl0[_nChoice], _struct, player, 1)
		return true
	else
		printDebug1("#### buildMediumTank: could not build template _nWeapon(" .. _nWeapon .. ") _nChoice(" .. _nChoice .. ") _pos(" .. _pos .. ") _n(" .. _n .. ")")
		return false
	end
	return false
end

-- ------------------------------------------------------------------------
function buildLightTank(_nWeapon, _struct)
	local _n = 0
	local _pos = 0
	local _nChoice = 0
	local _tmpl[15] = 0
	
	_n = 0
	while _n < 15 do
		_tmpl[_n] = -1
		_n = _n + 1
	end
	
	_n = 0
	_pos = -1
	
	if _nWeapon == WEAPON_AP then
		if skCanBuildTemplate(player, _struct, tmpl0[62]) then
			_tmpl[_n] = 62
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[61]) then
			_tmpl[_n] = 61
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[60]) then
			_tmpl[_n] = 60
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[33]) then
			_tmpl[_n] = 33
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[32]) then
			_tmpl[_n] = 32
			_n = _n + 1
		end
	end
	if _nWeapon == WEAPON_AT then
		if skCanBuildTemplate(player, _struct, tmpl0[58]) then
			_tmpl[_n] = 58
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[57]) then
			_tmpl[_n] = 57
			_n = _n + 1
		end
	end
	if _nWeapon == WEAPON_AR then
		if skCanBuildTemplate(player, _struct, tmpl0[59]) then
			_tmpl[_n] = 59
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[31]) then
			_tmpl[_n] = 31
			_n = _n + 1
		end
		if skCanBuildTemplate(player, _struct, tmpl0[30]) then
			_tmpl[_n] = 30
			_n = _n + 1
		end
	end
	
	-- dbg("buildLightTank:  _tmpl[0]("& _tmpl[0] &") _tmpl[1]("& _tmpl[1] &") _tmpl[2]("& _tmpl[2] &") _n("& _n &") < 0 !!! ",player);
	printDebug1("buildLightTank:  _tmpl[0](" .. _tmpl[0] .. ") _tmpl[1](" .. _tmpl[1] .. ") _tmpl[2](" .. _tmpl[2] .. ") _n(" .. _n .. ")  !!! ")
	if _n == 0 then
		printDebug1("#### buildLightTank:  error ! _nWeapon(" .. _nWeapon .. ") _n(" .. _n .. ") < 0 !!! ")
		return false
	end
	
	if _n > 2 then
		_pos = (_n - 1) - random(3)
	end
	if _n == 2 then
		_pos = random(2)
	end
	if _n == 1 then
		_pos = 0
	end
	
	_nChoice = _tmpl[_pos]
	
	if skCanBuildTemplate(player, _struct, tmpl0[_nChoice]) then
		printDebug1("buildLightTank: build template _nWeapon(" .. _nWeapon .. ") _nChoice(" .. _nChoice .. ") _pos(" .. _pos .. ") _n(" .. _n .. ")")
		buildDroid(tmpl0[_nChoice], _struct, player, 1)
		return true
	else
		printDebug1("#### buildLightTank: could not build template _nWeapon(" .. _nWeapon .. ") _nChoice(" .. _nChoice .. ") _pos(" .. _pos .. ") _n(" .. _n .. ")")
		return false
	end
	return false
end

-- ---------------------------------------------------------------------------
function checkBestBody(_nBody, _nWeapon, _struct)
	local _i = 0
	
	_i = 0
	if _nBody == BODY_HEAVY then
		if _nWeapon == WEAPON_AP then
			if skCanBuildTemplate(player, _struct, tmpl0[46]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[45]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[44]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[21]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[20]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[9]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[8]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[3]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[2]) then
				_i = _i + 1
			end
		end
		if _nWeapon == WEAPON_AR then
			if skCanBuildTemplate(player, _struct, tmpl0[43]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[42]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[41]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[40]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[36]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[35]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[34]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[19]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[18]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[7]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[6]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[1]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[0]) then
				_i = _i + 1
			end
		end
		if _nWeapon == WEAPON_AT then
			if skCanBuildTemplate(player, _struct, tmpl0[48]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[47]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[23]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[22]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[11]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[10]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[5]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[4]) then
				_i = _i + 1
			end
		end
	end
	if _nBody == BODY_MEDIUM then
		if _nWeapon == WEAPON_AP then
			if skCanBuildTemplate(player, _struct, tmpl0[53]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[50]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[49]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[38]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[27]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[26]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[15]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[14]) then
				_i = _i + 1
			end
		end
		if _nWeapon == WEAPON_AR then
			if skCanBuildTemplate(player, _struct, tmpl0[52]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[51]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[37]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[25]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[24]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[13]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[12]) then
				_i = _i + 1
			end
		end
		if _nWeapon == WEAPON_AT then
			if skCanBuildTemplate(player, _struct, tmpl0[56]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[55]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[54]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[39]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[29]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[28]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[17]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[16]) then
				_i = _i + 1
			end
		end
	end
	if _nBody == BODY_LIGHT then
		if _nWeapon == WEAPON_AP then
			if skCanBuildTemplate(player, _struct, tmpl0[62]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[61]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[60]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[33]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[32]) then
				_i = _i + 1
			end
		end
		if _nWeapon == WEAPON_AR then
			if skCanBuildTemplate(player, _struct, tmpl0[59]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[31]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[30]) then
				_i = _i + 1
			end
		end
		if _nWeapon == WEAPON_AT then
			if skCanBuildTemplate(player, _struct, tmpl0[58]) then
				_i = _i + 1
			end
			if skCanBuildTemplate(player, _struct, tmpl0[57]) then
				_i = _i + 1
			end
		end
	end
	printDebug1("checkBestBody: _i(" .. _i .. ") _nBody(" .. _nBody .. ") _nWeapon(" .. _nWeapon .. ")")
	return _i
end


---------- stubs ----------

if orderDroidStatsLoc == nil then orderDroidStatsLoc = function() print("stub: orderDroidStatsLoc"); return 0 end end
if numStructsByType == nil then numStructsByType = function() print("stub: numStructsByType"); return 0 end end
if threatInRange == nil then threatInRange = function() print("stub: threatInRange"); return 0 end end
if skFireLassat == nil then skFireLassat = function() print("stub: skFireLassat"); return 0 end end
if random == nil then random = function() print("stub: random"); return 0 end end
if enableResearch == nil then enableResearch = function() print("stub: enableResearch"); return 0 end end
if dbg == nil then dbg = function() print("stub: dbg"); return 0 end end
if getCoordRelated == nil then getCoordRelated = function() print("stub: getCoordRelated"); return 0 end end
if hasCoordStored == nil then hasCoordStored = function() print("stub: hasCoordStored"); return 0 end end
if getNearestEnemyPlayer == nil then getNearestEnemyPlayer = function() print("stub: getNearestEnemyPlayer"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if pickStructLocation == nil then pickStructLocation = function() print("stub: pickStructLocation"); return 0 end end
if deactivateHelp == nil then deactivateHelp = function() print("stub: deactivateHelp"); return 0 end end
if updatePlayersStats == nil then updatePlayersStats = function() print("stub: updatePlayersStats"); return 0 end end
if anyDroidsLeft == nil then anyDroidsLeft = function() print("stub: anyDroidsLeft"); return 0 end end
if activateAI == nil then activateAI = function() print("stub: activateAI"); return 0 end end
if console == nil then console = function() print("stub: console"); return 0 end end
if initIterateGroup == nil then initIterateGroup = function() print("stub: initIterateGroup"); return 0 end end
if helpAlly == nil then helpAlly = function() print("stub: helpAlly"); return 0 end end
if droidCanReach == nil then droidCanReach = function() print("stub: droidCanReach"); return 0 end end
if findEnemyOBJ == nil then findEnemyOBJ = function() print("stub: findEnemyOBJ"); return 0 end end
if hasGroup == nil then hasGroup = function() print("stub: hasGroup"); return 0 end end
if coordChanged == nil then coordChanged = function() print("stub: coordChanged"); return 0 end end
if buildDefStruct == nil then buildDefStruct = function() print("stub: buildDefStruct"); return 0 end end
if groupAddArea == nil then groupAddArea = function() print("stub: groupAddArea"); return 0 end end
if numPlayerWeapDroidsInRange == nil then numPlayerWeapDroidsInRange = function() print("stub: numPlayerWeapDroidsInRange"); return 0 end end
if getDefStruct == nil then getDefStruct = function() print("stub: getDefStruct"); return 0 end end
if closestDroidCanBuild == nil then closestDroidCanBuild = function() print("stub: closestDroidCanBuild"); return 0 end end
if getStructure == nil then getStructure = function() print("stub: getStructure"); return 0 end end
if printDebug == nil then printDebug = function() print("stub: printDebug"); return 0 end end
if closestOilRes == nil then closestOilRes = function() print("stub: closestOilRes"); return 0 end end
if manageVeryLowPower4 == nil then manageVeryLowPower4 = function() print("stub: manageVeryLowPower4"); return 0 end end
if manageVeryLowPower3 == nil then manageVeryLowPower3 = function() print("stub: manageVeryLowPower3"); return 0 end end
if manageVeryLowPower2 == nil then manageVeryLowPower2 = function() print("stub: manageVeryLowPower2"); return 0 end end
if initEnumDroids == nil then initEnumDroids = function() print("stub: initEnumDroids"); return 0 end end
if getPowerIndex == nil then getPowerIndex = function() print("stub: getPowerIndex"); return 0 end end
if attackedByDroid == nil then attackedByDroid = function() print("stub: attackedByDroid"); return 0 end end
if getRandomEnemyPlayer == nil then getRandomEnemyPlayer = function() print("stub: getRandomEnemyPlayer"); return 0 end end
if allianceExistsBetween == nil then allianceExistsBetween = function() print("stub: allianceExistsBetween"); return 0 end end
if dropBeaconToAllies == nil then dropBeaconToAllies = function() print("stub: dropBeaconToAllies"); return 0 end end
if buildLightTank == nil then buildLightTank = function() print("stub: buildLightTank"); return 0 end end
if notifyAll == nil then notifyAll = function() print("stub: notifyAll"); return 0 end end
if setDroidSecondary == nil then setDroidSecondary = function() print("stub: setDroidSecondary"); return 0 end end
if playerPower == nil then playerPower = function() print("stub: playerPower"); return 0 end end
if skDoResearch == nil then skDoResearch = function() print("stub: skDoResearch"); return 0 end end
if numStructinRange == nil then numStructinRange = function() print("stub: numStructinRange"); return 0 end end
if harvestNearOilRes == nil then harvestNearOilRes = function() print("stub: harvestNearOilRes"); return 0 end end
if orderGroupMoveCMD == nil then orderGroupMoveCMD = function() print("stub: orderGroupMoveCMD"); return 0 end end
if processChatMsg == nil then processChatMsg = function() print("stub: processChatMsg"); return 0 end end
if structTargetInArea == nil then structTargetInArea = function() print("stub: structTargetInArea"); return 0 end end
if getPlayer == nil then getPlayer = function() print("stub: getPlayer"); return 0 end end
if bHasHumanEnemies == nil then bHasHumanEnemies = function() print("stub: bHasHumanEnemies"); return 0 end end
if isStructureAvailable == nil then isStructureAvailable = function() print("stub: isStructureAvailable"); return 0 end end
if getNumStructNotIdle == nil then getNumStructNotIdle = function() print("stub: getNumStructNotIdle"); return 0 end end
if getDroidsInfo == nil then getDroidsInfo = function() print("stub: getDroidsInfo"); return 0 end end
if debugFile == nil then debugFile = function() print("stub: debugFile"); return 0 end end
if processCommand == nil then processCommand = function() print("stub: processCommand"); return 0 end end
if getTargetEnemy == nil then getTargetEnemy = function() print("stub: getTargetEnemy"); return 0 end end
if buildGatewayDef == nil then buildGatewayDef = function() print("stub: buildGatewayDef"); return 0 end end
if SetDyDoPersonality == nil then SetDyDoPersonality = function() print("stub: SetDyDoPersonality"); return 0 end end
if objDroidTargetInRange == nil then objDroidTargetInRange = function() print("stub: objDroidTargetInRange"); return 0 end end
if numEnemyWeapObjInRange == nil then numEnemyWeapObjInRange = function() print("stub: numEnemyWeapObjInRange"); return 0 end end
if buildMediumTank == nil then buildMediumTank = function() print("stub: buildMediumTank"); return 0 end end
if shutDownThisAI == nil then shutDownThisAI = function() print("stub: shutDownThisAI"); return 0 end end
if numEnemyWeapStructsInRange == nil then numEnemyWeapStructsInRange = function() print("stub: numEnemyWeapStructsInRange"); return 0 end end
if distBetweenTwoPoints == nil then distBetweenTwoPoints = function() print("stub: distBetweenTwoPoints"); return 0 end end
if storeDroidCoord == nil then storeDroidCoord = function() print("stub: storeDroidCoord"); return 0 end end
if chatCmdIsPlayerAddressed == nil then chatCmdIsPlayerAddressed = function() print("stub: chatCmdIsPlayerAddressed"); return 0 end end
if droidInRange == nil then droidInRange = function() print("stub: droidInRange"); return 0 end end
if deactivateCybAttack == nil then deactivateCybAttack = function() print("stub: deactivateCybAttack"); return 0 end end
if isHumanPlayer == nil then isHumanPlayer = function() print("stub: isHumanPlayer"); return 0 end end
if enumDroid == nil then enumDroid = function() print("stub: enumDroid"); return 0 end end
if repairDefStructs == nil then repairDefStructs = function() print("stub: repairDefStructs"); return 0 end end
if skDefenseLocationB == nil then skDefenseLocationB = function() print("stub: skDefenseLocationB"); return 0 end end
if updateBeacons == nil then updateBeacons = function() print("stub: updateBeacons"); return 0 end end
if groupAddGroup == nil then groupAddGroup = function() print("stub: groupAddGroup"); return 0 end end
if pickCybEng == nil then pickCybEng = function() print("stub: pickCybEng"); return 0 end end
if helpBuild == nil then helpBuild = function() print("stub: helpBuild"); return 0 end end
if pickDefTruck == nil then pickDefTruck = function() print("stub: pickDefTruck"); return 0 end end
if dropBeacon == nil then dropBeacon = function() print("stub: dropBeacon"); return 0 end end
if getPlayerName == nil then getPlayerName = function() print("stub: getPlayerName"); return 0 end end
if researchStarted == nil then researchStarted = function() print("stub: researchStarted"); return 0 end end
if testStructureModule == nil then testStructureModule = function() print("stub: testStructureModule"); return 0 end end
if completeResearch == nil then completeResearch = function() print("stub: completeResearch"); return 0 end end
if getNumDerricks == nil then getNumDerricks = function() print("stub: getNumDerricks"); return 0 end end
if numEnemyAAInRange == nil then numEnemyAAInRange = function() print("stub: numEnemyAAInRange"); return 0 end end
if initEnumStruct == nil then initEnumStruct = function() print("stub: initEnumStruct"); return 0 end end
if numEnemyWeapDroidsInRange == nil then numEnemyWeapDroidsInRange = function() print("stub: numEnemyWeapDroidsInRange"); return 0 end end
if checkDerrickIsBuilt == nil then checkDerrickIsBuilt = function() print("stub: checkDerrickIsBuilt"); return 0 end end
if createAlliance == nil then createAlliance = function() print("stub: createAlliance"); return 0 end end
if displayStats == nil then displayStats = function() print("stub: displayStats"); return 0 end end
if moveUnitsBetweenGRPs == nil then moveUnitsBetweenGRPs = function() print("stub: moveUnitsBetweenGRPs"); return 0 end end
if incrementDroidCounter == nil then incrementDroidCounter = function() print("stub: incrementDroidCounter"); return 0 end end
if checkBestBody == nil then checkBestBody = function() print("stub: checkBestBody"); return 0 end end
if anyFactoriesLeft == nil then anyFactoriesLeft = function() print("stub: anyFactoriesLeft"); return 0 end end
if getFreePosDroid == nil then getFreePosDroid = function() print("stub: getFreePosDroid"); return 0 end end
if deactivateTankAttack == nil then deactivateTankAttack = function() print("stub: deactivateTankAttack"); return 0 end end
if numAAinRange == nil then numAAinRange = function() print("stub: numAAinRange"); return 0 end end
if orderDroidLoc == nil then orderDroidLoc = function() print("stub: orderDroidLoc"); return 0 end end
if updateGateways == nil then updateGateways = function() print("stub: updateGateways"); return 0 end end
if orderGroup == nil then orderGroup = function() print("stub: orderGroup"); return 0 end end
if find_Research == nil then find_Research = function() print("stub: find_Research"); return 0 end end
if skLocateEnemy == nil then skLocateEnemy = function() print("stub: skLocateEnemy"); return 0 end end
if numTemplatesInProduction == nil then numTemplatesInProduction = function() print("stub: numTemplatesInProduction"); return 0 end end
if do_Research == nil then do_Research = function() print("stub: do_Research"); return 0 end end
if checkIfDroidIsStuck == nil then checkIfDroidIsStuck = function() print("stub: checkIfDroidIsStuck"); return 0 end end
if enumStruct == nil then enumStruct = function() print("stub: enumStruct"); return 0 end end
if addPower == nil then addPower = function() print("stub: addPower"); return 0 end end
if closestEnemyDerrick == nil then closestEnemyDerrick = function() print("stub: closestEnemyDerrick"); return 0 end end
if objToDroid == nil then objToDroid = function() print("stub: objToDroid"); return 0 end end
if initGetFeature == nil then initGetFeature = function() print("stub: initGetFeature"); return 0 end end
if orderGroupObj == nil then orderGroupObj = function() print("stub: orderGroupObj"); return 0 end end
if updateBaseCoord == nil then updateBaseCoord = function() print("stub: updateBaseCoord"); return 0 end end
if calcDroidPower == nil then calcDroidPower = function() print("stub: calcDroidPower"); return 0 end end
if getWeaponUnitsInfo == nil then getWeaponUnitsInfo = function() print("stub: getWeaponUnitsInfo"); return 0 end end
if setStructTarIgnore == nil then setStructTarIgnore = function() print("stub: setStructTarIgnore"); return 0 end end
if friendlyWeapObjCostInRange == nil then friendlyWeapObjCostInRange = function() print("stub: friendlyWeapObjCostInRange"); return 0 end end
if closestIdleDroid == nil then closestIdleDroid = function() print("stub: closestIdleDroid"); return 0 end end
if orderGroupLoc == nil then orderGroupLoc = function() print("stub: orderGroupLoc"); return 0 end end
if skVtolEnableCheck == nil then skVtolEnableCheck = function() print("stub: skVtolEnableCheck"); return 0 end end
if getFeature == nil then getFeature = function() print("stub: getFeature"); return 0 end end
if closestDerrickToDefend == nil then closestDerrickToDefend = function() print("stub: closestDerrickToDefend"); return 0 end end
if myResponsibility == nil then myResponsibility = function() print("stub: myResponsibility"); return 0 end end
if objHumanDerrick == nil then objHumanDerrick = function() print("stub: objHumanDerrick"); return 0 end end
if droidTargetInArea == nil then droidTargetInArea = function() print("stub: droidTargetInArea"); return 0 end end
if buildHeavyTank == nil then buildHeavyTank = function() print("stub: buildHeavyTank"); return 0 end end
if do_CheapResearch == nil then do_CheapResearch = function() print("stub: do_CheapResearch"); return 0 end end
if centreView == nil then centreView = function() print("stub: centreView"); return 0 end end
if getDroidCount == nil then getDroidCount = function() print("stub: getDroidCount"); return 0 end end
if notifyStatus == nil then notifyStatus = function() print("stub: notifyStatus"); return 0 end end
if manageVeryLowPower == nil then manageVeryLowPower = function() print("stub: manageVeryLowPower"); return 0 end end
if msg == nil then msg = function() print("stub: msg"); return 0 end end
if getNearestGateway == nil then getNearestGateway = function() print("stub: getNearestGateway"); return 0 end end
if buildRearmPads == nil then buildRearmPads = function() print("stub: buildRearmPads"); return 0 end end
if orderDroid == nil then orderDroid = function() print("stub: orderDroid"); return 0 end end
if haveAnyBeacon == nil then haveAnyBeacon = function() print("stub: haveAnyBeacon"); return 0 end end
if structInRange == nil then structInRange = function() print("stub: structInRange"); return 0 end end
if attackedByStruct == nil then attackedByStruct = function() print("stub: attackedByStruct"); return 0 end end
if getOilResTargetFree == nil then getOilResTargetFree = function() print("stub: getOilResTargetFree"); return 0 end end
if resetStructTargets == nil then resetStructTargets = function() print("stub: resetStructTargets"); return 0 end end
if setStructTarPref == nil then setStructTarPref = function() print("stub: setStructTarPref"); return 0 end end
if objStrTargetInRange == nil then objStrTargetInRange = function() print("stub: objStrTargetInRange"); return 0 end end
if assignDroidToGrp == nil then assignDroidToGrp = function() print("stub: assignDroidToGrp"); return 0 end end
if displayMsg == nil then displayMsg = function() print("stub: displayMsg"); return 0 end end
if cleanDroidPos == nil then cleanDroidPos = function() print("stub: cleanDroidPos"); return 0 end end
if pursueResearch == nil then pursueResearch = function() print("stub: pursueResearch"); return 0 end end
if groupAddAreaNoGroup == nil then groupAddAreaNoGroup = function() print("stub: groupAddAreaNoGroup"); return 0 end end
if structureIdle == nil then structureIdle = function() print("stub: structureIdle"); return 0 end end
if objToStructure == nil then objToStructure = function() print("stub: objToStructure"); return 0 end end
if gameType == nil then gameType = function() print("stub: gameType"); return 0 end end
if bHelpingAnyAlly == nil then bHelpingAnyAlly = function() print("stub: bHelpingAnyAlly"); return 0 end end
if nearestDroidToBeRepaired == nil then nearestDroidToBeRepaired = function() print("stub: nearestDroidToBeRepaired"); return 0 end end
if friendlyPlayer == nil then friendlyPlayer = function() print("stub: friendlyPlayer"); return 0 end end
if printDebug1 == nil then printDebug1 = function() print("stub: printDebug1"); return 0 end end
if bAnyOilResLeft == nil then bAnyOilResLeft = function() print("stub: bAnyOilResLeft"); return 0 end end
if setDroidTarIgnore == nil then setDroidTarIgnore = function() print("stub: setDroidTarIgnore"); return 0 end end
if _random == nil then _random = function() print("stub: _random"); return 0 end end
if numResearchLeft == nil then numResearchLeft = function() print("stub: numResearchLeft"); return 0 end end
if ASSERT == nil then ASSERT = function() print("stub: ASSERT"); return 0 end end
if numRemainingOilRes == nil then numRemainingOilRes = function() print("stub: numRemainingOilRes"); return 0 end end
if skDifficultyModifier == nil then skDifficultyModifier = function() print("stub: skDifficultyModifier"); return 0 end end
if initAllNoGoAreas == nil then initAllNoGoAreas = function() print("stub: initAllNoGoAreas"); return 0 end end
if beaconTimeout == nil then beaconTimeout = function() print("stub: beaconTimeout"); return 0 end end
if iterateGroup == nil then iterateGroup = function() print("stub: iterateGroup"); return 0 end end
if initAssignUnitToGrp == nil then initAssignUnitToGrp = function() print("stub: initAssignUnitToGrp"); return 0 end end
if getChatCmdDescription == nil then getChatCmdDescription = function() print("stub: getChatCmdDescription"); return 0 end end
if math.min == nil then math.min = function() print("stub: math.min"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if resetDroidTargets == nil then resetDroidTargets = function() print("stub: resetDroidTargets"); return 0 end end
if cleanDroidCoordArray == nil then cleanDroidCoordArray = function() print("stub: cleanDroidCoordArray"); return 0 end end
if isVtol == nil then isVtol = function() print("stub: isVtol"); return 0 end end
if vtolFactoryBuildVtol == nil then vtolFactoryBuildVtol = function() print("stub: vtolFactoryBuildVtol"); return 0 end end
if getVTOLstructTarget == nil then getVTOLstructTarget = function() print("stub: getVTOLstructTarget"); return 0 end end
if getEnemy_baseCoord == nil then getEnemy_baseCoord = function() print("stub: getEnemy_baseCoord"); return 0 end end
if droidOrderIdle == nil then droidOrderIdle = function() print("stub: droidOrderIdle"); return 0 end end
if repairStructs == nil then repairStructs = function() print("stub: repairStructs"); return 0 end end
if updateDefendRange == nil then updateDefendRange = function() print("stub: updateDefendRange"); return 0 end end
if orderDroidObj == nil then orderDroidObj = function() print("stub: orderDroidObj"); return 0 end end
if math.max == nil then math.max = function() print("stub: math.max"); return 0 end end
if dbgMsgOn == nil then dbgMsgOn = function() print("stub: dbgMsgOn"); return 0 end end
if getAAStruct == nil then getAAStruct = function() print("stub: getAAStruct"); return 0 end end
if enemyWeapObjCostInRange == nil then enemyWeapObjCostInRange = function() print("stub: enemyWeapObjCostInRange"); return 0 end end
if updateDroidCoord == nil then updateDroidCoord = function() print("stub: updateDroidCoord"); return 0 end end
if numDroidsInArea == nil then numDroidsInArea = function() print("stub: numDroidsInArea"); return 0 end end
if sendIdleBackToTheBase == nil then sendIdleBackToTheBase = function() print("stub: sendIdleBackToTheBase"); return 0 end end
if skCanBuildTemplate == nil then skCanBuildTemplate = function() print("stub: skCanBuildTemplate"); return 0 end end
if numFriendlyWeapStructsInRange == nil then numFriendlyWeapStructsInRange = function() print("stub: numFriendlyWeapStructsInRange"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if getADroid == nil then getADroid = function() print("stub: getADroid"); return 0 end end
if stopDroidHarvesting == nil then stopDroidHarvesting = function() print("stub: stopDroidHarvesting"); return 0 end end
if undefendedEnemyDerrick == nil then undefendedEnemyDerrick = function() print("stub: undefendedEnemyDerrick"); return 0 end end
if idleRepairDroid == nil then idleRepairDroid = function() print("stub: idleRepairDroid"); return 0 end end
if buildDroid == nil then buildDroid = function() print("stub: buildDroid"); return 0 end end
if researchFinished == nil then researchFinished = function() print("stub: researchFinished"); return 0 end end
if getTargetObj == nil then getTargetObj = function() print("stub: getTargetObj"); return 0 end end
if updateBaseRange == nil then updateBaseRange = function() print("stub: updateBaseRange"); return 0 end end
if canHelpAlly == nil then canHelpAlly = function() print("stub: canHelpAlly"); return 0 end end
if isPlayerStillLive == nil then isPlayerStillLive = function() print("stub: isPlayerStillLive"); return 0 end end
if haveBeacon == nil then haveBeacon = function() print("stub: haveBeacon"); return 0 end end
if skGetFactoryCapacity == nil then skGetFactoryCapacity = function() print("stub: skGetFactoryCapacity"); return 0 end end
if structureComplete == nil then structureComplete = function() print("stub: structureComplete"); return 0 end end
if orderGroupScoutCMD == nil then orderGroupScoutCMD = function() print("stub: orderGroupScoutCMD"); return 0 end end
if aiResponsibleForPlayer == nil then aiResponsibleForPlayer = function() print("stub: aiResponsibleForPlayer"); return 0 end end
if setDroidTarPref == nil then setDroidTarPref = function() print("stub: setDroidTarPref"); return 0 end end
