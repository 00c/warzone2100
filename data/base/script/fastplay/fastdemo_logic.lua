-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for

-- Define Players/Enemies
-- MAX targets = 4, need array one bigger!
targetCount = Array(2)
targetX = Array(2, 5)
targetY = Array(2, 5)

-- Starting Enemy Power

-- Structure Limits

-- Initialisation

-- Briefings

-- Victory Conditions
victoryX = Array(2)
victoryY = Array(2)

-- Objectives
objectiveFlag = Array(3)
objectivesDone = 0

-- Artifacts
-- public		INTMESSAGE	artMsg[6];
artID = Array(6)
artFlag = Array(6)
artCollected = 0

-- Enemy Base Blips
baseFlag = Array(5)
basesDead = 0
iMidX = 0
iMidY = 0

-- Groups
-- these can be for any player!
-- keep track of already triggered groups
grpFlagGo = Array(10)
-- the actual groups are stored in this, based on region.
grpGroup = Array(10)
grpReinforce = Array(10)
-- keep track of current waypoint
grpPosCurrent = Array(10)
-- keep track of already ordered
grpBusy = Array(10)
-- keeps track of time since started level, for triggering groups
timeGroup = 0

-- Factories
-- these can be for any player!
-- stores whether producing or not
factFlagGo = Array(10)

-- LISTS OF STUFF (INDEXED BY ARRAY)

droids = Array(10)
sectorsX1 = Array(20)
sectorsY1 = Array(20)
sectorsX2 = Array(20)
sectorsY2 = Array(20)


-- 'Globals'
-- artifact pickup/obj blip removal
-- range to waypoints/range for targets
-- maximum number of targets (4)
-- mission won
-- mission lost
-- Base Under Attack Sound
-- base detected/dead

-- General variables
-- for while loops
count = 0
count2 = 0
testDroid = nil
newDroid = nil
-- new droid built
newDroidFactory = nil
countBriefs = 0
temp = 0
temp1 = 0
temp2 = 0
tempX = 0
tempY = 0
-- Base Under Attack
hitStruc = nil
-- Base Under Attack
attackerObj = nil
-- Base Under Attack time delay for next warning
t = 0
-- for enemy base attack stuff!
enemyCount = 0

-- ********************
-- Events
-- ********************

-- Declared Events

-- Initialisation
function start()
	centreViewPos(centreX, centreY)
	-- set alliances
	if allianceFlag and numEnemies > 1 then
		count = 0
		while count < numEnemies do
			count2 = 0
			while count2 < numEnemies do
				if count ~= count2 then
					createAlliance(enemy[count], enemy[count2])
				end
				count2 = count2 + 1
			end
			count = count + 1
		end
	end
	
	-- set scroll limits
	setScrollParams(scrollX1, scrollY1, scrollX2, scrollY2)
	
	-- set radar zoom level
	setRadarZoom(zoomLevel)
	
	-- set LZ and no go areas
	initAllNoGoAreas()
	count = 0
	while count < numLZ do
		setNoGoArea(LZX[count] - 1, LZY[count] - 1, LZX[count] + 1, LZY[count] + 1, count)
		count = count + 1
	end
	
	-- set structure limits
	count = 0
	while count < numStrucStats do
		setStructureLimits(strucStat[count], strucLimit[count], player)
		enableStructure(strucStat[count], player)
		count = count + 1
	end
	
	-- set power levels
	count = 0
	while count < numEnemies do
		count2 = 0
		while count2 < numTechs[count] do
			completeResearch(startTech[count][count2], enemy[count])
			count2 = count2 + 1
		end
		setPowerLevel(power[count], enemy[count])
		count = count + 1
	end
	
	-- show player start objectives
	count = 0
	while count < numObjectives do
		addMessage(objective[count], PROX_MSG, player, false)
		count = count + 1
	end
	
	-- Setup Artifacts already on map (NOT TESTED YET!)
	-- setting flags incorrectly in VLO could break game!
	count = 0
	while count < numArt do
		if artType[count] >= 4 then
			artFlag[count] = 4
		end
		-- deal with artifact already on map
		if artType[count] == 0 then
			artID[count] = features[artVal[count]]
			artFlag[count] = 1
		end
		count = count + 1
	end
	
	-- setup groups
	count = 0
	while count < numGroups do
		groupAddArea(grpGroup[count], grpPlayer[count], regionsX1[grpRegion[count]], regionsY1[grpRegion[count]], regionsX2[grpRegion[count]], regionsY2[grpRegion[count]])
		grpPosCurrent[count] = grpPosStart[count]
		-- set morale levels
		if grpMorale[count] >= 0 then
			setGroupRetreatForce(grpGroup[count], grpMorale[count])
			setGroupRetreatLeadership(grpGroup[count], grpLeadership[count])
			-- use coords for patrol/ambush/defence
			if grpType[count] < 2 then
				setGroupRetreatPoint(grpGroup[count], coordsX[grpRetreatXY[count]], coordsY[grpRetreatXY[count]])
			else
				temp = grpRetreatXY[count]
				-- order scout/attack forces to random position in this sector
				tempX = sectorsX1[temp] + random(sectorsX2[temp] - sectorsX1[temp])
				tempY = sectorsY1[temp] + random(sectorsY2[temp] - sectorsY1[temp])
				setGroupRetreatPoint(grpGroup[count], tempX, tempY)
			end
		end
		-- set time = 0 groups going
		if grpTimeGo[count] == timeGroup then
			grpFlagGo[count] = true
			-- use coords for patrol/ambush/defence
			if grpType[count] < 2 then
				if grpPosStart[count] >= 0 then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
				end
			else
				temp = grpPosCurrent[count]
				-- order scout/attack forces to random position in this sector
				tempX = sectorsX1[temp] + random(sectorsX2[temp] - sectorsX1[temp])
				tempY = sectorsY1[temp] + random(sectorsY2[temp] - sectorsY1[temp])
				orderGroupLoc(grpGroup[count], DORDER_MOVE, tempX, tempY)
			end
		end
		count = count + 1
	end
	-- set time = 0 factories going
	count = 0
	while count < numFactories do
		if factAssXY[count] ~= -1 then
			setAssemblyPoint(structures[factID[count]], coordsX[factAssXY[count]], coordsY[factAssXY[count]])
		end
		if (factTimeGo[count] == timeGroup) and (not factFlagGo[count]) then
			factFlagGo[count] = true
		end
		count = count + 1
	end
	
	-- play mission brief(s)
	if numBriefs > 0 then
		addMessage(brief[0], MISS_MSG, 0, true)
		countBriefs = 1
	end
end
callbackEvent(start, CALL_GAMEINIT)

-- need to rework this better!!
function briefings()
	if countBriefs >= numBriefs then
		deactivateEvent(briefings)
	end
	-- remove last, add next?
	if countBriefs < numBriefs then
		removeMessage(brief[countBriefs - 1], MISS_MSG, 0)
		addMessage(brief[countBriefs], MISS_MSG, 0, true)
		countBriefs = countBriefs + 1
	end
end
callbackEvent(briefings, CALL_VIDEO_QUIT)

-- Base Under Attack
function baseHit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= C.selectedPlayer then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if t >= 10 then
		t = 0
		playSoundPos(attackSnd1, player, hitStruc.x, hitStruc.y, hitStruc.z)
	end
end
callbackEvent(baseHit, CALL_STRUCT_ATTACKED)

-- update time delay before told again (about 20 seconds)
function everySec()
	t = t + 1
end
repeatingEvent(everySec, 2.0)

-- Remove Objective Blips
function removeObjectives()
	if objectivesDone == numObjectives then
		deactivateEvent(removeObjectives)
	else
		count = 0
		while count < numObjectives do
			if (not objectiveFlag[count]) and (droidInRange(player, objectiveX[count], objectiveY[count], objectiveRange)) then
				objectiveFlag[count] = true
				objectivesDone = objectivesDone + 1
				removeMessage(objective[count], PROX_MSG, player)
			end
			count = count + 1
		end
	end
end
repeatingEvent(removeObjectives, 1.5)

-- Artifacts
-- This works for artifacts from STRUCTURES, FEATURES or DROIDS as well as crates already on map!
-- tested for STRUCTURES, FEATURES, DROIDS and starting CRATES
-- update artifact list
function artLoop()
	if artCollected == numArt then
		deactivateEvent(artLoop)
	else
		count = 0
		while count < numArt do
			if artFlag[count] == 0 then
				temp = 0
				-- might be a better way to do this check?
				if artType[count] == 1 then
					if structures[artVal[count]] == nil then
						temp = 1
					end
				end
				if artType[count] == 2 then
					if features[artVal[count]] == nil then
						temp = 1
					end
				end
				if artType[count] == 3 then
					if droids[artVal[count]] == nil then
						temp = 1
					end
				end
				-- OK to place crate?
				if temp == 1 then
					artID[count] = addFeature(crate, artX[count], artY[count])
					artFlag[count] = 1
				end
			end
			if artFlag[count] == 1 then
				artFlag[count] = 2
			end
			if artFlag[count] == 2 then
				if droidInRange(player, artX[count], artY[count], artRange) then
					artCollected = artCollected + 1
					artFlag[count] = 3
					playSoundPos(artSnd2, player, artID[count].x, artID[count].y, artID[count].z)
					destroyFeature(artID[count])
					-- removeMessage(artMsg[count], PROX_MSG, player);
					enableResearch(artComp[count], player)
				end
			end
			if artType[count] == 3 then
				if droids[artVal[count]] ~= nil then
					artX[count] = droids[artVal[count]].x
					artY[count] = droids[artVal[count]].y
				end
			end
			count = count + 1
		end
	end
end
repeatingEvent(artLoop, 1.0)


-- Enemy Base Blips
-- update base blips
function baseLoop()
	if basesDead == numBases then
		deactivateEvent(baseLoop)
	else
		count = 0
		while count < numBases do
			if baseFlag[count] == 0 then
				if seenStructInArea(player, basePlayer[count], false, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]]) then
					addMessage(baseMsg[count], PROX_MSG, player, false)
					if baseWav1[count] >= 0 then
						iMidX = (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2
						iMidY = (regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2
						playSoundPos(baseSnd[baseWav1[count]], player, iMidX, iMidY, 0)
					end
					baseFlag[count] = 1
				end
			end
			if baseFlag[count] == 1 then
				if numStructsButNotWallsInArea(basePlayer[count], regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]]) == 0 then
					basesDead = basesDead + 1
					baseFlag[count] = 2
					if baseWav2[count] >= 0 then
						iMidX = (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2
						iMidY = (regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2
						playSoundPos(baseSnd[baseWav2[count]], player, iMidX, iMidY, 0)
					end
					-- playSound(baseSnd[baseWav2[count]], player);
					removeMessage(baseMsg[count], PROX_MSG, player)
					-- remove walls and building features in base
					killStructsInArea(basePlayer[count], REF_WALL, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]], true, true)
					-- remove corner walls in base
					killStructsInArea(basePlayer[count], REF_WALLCORNER, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]], true, false)
				end
			end
			
			count = count + 1
		end
	end
end
repeatingEvent(baseLoop, 1.5)

-- Events: Win or Lose
-- assumes victory already checked
function nextLevEvnt()
	flushConsoleMessages()
	playSound(wonSnd, 0)
	pause(20/10.0)
	-- give all research
	count = 0
	while count < numArt do
		enableResearch(artComp[count], 0)
		count = count + 1
	end
	-- *required for sub missions*
	-- setLandingZone(10, 51, 12, 53);
	-- *no longer need to remove briefings?*
	-- removeMessage(MissionBrief, MISS_MSG, player);
	-- startMission(CAMP_EXPAND, NextLev);
	-- End game here for now! (don't try next mission)
	gameOverMessage(winMsg, MISS_MSG, 0, true)
	
	deactivateEvent(nextLevEvnt)
end

-- skip to end of level
-- cheat button ctrl M
function cheatEvnt()
	repeatingEvent(nextLevEvnt, 2.0)
	deactivateEvent(cheatEvnt)
end
callbackEvent(cheatEvnt, CALL_MISSION_START)
function gameLost()
	gameOverMessage(endMsg, MISS_MSG, 0, false)
	deactivateEvent(gameLost)
end

-- triggered on (not anyDroidsLeft(player))
function lostYetEvnt()
	if not anyStructButWallsLeft(player) then
		deactivateEvent(wonYetEvnt)
		deactivateEvent(timeUp)
		-- waits 2 seconds before ending
		repeatingEvent(gameLost, 2.0)
		-- playSound(lostSnd,0);
		deactivateEvent(lostYetEvnt)
	end
end
conditionalEvent(lostYetEvnt, "not anyDroidsLeft(player)", 2.5)

-- out of time?
function timeUp()
	deactivateEvent(wonYetEvnt)
	deactivateEvent(lostYetEvnt)
	-- may want different sound, eg "Out of Time"
	playSound(lostSnd, 0)
	-- waits 2 seconds before ending
	repeatingEvent(gameLost, 2.0)
	deactivateEvent(timeUp)
end
callbackEvent(timeUp, CALL_MISSION_TIME)

-- triggered on (artCollected == victoryArt)
function wonYetEvnt()
	temp2 = 0
	-- needs to check various victory conditions setup in VLO
	
	-- check all enemy vehicles and structures destroyed
	if victory[0] then
		count = 0
		temp = 0
		while count < numEnemies do
			if (not anyDroidsLeft(enemy[count])) and (not anyStructButWallsLeft(enemy[count])) then
				temp = temp + 1
			end
			count = count + 1
		end
		if temp == numEnemies then
			temp2 = temp2 + 1
		end
	end
	
	-- check all player vehicles in specific area (eg LZ)
	if victory[1] then
		temp = numDroidsInArea(player, 0, 0, scrollX1 * 128, scrollY1 * 128)
		if temp == numDroidsInArea(player, victoryX[0], victoryY[0], victoryX[1], victoryY[1]) then
			if temp ~= 0 then
				temp2 = temp2 + 1
			end
		end
	end
	
	-- victory reached?
	if temp2 == numVictory then
		deactivateEvent(lostYetEvnt)
		deactivateEvent(timeUp)
		repeatingEvent(nextLevEvnt, 2.0)
		deactivateEvent(wonYetEvnt)
	end
end
conditionalEvent(wonYetEvnt, "artCollected == victoryArt", 2.5)

-- Enemy AI

function wayGroups()
	count = 0
	while count < numGroups do
		if (grpFlagGo[count]) and (grpType[count] < 2) and (grpPosStart[count] >= 0) then
			if groupCountMembers(grpGroup[count]) > 0 then
				grpBusy[count] = false
				-- store for checking difference later
				temp = grpPosCurrent[count]
				-- random choice
				if grpPosType[count] == 3 then
					grpPosCurrent[count] = grpPosMin[count] + grpPosStep[count] * random(grpPosMax[count] - grpPosMin[count])
				else
					grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
				end
				if (grpPosCurrent[count] > grpPosMax[count]) or (grpPosCurrent[count] < grpPosMin[count]) then
					grpPosCurrent[count] = grpPosCurrent[count] - grpPosStep[count]
					-- loop
					if grpPosType[count] == 1 then
						if grpPosStep[count] > 0 then
							grpPosCurrent[count] = grpPosMin[count]
						else
							grpPosCurrent[count] = grpPosMax[count]
						end
					end
					-- ping pong
					if grpPosType[count] == 2 then
						grpPosStep[count] = -grpPosStep[count]
						grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
					end
				end
				-- don't order again if already there!
				if grpPosCurrent[count] ~= temp then
					orderGroupLoc(grpGroup[count], DORDER_MOVE, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]])
				end
			end
		end
		count = count + 1
	end
end
repeatingEvent(wayGroups, 10.0)


function factoryProdEvnt()
	count = 0
	while count < numFactories do
		if structures[factID[count]] == nil then
			factFlagGo[count] = false
		end
		-- switched on and not producing anything?
		if factFlagGo[count] then
			if structureIdle(structures[factID[count]]) then
				temp = random(factTempMax[count] - factTempMin[count]) + factTempMin[count]
				-- build random number (less for better stuff)
				temp2 = random(factTempMax[count] - temp) + 1
				buildDroid(templates[temp], structures[factID[count]], structures[factID[count]].player, temp2)
			end
		end
		count = count + 1
	end
end
repeatingEvent(factoryProdEvnt, 45.0)

-- triggered by later callbacks
function droidBuilt()
	temp2 = 0
	-- in case not found
	temp = -1
	if newDroidFactory ~= nil then
		count = 0
		while count < numFactories do
			if newDroidFactory == structures[factID[count]] then
				temp = factID[count]
			end
			count = count + 1
		end
	end
	-- check thru groups to reinforce
	count = 0
	while count < numGroups do
		if ((temp == grpFactory[count]) or (grpFactory[count] == -1)) and (groupCountMembers(grpGroup[count]) < grpIdealSize[count]) then
			groupAddDroid(grpReinforce[count], newDroid)
			-- orderGroupLoc(grpReinforce[count], DORDER_MOVE, 8000, 13000);	//test for now
			
			-- if ideal size, add to main group!
			if (groupCountMembers(grpGroup[count]) + groupCountMembers(grpReinforce[count])) >= grpIdealSize[count] then
				groupAddGroup(grpGroup[count], grpReinforce[count])
			end
			-- grpPosCurrent[count] = grpPosMin[count];		//test for now so can see if added to group
			-- if group dead, add to group and reset starting sector?
			if groupCountMembers(grpGroup[count]) == 0 then
				groupAddGroup(grpGroup[count], grpReinforce[count])
				-- set back to start sector...?
				-- go back to min sector if starting group from scratch
				grpPosCurrent[count] = grpPosMin[count]
			end
			-- test order only!!!
			-- orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]]);
			-- exit early
			count = numGroups
			temp2 = 1
		end
		count = count + 1
	end
end
-- if temp2 != 0, ie not assigned to a group, put in a special group for that player, and pull out if a group can take from any and
-- needs reinforcing. (another event to check thru pooled group?)
-- still to be done!


-- hack to allow CALL_NEWDROID to work with unspecified enemy players!!!!
function droidBuilt1(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 1 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt1, CALL_NEWDROID)

function droidBuilt2(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 2 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt2, CALL_NEWDROID)

function droidBuilt3(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 3 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt3, CALL_NEWDROID)

function droidBuilt4(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 4 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt4, CALL_NEWDROID)

function droidBuilt5(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 5 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt5, CALL_NEWDROID)

function droidBuilt6(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 6 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt6, CALL_NEWDROID)

function droidBuilt7(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 7 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt7, CALL_NEWDROID)

function regionGroupsEvnt()
	count = 0
	while count < numGroups do
		if (not grpFlagGo[count]) and (grpType[count] ~= 1) and (grpRegionGo[count] >= 0) then
			if droidInArea(grpWhoGo[count], regionsX1[grpRegionGo[count]], regionsY1[grpRegionGo[count]], regionsX2[grpRegionGo[count]], regionsY2[grpRegionGo[count]]) then
				grpFlagGo[count] = true
				-- scouts and attack forces don't use coords array, so don't bother with initial order!
				if grpType[count] < 2 then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
				end
			end
		end
		count = count + 1
	end
	-- check for factories
	count = 0
	while count < numFactories do
		if (not factFlagGo[count]) and (factRegionGo[count] >= 0) then
			if droidInArea(player, regionsX1[factRegionGo[count]], regionsY1[factRegionGo[count]], regionsX2[factRegionGo[count]], regionsY2[factRegionGo[count]]) then
				factFlagGo[count] = true
			end
		end
		count = count + 1
	end
end
repeatingEvent(regionGroupsEvnt, 1.1)

-- update time count for triggering groups and factories...
function timeGroupsEvnt()
	timeGroup = timeGroup + 1
	count = 0
	-- update groups
	while count < numGroups do
		if (grpTimeGo[count] == timeGroup) and (not grpFlagGo[count]) then
			grpFlagGo[count] = true
			-- scouts don't use coords array, so don't bother with initial order!
			if grpType[count] < 2 then
				orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
			end
		end
		count = count + 1
	end
	-- update factories
	count = 0
	while count < numFactories do
		if (factTimeGo[count] == timeGroup) and (not factFlagGo[count]) then
			factFlagGo[count] = true
		end
		count = count + 1
	end
end
repeatingEvent(timeGroupsEvnt, 10.0)

function enemyBaseHit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= enemy[enemyCount] then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if (attackerObj ~= nil) and (hitStruc ~= nil) then
		count = 0
		while count < numGroups do
			if (grpType[count] == 1) and (grpPlayer[count] == enemy[enemyCount]) and (not grpBusy[count]) then
				if grpRegionGo[count] < 0 then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, attackerObj.x, attackerObj.y)
					grpBusy[count] = true
					-- break out of loop, since found
					count = numGroups
				else
					if (hitStruc.x >= regionsX1[grpRegionGo[count]]) and (hitStruc.x <= regionsX2[grpRegionGo[count]]) and (hitStruc.y >= regionsY1[grpRegionGo[count]]) and (hitStruc.y <= regionsY2[grpRegionGo[count]]) then
						orderGroupLoc(grpGroup[count], DORDER_SCOUT, attackerObj.x, attackerObj.y)
						grpBusy[count] = true
						-- break out of loop, since found
						count = numGroups
					end
				end
			end
			count = count + 1
		end
	end
end
callbackEvent(enemyBaseHit, CALL_STRUCT_ATTACKED)


-- Updates enemyCount for enemyBaseHit event.
function updateEnemy()
	if enemyCount < numEnemies - 1 then
		enemyCount = enemyCount + 1
	else
		enemyCount = 0
	end
end
repeatingEvent(updateEnemy, 2.1)


---------- stubs ----------

if anyStructButWallsLeft == nil then anyStructButWallsLeft = function() print("stub: anyStructButWallsLeft"); return 0 end end
if gameOverMessage == nil then gameOverMessage = function() print("stub: gameOverMessage"); return 0 end end
if random == nil then random = function() print("stub: random"); return 0 end end
if enableResearch == nil then enableResearch = function() print("stub: enableResearch"); return 0 end end
if droidInArea == nil then droidInArea = function() print("stub: droidInArea"); return 0 end end
if addFeature == nil then addFeature = function() print("stub: addFeature"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if initAllNoGoAreas == nil then initAllNoGoAreas = function() print("stub: initAllNoGoAreas"); return 0 end end
if orderGroupLoc == nil then orderGroupLoc = function() print("stub: orderGroupLoc"); return 0 end end
if anyDroidsLeft == nil then anyDroidsLeft = function() print("stub: anyDroidsLeft"); return 0 end end
if droidInRange == nil then droidInRange = function() print("stub: droidInRange"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if removeMessage == nil then removeMessage = function() print("stub: removeMessage"); return 0 end end
if destroyFeature == nil then destroyFeature = function() print("stub: destroyFeature"); return 0 end end
if setGroupRetreatPoint == nil then setGroupRetreatPoint = function() print("stub: setGroupRetreatPoint"); return 0 end end
if setStructureLimits == nil then setStructureLimits = function() print("stub: setStructureLimits"); return 0 end end
if setPowerLevel == nil then setPowerLevel = function() print("stub: setPowerLevel"); return 0 end end
if groupAddArea == nil then groupAddArea = function() print("stub: groupAddArea"); return 0 end end
if setGroupRetreatForce == nil then setGroupRetreatForce = function() print("stub: setGroupRetreatForce"); return 0 end end
if playSoundPos == nil then playSoundPos = function() print("stub: playSoundPos"); return 0 end end
if killStructsInArea == nil then killStructsInArea = function() print("stub: killStructsInArea"); return 0 end end
if completeResearch == nil then completeResearch = function() print("stub: completeResearch"); return 0 end end
if numDroidsInArea == nil then numDroidsInArea = function() print("stub: numDroidsInArea"); return 0 end end
if setScrollParams == nil then setScrollParams = function() print("stub: setScrollParams"); return 0 end end
if pause == nil then pause = function() print("stub: pause"); return 0 end end
if setNoGoArea == nil then setNoGoArea = function() print("stub: setNoGoArea"); return 0 end end
if numStructsButNotWallsInArea == nil then numStructsButNotWallsInArea = function() print("stub: numStructsButNotWallsInArea"); return 0 end end
if createAlliance == nil then createAlliance = function() print("stub: createAlliance"); return 0 end end
if playSound == nil then playSound = function() print("stub: playSound"); return 0 end end
if buildDroid == nil then buildDroid = function() print("stub: buildDroid"); return 0 end end
if seenStructInArea == nil then seenStructInArea = function() print("stub: seenStructInArea"); return 0 end end
if groupAddGroup == nil then groupAddGroup = function() print("stub: groupAddGroup"); return 0 end end
if addMessage == nil then addMessage = function() print("stub: addMessage"); return 0 end end
if setRadarZoom == nil then setRadarZoom = function() print("stub: setRadarZoom"); return 0 end end
if structureIdle == nil then structureIdle = function() print("stub: structureIdle"); return 0 end end
if enableStructure == nil then enableStructure = function() print("stub: enableStructure"); return 0 end end
if setGroupRetreatLeadership == nil then setGroupRetreatLeadership = function() print("stub: setGroupRetreatLeadership"); return 0 end end
if flushConsoleMessages == nil then flushConsoleMessages = function() print("stub: flushConsoleMessages"); return 0 end end
if centreViewPos == nil then centreViewPos = function() print("stub: centreViewPos"); return 0 end end
if setAssemblyPoint == nil then setAssemblyPoint = function() print("stub: setAssemblyPoint"); return 0 end end
