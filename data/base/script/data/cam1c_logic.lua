-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for
numart = 0

newDroidFactory = nil

-- structure limit stuff
-- public	STRUCTURESTAT		powerModuleHack;

-- Win or lose
allPlayer = Group()
nearLZ = Group()
totDroids = 0

-- required for enemy transports landing
transportDroid = nil
loadDroid = nil
reinforceTemplate = nil
transOnMap = false

-- Base Under Attack Stuff
hitStruc = nil
attackerObj = nil
viewerObj = nil
targetObj = nil
t = 0
targetDroid = nil

-- Briefing stuff
-- public		INTMESSAGE		NewParadigm_MSG1, NewParadigm_MSG2;
-- , winMsg;
-- enemy LZ's

-- Proximity: Resources
--[[public		FEATURE		res1;
public		INTMESSAGE	res1Msg;
public		SOUND		res1Snd;
public		STRUCTURESTAT	derrick;
private		int		res1x,res1y;	//temp values to cope with oil disappearing!]]--

-- Proximity: Artifacts

-- public		INTMESSAGE	art1Msg;
art1ID = nil

-- public		INTMESSAGE	art2Msg;
art2ID = nil

-- public		INTMESSAGE	art3Msg;
art3ID = nil

--[[No longer used
public		int		art4X, art4Y;
public		STRUCTURE	art4Get;
public		SOUND		art4Snd2;
//public		INTMESSAGE	art4Msg;
public		RESEARCHSTAT	art4Comp;
private		FEATURE		art4ID;]]--

-- public		INTMESSAGE	art5Msg;
art5ID = nil

-- player Bonus Research topics given at end of mission
-- need to be declared with value >= numResP0, numResP1, etc.
count = 0

-- Proximity: Enemy

-- public		INTMESSAGE	enm1Msg;
-- public		SOUND		enm1Snd1;
-- public		SOUND		enm1Snd2;

-- enm2d;
-- enm2dID;

-- public		INTMESSAGE	enm2Msg;
-- public		SOUND		enm2Snd1;
-- public		SOUND		enm2Snd2;

-- AI STUFF

-- enemy1 variables
enemy1Build = Group()
enemy1Attack = Group()
enemy1Start = Group()
enemy1Fin = Group()
enemy1Force1 = Group()
enemy1Force2 = Group()
enemy2Build = Group()
enemy2Attack = Group()
enemy2Start = Group()
enemy2Fin = Group()
enemy1Guard = Group()
enemy2Guard = Group()
Strike3 = Group()
Ambush1 = Group()
Reserve1 = Group()
IDF1 = Group()
dummy1 = Group()
dummy2 = Group()
Scav1 = Group()
Scav2 = Group()
Scav3 = Group()
-- public		DROID		sensor1, sensor2;
-- public		DROID		Ambush1Droid;	//a Howitzer droid used to figure out when in position!
tempInt = 0
tempx1 = 0
tempx2 = 0
tempy1 = 0
tempy2 = 0
temp1 = 0
temp2 = 0
-- for keeping track of casualties
AmbushTot = 0
Scav2Health = 0

attackedStruct = nil
attacker = nil

-- temporary variables
newDroid = nil
testDroid = nil
moveX = 0
moveY = 0
xdiff = 0
ydiff = 0
-- default leadership for enemy2
ld = 0

-- values for build lists start here
-- General Values
-- limit build to this number
-- limit build to this number

-- Enemy Tactics


-- Reinforcement Lists for New Paradigm

--[[public		TEMPLATE	scorpRkt, scorpTank, scorpHow, scorpTruck;
public		TEMPLATE	beetSensor, beetTank;]]--
-- enemy1
enm1aState = 0
enm1bState = 0
enm1cState = 0
atkTot = 0
enm1aDestroyed = false
enm1bDestroyed = false
enm1cDestroyed = false

-- enemy2
-- enm2dState;
enm2aState = 0
enm2bState = 0
enm2cState = 0
-- enm2dDestroyed;
enm2aDestroyed = false
enm2bDestroyed = false
enm2cDestroyed = false

-- Values for build Commands
-- , enemyTruck2, enemyTruck3;
comTruck1 = 0
comTruck2 = 0
comTruck3 = 0
-- used to calc closest repair truck!
dist1 = 0
dist2 = 0
dist3 = 0

--[[DON'T BOTHER!!!!  Structures to be built
public		INT		numStruc1, numStruc2, numStruc3;
public		STRUCTURESTAT	struc1[6], struc2[2], struc3[19];
public		INT		struc1X[6], struc1Y[6], struc2X[2], struc2Y[2], struc3X[19], struc3Y[19];]]--

-- for checking repair
testStruc = nil

-- Starting nology

-- Enemy LZs for 1CA
LZpos = 0

-- Sectors to check
as = 0
as1 = 0
asX = 0
asY = 0

-- target acquisition
targetX = Array(2, 5)
targetY = Array(2, 5)

-- arrayed version of sector scout!
-- scouts total (2)
-- scout number (used in loops)
targetCount = Array(2)
scoutSector = Array(2)
sectInc = Array(2)
sn = 0
-- scout and heavy forces
Strike1 = Array(2)
Strike2 = Array(2)
temp = 0

-- Build oil derricks
feature = nil
oilFlag = 0
oilX = 0
oilY = 0
boolResult = false

-- Enemy Base Blips
baseFlag = Array(10)
basesDead = 0

-- base detected/dead

-- stop 2nd landing


-- Events: Initialise

-- Events: Start

function startEvnt()
	centreViewPos(11 * 128, 52 * 128)
	-- make scavengers and New paradigm allies (just in case!)
	createAlliance(enemy1, enemy2)
	-- set scroll limits
	-- setScrollParams(0, 0, 128, 128);			//limit scroll
	-- set zoom Level 128x128
	setRadarZoom(0)
	-- stop player building on LZ
	initAllNoGoAreas()
	setLandingZone(10, 51, 12, 53)
	-- also don't allow building on 1CA's enemy LZs!
	count = 0
	-- don't go over 7!! SKIP LAST ONE, since changes!
	while count < numLZ - 1 do
		setNoGoArea((enemyLZX[count] / 128) - 1, (enemyLZY[count] / 128) - 1, (enemyLZX[count] / 128) + 1, (enemyLZY[count] / 128) + 1, count + 2)
		count = count + 1
	end
	-- set no time limits (can carry over from previous missions if not set!)
	setReinforcementTime(-1/10.0)
	-- set Mission time limit
	setMissionTime(timeLimit/10.0)
	
	-- add enemy transport (once!)
	setNoGoArea((enemyLZX[0] / 128) - 1, (enemyLZY[0] / 128) - 1, (enemyLZX[0] / 128) + 1, (enemyLZY[0] / 128) + 1, enemy2)
	transportDroid = addDroidToMissionList(transporter, enemy2)
	
	-- allow to build stuff
	setStructureLimits(powerGen, numPow, 0)
	setStructureLimits(oilDerrick, numExt, 0)
	setStructureLimits(research, numRes, 0)
	setStructureLimits(factory, numFac, 0)
	setStructureLimits(command, 1, player)
	enableStructure(command, player)
	enableStructure(powerGen, 0)
	enableStructure(oilDerrick, 0)
	enableStructure(research, 0)
	enableStructure(factory, 0)
	-- enableStructure(powerModuleHack, 0);
	
	setPowerLevel(pow1, enemy1)
	setPowerLevel(pow2, enemy2)
	deactivateEvent(startEvnt)
	-- show enemy Position
	addMessage(obj0Msg, PROX_MSG, player, false)
	addMessage(MissionBrief, MISS_MSG, 0, true)
end
callbackEvent(startEvnt, CALL_GAMEINIT)

function start2Evnt()
	deactivateEvent(start2Evnt)
	removeMessage(MissionBrief, MISS_MSG, 0)
	addMessage(MissionBrief2, MISS_MSG, 0, true)
end
callbackEvent(start2Evnt, CALL_VIDEO_QUIT)

function removeObj0()
	removeMessage(obj0Msg, PROX_MSG, player)
	deactivateEvent(removeObj0)
end
conditionalEvent(removeObj0, "droidInRange(player, 6848, 13888, 5 * 128)", 2.0)

-- Events:

-- Events: Artifacts
function art1TakeEvnt()
	numart = numart + 1
	-- playSound(art1Snd2, player);
	playSoundPos(art1Snd2, player, art1ID.x, art1ID.y, art1ID.z)
	destroyFeature(art1ID)
	-- removeMessage(art1Msg, PROX_MSG, player);
	enableResearch(art1Comp, player)
	deactivateEvent(art1TakeEvnt)
end

function art1PlaceEvnt()
	art1ID = addFeature(crate, art1X, art1Y)
	-- setEventTrigger(art1SeenEvnt, art1SeenTrig);
	conditionalEvent(art1TakeEvnt, "droidInRange(player, art1X, art1Y, 171)", 0.5)
	deactivateEvent(art1PlaceEvnt)
end
conditionalEvent(art1PlaceEvnt, "(destroyed(art1Get))", 0.5)

function art2TakeEvnt()
	numart = numart + 1
	-- playSound(art2Snd2, player);
	playSoundPos(art2Snd2, player, art2ID.x, art2ID.y, art2ID.z)
	destroyFeature(art2ID)
	-- removeMessage(art2Msg, PROX_MSG, player);
	enableResearch(art2Comp, player)
	deactivateEvent(art2TakeEvnt)
end

function art2PlaceEvnt()
	art2ID = addFeature(crate, art2X, art2Y)
	-- setEventTrigger(art2SeenEvnt, art2SeenTrig);
	conditionalEvent(art2TakeEvnt, "droidInRange(player, art2X, art2Y, 171)", 0.5)
	deactivateEvent(art2PlaceEvnt)
end
conditionalEvent(art2PlaceEvnt, "(destroyed(art2Get))", 0.5)

function art3TakeEvnt()
	numart = numart + 1
	-- playSound(art3Snd2, player);
	playSoundPos(art3Snd2, player, art3ID.x, art3ID.y, art3ID.z)
	destroyFeature(art3ID)
	-- removeMessage(art3Msg, PROX_MSG, player);
	enableResearch(art3Comp, player)
	deactivateEvent(art3TakeEvnt)
end

function art3PlaceEvnt()
	art3ID = addFeature(crate, art3X, art3Y)
	-- setEventTrigger(art3SeenEvnt, art3SeenTrig);
	conditionalEvent(art3TakeEvnt, "droidInRange(player, art3X, art3Y, 171)", 0.5)
	deactivateEvent(art3PlaceEvnt)
end
conditionalEvent(art3PlaceEvnt, "(destroyed(art3Get))", 0.5)


function art5TakeEvnt()
	numart = numart + 1
	-- playSound(art5Snd2, player);
	playSoundPos(art5Snd2, player, art5ID.x, art5ID.y, art5ID.z)
	destroyFeature(art5ID)
	-- removeMessage(art5Msg, PROX_MSG, player);
	enableResearch(art5Comp, player)
	deactivateEvent(art5TakeEvnt)
end

function art5PlaceEvnt()
	art5ID = addFeature(crate, art5X, art5Y)
	-- setEventTrigger(art5SeenEvnt, art5SeenTrig);
	conditionalEvent(art5TakeEvnt, "droidInRange(player, art5X, art5Y, 171)", 0.5)
	deactivateEvent(art5PlaceEvnt)
end
conditionalEvent(art5PlaceEvnt, "(destroyed(art5Get))", 0.5)





-- Events: Win or Lose

-- assumes victory already checked
function nextLevEvnt()
	pause(20/10.0)
	-- give bonus research (if req'd)
	count = 0
	while count < numResP0 do
		enableResearch(resP0[count], 0)
		count = count + 1
	end
	
	-- flag next part of map
	C.gameLevel = C.gameLevel + 1
	-- removing message unnecessary
	-- removeMessage(MissionBrief2, MISS_MSG, player);
	startMission(CAMP_EXPAND, NextLev)
	-- End game here for now! (don't try next mission)
	-- gameOver(true);
	
	deactivateEvent(nextLevEvnt)
end

function gameLost()
	gameOverMessage(endMsg, MISS_MSG, 0, false)
	deactivateEvent(gameLost)
end

function lostYetEvnt()
	if not anyDroidsLeft(player) then
		if not anyStructButWallsLeft(player) then
			deactivateEvent(wonYetEvnt)
			-- waits 2 seconds before ending
			repeatingEvent(gameLost, 2.0)
			deactivateEvent(lostYetEvnt)
			deactivateEvent(timeUp)
		end
	end
end
repeatingEvent(lostYetEvnt, 0.5)


-- have all enemies lost yet?
function wonYetEvnt()
	if not anyDroidsLeft(enemy2) then
		if not anyStructButWallsLeft(enemy2) then
			if not anyDroidsLeft(enemy1) then
				if not anyStructButWallsLeft(enemy1) then
					if numart == 4 then
						deactivateEvent(lostYetEvnt)
						repeatingEvent(nextLevEvnt, 0.5)
						deactivateEvent(wonYetEvnt)
						deactivateEvent(timeUp)
					end
				end
			end
		end
	end
end
repeatingEvent(wonYetEvnt, 0.5)


-- cheat button ctrl M
function cheatEvnt()
	repeatingEvent(nextLevEvnt, 0.5)
	deactivateEvent(cheatEvnt)
end
callbackEvent(cheatEvnt, CALL_MISSION_START)

-- Base Under Attack
function baseHit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= C.selectedPlayer then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if t >= 20 then
		t = 0
		if hitStruc ~= nil then
			playSoundPos(attackSnd1, C.selectedPlayer, hitStruc.x, hitStruc.y, hitStruc.z)
		else
			playSound(attackSnd1, C.selectedPlayer)
		end
	end
end
callbackEvent(baseHit, CALL_STRUCT_ATTACKED)

function everySec()
	t = t + 1
end
repeatingEvent(everySec, 1.0)

function seeBaseHit()
	if hitStruc ~= nil then
		centreView(hitStruc)
		-- flag known about!
		t = 0
	end
end
callbackEvent(seeBaseHit, CALL_MISSION_END)

-- event enm2dFactEvnt;

-- event setBuild1;
-- event setBuild2;
-- event setBuild3;

-- (init)
function startup()
	setAssemblyPoint(enm1a, 13248, 13632)
	-- setAssemblyPoint (enm1b, 8384, 704);	//in good place
	setAssemblyPoint(enm1c, 8384, 704)
	
	-- setAssemblyPoint (enm2a, 13504, 13248);	//12736, 14016);
	setAssemblyPoint(enm2b, 12736, 11456)
	setAssemblyPoint(enm2c, 9920, 3136)
	-- setAssemblyPoint (enm2d, 14528, 3776);
	
	-- make scavengers allies with NP
	createAlliance(enemy1, enemy2)
	-- set attack level for scavs
	atkTot = 4
	-- make up starting forces
	
	-- Send sensor droids to new positions
	-- orderDroidLoc(sensor1, DORDER_SCOUT, 6976, 13376);
	-- orderDroidLoc(sensor2, DORDER_SCOUT, 6592, 14400);
	
	-- Setup Mortar group
	groupAddArea(IDF1, enemy2, 8384, 15168, 9024, 15680)
	-- orderGroupLoc(IDF1, DORDER_SCOUT, 7232, 15168);		//then move into position (no good other way round!)
	
	-- set up strike force (scout)
	-- rocket-sensor scout force
	groupAddArea(Strike1[0], enemy2, 8384, 13760, 8512, 14144)
	-- rocket-sensor  force
	groupAddArea(Strike2[0], enemy2, 8640, 13760, 8896, 14144)
	-- halftrack 'scout' force
	groupAddArea(Strike1[1], enemy2, 9280, 13760, 9920, 14144)
	-- tank force
	groupAddArea(Strike2[1], enemy2, 9280, 14272, 9920, 14656)
	
	-- first scout to south of players base
	scoutSector[0] = 6
	-- set going immediately!
	as1 = scoutSector[0]
	asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1])
	asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1])
	orderGroupLoc(Strike1[0], DORDER_SCOUT, asX, asY)
	
	-- 5;		//move followup force out to 2 sectors back
	as1 = 3
	asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1])
	asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1])
	-- orderGroupLoc(Strike2[0], DORDER_SCOUT, asX, asY);
	
	-- 3;//second scout South 1B
	scoutSector[1] = 0
	-- sector increment to get to next one
	sectInc[0] = 1
	sectInc[1] = 1
	
	-- setGroupSecondary(Strike1, DSO_ATTACK_RANGE, DSS_ARANGE_LONG);
	-- scout player's base
	groupAddArea(Ambush1, enemy2, 10944, 10816, 11712, 11712)
	-- keep note of max for checking casualties later
	AmbushTot = groupCountMembers(Ambush1)
	-- orderGroupObj(Ambush1, DORDER_FIRESUPPORT, sensor1);	//use sensor droid for firesupport?
	
	-- groupAddArea(Reserve1, enemy2, 9280, 13632, 9664, 14144);
	
	-- set up Scavenger forces
	-- 4 Jeeps
	groupAddArea(Scav1, enemy1, 13120, 13376, 12896, 13587)
	-- 4 Rocket Buggies
	groupAddArea(Scav2, enemy1, 13730, 9419, 13863, 9505)
	-- setGroupSecondary(Scav2, DSO_HALTTYPE, DSS_HALT_HOLD);		//Hold position
	-- keep track of casualties
	Scav2Health = Scav2.health
	
	-- player specific technology startups
	count = 0
	while count < numtecE1 do
		completeResearch(tecE1[count], enemy1)
		count = count + 1
	end
	count = 0
	while count < numtecE2 do
		completeResearch(tecE2[count], enemy2)
		count = count + 1
	end
	
	-- build on oil resources setup
	initGetFeature(oilRes, enemy2, enemy2)
end
callbackEvent(startup, CALL_GAMEINIT)

-- event orderEvnt4;
function orderEvnt1()
	orderGroupLoc(Ambush1, DORDER_SCOUT, 8352, 13880)
	-- start mid scavs building also!
	repeatingEvent(enm1bFactEvnt, 60.0)
	-- change attack point to ravine ambush
	playerX = 8352
	playerY = 13880
	-- setEventTrigger(orderEvnt4, orderTrig4);
	deactivateEvent(orderEvnt1)
end
conditionalEvent(orderEvnt1, "(droidInArea(player, 8896, 13760, 10048, 14656))", 1.0)

-- deal with a droid being built by enemy1
function enemy1build(_newDroid, _newDroidFactory)
	if _newDroid.player ~= enemy1 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	groupAddDroid(enemy1Build, newDroid)
	if groupCountMembers(enemy1Build) >= atkTot then
		groupAddGroup(enemy1Attack, enemy1Build)
		-- do attack force decision here!
		if atkTot < enemy1Tot then
			atkTot = atkTot + 1
		end
		if targetCount[0] > 0 then
			orderGroupLoc(enemy1Attack, DORDER_SCOUT, targetX[0][0], targetY[0][0])
		else
			orderGroupLoc(enemy1Attack, DORDER_SCOUT, playerX, playerY)
		end
	end
end
callbackEvent(enemy1build, CALL_NEWDROID)

-- deal with a droid being built by enemy2
function enemy2build(_newDroid, _newDroidFactory)
	if _newDroid.player ~= enemy2 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	if newDroid.droidType == DROID_CONSTRUCT then
		if enemyTruck1 == nil then
			enemyTruck1 = newDroid
		end
	else
		groupAddDroid(enemy2Build, newDroid)
		if groupCountMembers(enemy2Build) >= 4 then
			if groupCountMembers(enemy2Attack) >= 4 then
				groupAddGroup(enemy2Attack, enemy2Build)
			else
				sn = 0
				while sn < st do
					if groupCountMembers(Strike1[sn]) == 0 then
						groupAddGroup(Strike1[sn], enemy2Build)
						-- start from 1st sector again!
						scoutSector[sn] = 0
						sectInc[sn] = 1
					else
						if groupCountMembers(Strike2[sn]) == 0 then
							groupAddGroup(Strike2[sn], enemy2Build)
						end
					end
					sn = sn + 1
				end
			end
		end
	end
end
callbackEvent(enemy2build, CALL_NEWDROID)

-- events for build lists start here
-- Enemy 1 Scavengers
-- build list Scav South factory!
function enm1aFactEvnt()
	enm1aDestroyed = destroyed(enm1aID)
	if enm1aDestroyed then
		repeatingEvent(enm1bFactEvnt, 60.0)
		deactivateEvent(enm1aFactEvnt)
	else
		if structureIdle(enm1a) and (groupCountMembers(enemy1Build) + groupCountMembers(enemy1Attack)) < enemy1Tot then
			if enm1aState == 0 then
				buildDroid(BusCan, enm1a, enemy1, 1)
				enm1aState = 1
			else
				if enm1aState == 1 then
					buildDroid(rktJeep, enm1a, enemy1, 1)
					enm1aState = 2
				else
					
					if enm1aState == 2 then
						buildDroid(trike, enm1a, enemy1, 3)
						enm1aState = 3
					else
						buildDroid(buggy, enm1a, enemy1, 2)
						enm1aState = 0
					end
				end
			end
		end
	end
end

function enm1aStartEvnt()
	repeatingEvent(enm1aFactEvnt, 90.0)
	deactivateEvent(enm1aStartEvnt)
end
delayedEvent(enm1aStartEvnt, 2.0)

-- build list Scav mid Factory
function enm1bFactEvnt()
	enm1bDestroyed = destroyed(enm1bID)
	if enm1bDestroyed then
		repeatingEvent(enm1cFactEvnt, 30.0)
		deactivateEvent(enm1bFactEvnt)
	else
		if structureIdle(enm1b) and (groupCountMembers(enemy1Build) + groupCountMembers(enemy1Attack)) < enemy1Tot then
			if enm1bState == 0 then
				buildDroid(FireCan, enm1b, enemy1, 1)
				enm1bState = 1
			else
				
				if enm1bState == 1 then
					buildDroid(rktBuggy, enm1b, enemy1, 1)
					enm1bState = 2
				else
					if enm1bState == 2 then
						buildDroid(jeep, enm1b, enemy1, 2)
						enm1bState = 3
					else
						buildDroid(bloke, enm1b, enemy1, 3)
						enm1bState = 0
					end
				end
			end
		end
	end
end

function enm1bStartEvnt()
	repeatingEvent(enm1bFactEvnt, 60.0)
	deactivateEvent(enm1bStartEvnt)
end
conditionalEvent(enm1bStartEvnt, "droidInRange(player, enm1b.x, enm1b.y, 15 * 128)", 2.0)

-- build list Scav north Factory
function enm1cFactEvnt()
	enm1cDestroyed = destroyed(enm1cID)
	if enm1cDestroyed then
		deactivateEvent(enm1cFactEvnt)
	else
		if structureIdle(enm1c) and (groupCountMembers(enemy1Build) + groupCountMembers(enemy1Attack)) < enemy1Tot then
			if enm1cState == 0 then
				buildDroid(FireCan, enm1c, enemy1, 1)
				enm1cState = 1
			else
				
				if enm1cState == 1 then
					buildDroid(rktBuggy, enm1c, enemy1, 1)
					enm1cState = 2
				else
					if enm1cState == 2 then
						buildDroid(BusCan, enm1c, enemy1, 2)
						enm1cState = 3
					else
						buildDroid(trike, enm1c, enemy1, 3)
						enm1cState = 0
					end
				end
			end
		end
	end
end

function enm1cStartEvnt()
	repeatingEvent(enm1cFactEvnt, 30.0)
	deactivateEvent(enm1cStartEvnt)
end
conditionalEvent(enm1cStartEvnt, "droidInRange(player, enm1c.x, enm1c.y, 15 * 128)", 2.0)


-- build list NP central Factory
function enm2bFactEvnt()
	enm2bDestroyed = destroyed(enm2bID)
	if enm2bDestroyed then
		repeatingEvent(enm2cFactEvnt, 30.0)
		deactivateEvent(enm2bFactEvnt)
	else
		if structureIdle(enm2b) and (groupCountMembers(enemy2Build) + groupCountMembers(enemy2Attack)) < enemy2Tot then
			if enm2bState == 0 then
				buildDroid(ScorpLMort, enm2b, enemy2, 3)
				enm2bState = 1
			else
				if enm2bState == 1 then
					buildDroid(BugSensor, enm2b, enemy2, 1)
					enm2bState = 2
				else
					if enm2bState == 2 then
						buildDroid(ScorpMCan, enm2b, enemy2, 2)
						enm2bState = 0
					else
						buildDroid(scorpTruck, enm2b, enemy2, 1)
						enm2bState = 0
					end
				end
			end
			-- check for any trucks dead, and set to manufacturing a replacement
			-- or (enemyTruck2 == NULLOBJECT) or (enemyTruck3 == NULLOBJECT))
			if enemyTruck1 == nil then
				enm2bState = 3
			end
		end
	end
end

-- (wait, 50)
function enm2bStartEvnt()
	repeatingEvent(enm2bFactEvnt, 60.0)
	deactivateEvent(enm2bStartEvnt)
end
delayedEvent(enm2bStartEvnt, 300.0)

-- build list NP NW Factory
-- rocket tanks always
function enm2cFactEvnt()
	enm2cDestroyed = destroyed(enm2cID)
	if enm2cDestroyed then
		deactivateEvent(enm2cFactEvnt)
	else
		if (structureIdle(enm2c) and (groupCountMembers(enemy2Build) + groupCountMembers(enemy2Attack)) < enemy2Tot) and (structureBuilt(powerGen, enemy2)) then
			if enm2cState == 0 then
				buildDroid(BugRktP, enm2c, enemy2, 3)
				enm2cState = 1
			else
				if enm2cState == 1 then
					buildDroid(ScorpMCan2, enm2c, enemy2, 3)
					enm2cState = 2
				else
					if enm2cState == 2 then
						buildDroid(ScorpLMort, enm2c, enemy2, 3)
						enm2cState = 0
					else
						buildDroid(scorpTruck, enm2c, enemy2, 1)
						enm2cState = 0
					end
				end
			end
			-- check for any trucks dead, and set to manufacturing a replacement
			-- or (enemyTruck2 == NULLOBJECT) or (enemyTruck3 == NULLOBJECT))
			if enemyTruck1 == nil then
				enm2cState = 3
			end
		end
	end
end


function lastAttack1()
	if not anyStructButWallsLeft(enemy1) then
		groupAddArea(enemy1Fin, enemy1, 0, 0, 128 * 128, 128 * 128)
		orderGroupLoc(enemy1Fin, DORDER_SCOUT, playerX, playerY)
	end
end
repeatingEvent(lastAttack1, 5.0)
-- setEventTrigger(lastAttack1, inactive);

function lastAttack2()
	if not anyStructButWallsLeft(enemy2) then
		groupAddArea(enemy2Fin, enemy1, 0, 0, 128 * 128, 128 * 128)
		orderGroupLoc(enemy2Fin, DORDER_SCOUT, playerX, playerY)
	end
end
repeatingEvent(lastAttack2, 5.0)
-- setEventTrigger(lastAttack2, inactive);

-- Generic go investigate nearby structures if under attack!

function enm1Hit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= enemy1 then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if hitStruc ~= nil then
		tempx1 = 1 * 128
		-- empty enemy1Guard group first!
		groupAddGroup(dummy1, enemy1Guard)
		while (groupCountMembers(enemy1Guard) < 4) and (tempx1 <= 1280) do
			groupAddArea(enemy1Guard, enemy1, hitStruc.x - tempx1, hitStruc.y - tempx1, hitStruc.x + tempx1, hitStruc.y + tempx1)
			tempx1 = tempx1 + 128
			-- hack to recalculate members in enemy1Guard!!!
			tempy1 = groupCountMembers(enemy1Attack)
		end
		if attackerObj ~= nil then
			orderGroupObj(enemy1Guard, DORDER_ATTACK, attackerObj)
			orderGroupLoc(enemy1Guard, DORDER_SCOUT, attackerObj.x, attackerObj.y)
		else
			orderGroupLoc(enemy1Guard, DORDER_SCOUT, hitStruc.x, hitStruc.y)
		end
	end
end
callbackEvent(enm1Hit, CALL_STRUCT_ATTACKED)

function enm2Hit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= enemy2 then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if hitStruc ~= nil then
		tempx2 = 1 * 128
		-- empty enemy2Guard group first!
		groupAddGroup(dummy2, enemy2Guard)
		while (groupCountMembers(enemy2Guard) < 4) and (tempx2 <= 2560) do
			groupAddArea(enemy2Guard, enemy2, hitStruc.x - tempx2, hitStruc.y - tempx2, hitStruc.x + tempx2, hitStruc.y + tempx2)
			tempx2 = tempx2 + 128
			-- hack to recalculate members in enemy2Guard!!!
			tempy2 = groupCountMembers(enemy2Attack)
		end
		
		-- set repair level
		setGroupSecondary(enemy2Guard, DSO_REPAIR_LEVEL, DSS_REPLEV_HIGH)
		
		if attackerObj ~= nil then
			orderGroupLoc(enemy2Guard, DORDER_SCOUT, attackerObj.x, attackerObj.y)
		else
			orderGroupLoc(enemy2Guard, DORDER_SCOUT, hitStruc.x, hitStruc.y)
		end
	end
end
callbackEvent(enm2Hit, CALL_STRUCT_ATTACKED)


function scoutAtk1Sectors()
	sn = 0
	-- for all 'st' forces (scout group + heavy group)
	while sn < st do
		if groupCountMembers(Strike1[sn]) == 0 then
			groupAddGroup(Strike1[sn], Strike2[sn])
		end
		-- check all attack areas for enemy
		as1 = scoutSector[sn]
		-- if (not (objectInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1])))
		
		-- if ((numStructsButNotWallsInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1]) == 0)
		-- and (numStructsButNotWallsInArea(player, targetX[sn] - 768, targetY[sn] - 768, targetX[sn] + 768, targetY[sn] + 768) == 0))
		-- if ((random(100) < 25) and (targetCount[sn] == 0))	//25% chance of moving on if no targets
		
		-- 10% chance of scouting past an occupied sector (even if targets!)
		temp1 = numStructsButNotWallsInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1])
		temp2 = numDroidsInArea(player, atk1SectX1[as1], atk1SectY1[as1], atk1SectX2[as1], atk1SectY2[as1])
		if (random(100) < 10) or (temp1 == 0) or (temp2 == 0) then
			setGroupRetreatPoint(Strike1[sn], Strike1[sn].x, Strike1[sn].y)
			-- sector clear so choose another
			
			-- keep track of frontline
			scoutSector[sn] = scoutSector[sn] + sectInc[sn]
			if (scoutSector[sn] >= numAtk1Sects) or (scoutSector[sn] < 0) then
				sectInc[sn] = -sectInc[sn]
				scoutSector[sn] = scoutSector[sn] + sectInc[sn]
			end
		end
		if idleGroup(Strike1[sn]) >= groupCountMembers(Strike1[sn]) / 2 then
			as1 = scoutSector[sn]
			-- order scout forces to random position in this sector
			asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1])
			asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1])
			orderGroupLoc(Strike1[sn], DORDER_SCOUT, asX, asY)
		end
		sn = sn + 1
	end
end
repeatingEvent(scoutAtk1Sectors, 15.0)

function attackAtk1Sector()
	sn = 0
	while sn < st do
		if (idleGroup(Strike2[sn]) >= groupCountMembers(Strike2[sn]) / 2) or (random(100) < 5) then
			if targetCount[sn] > 0 then
				resetStructTargets()
				if random(100) < 10 then
					setStructTarPref(ST_WALL)
				end
				hitStruc = structTargetInArea(player, enemy2, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768)
				if hitStruc ~= nil then
					orderGroupObj(Strike2[sn], DORDER_ATTACK, hitStruc)
				else
					orderGroupLoc(Strike2[sn], DORDER_SCOUT, targetX[sn][0] - 384 + random(768), targetY[sn][0] - 384 + random(768))
				end
			else
				as1 = scoutSector[sn] - sectInc[sn]
				if (as1 >= numAtk1Sects) or (as1 < 0) then
					as1 = scoutSector[sn]
				end
				asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1])
				asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1])
				-- random pos in previous sector
				orderGroupLoc(Strike2[sn], DORDER_SCOUT, asX, asY)
			end
		end
		sn = sn + 1
	end
end
repeatingEvent(attackAtk1Sector, 25.0)

function scavAttack()
	if targetCount[0] > 0 then
		orderGroupLoc(enemy1Attack, DORDER_SCOUT, targetX[0][0], targetY[0][0])
	else
		orderGroupLoc(enemy1Attack, DORDER_SCOUT, playerX, playerY)
	end
end
repeatingEvent(scavAttack, 19.0)


--
-- New Version using 2D Arrays
--


-- (every, 43)
function flagTargets()
	sn = 0
	while sn < st do
		if targetCount[sn] > 0 then
			tempInt = 0
			while tempInt < targetCount[sn] do
				resetStructTargets()
				-- include walls always
				setStructTarPref(ST_WALL)
				hitStruc = structTargetInArea(player, enemy2, targetX[sn][tempInt] - 768, targetY[sn][tempInt] - 768, targetX[sn][tempInt] + 768, targetY[sn][tempInt] + 768)
				if hitStruc == nil then
					count = tempInt
					while count < targetCount[sn] do
						targetX[sn][count] = targetX[sn][count + 1]
						targetY[sn][count] = targetY[sn][count + 1]
						count = count + 1
					end
					-- reduce total
					targetCount[sn] = targetCount[sn] - 1
				end
				tempInt = tempInt + 1
			end
		end
		-- flag new targets, if any (structures and droids but not walls!)
		temp1 = numStructsButNotWallsInArea(player, Strike1[sn].x - 768, Strike1[sn].y - 768, Strike1[sn].x + 768, Strike1[sn].y + 768)
		temp2 = numDroidsInArea(player, Strike1[sn].x - 768, Strike1[sn].y - 768, Strike1[sn].x + 768, Strike1[sn].y + 768)
		--[[OLD SYSTEM
				if ((targetCount[sn] < targetMax) and ((temp1 > 0) or (temp2 > 0)))
						//(objectInRange(player, Strike1[sn].x, Strike1[sn].y, 6 * 128)))
				{]]--
		-- new targetting system!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		-- find a target in area
		resetStructTargets()
		if random(100) < 10 then
			setStructTarPref(ST_WALL)
		end
		hitStruc = structTargetInArea(player, enemy2, Strike1[sn].x - 768, Strike1[sn].y - 768, Strike1[sn].x + 768, Strike1[sn].y + 768)
		if (targetCount[sn] < targetMax) and (hitStruc ~= nil) then
			targetX[sn][targetCount[sn]] = Strike1[sn].x
			targetY[sn][targetCount[sn]] = Strike1[sn].y
			orderGroupLoc(Strike2[sn], DORDER_SCOUT, targetX[sn][targetCount[sn]], targetY[sn][targetCount[sn]])
			-- if (Strike2[sn].members > Strike1[sn].members)	//make heavies target this, and shoot with scouts (if more than heavies)!
			if (groupCountMembers(Strike1[sn]) < temp1) or (groupCountMembers(Strike1[sn]) < temp2) then
				scoutSector[sn] = scoutSector[sn] - sectInc[sn]
				if (scoutSector[sn] >= numAtk1Sects) or (scoutSector[sn] < 0) then
					scoutSector[sn] = scoutSector[sn] + sectInc[sn]
				end
				as1 = scoutSector[sn]
				-- order scout forces to random position in this sector
				asX = atk1SectX1[as1] + random(atk1SectX2[as1] - atk1SectX1[as1])
				asY = atk1SectY1[as1] + random(atk1SectY2[as1] - atk1SectY1[as1])
				orderGroupLoc(Strike1[sn], DORDER_SCOUT, asX, asY)
			else
				-- orderGroup(Strike1[sn], DORDER_RUN);	//run away for a bit!
				-- only if not busy or small chance
				if (idleGroup(Strike1[sn]) >= groupCountMembers(Strike1[sn]) / 2) or (random(100) < 5) then
					orderGroupObj(Strike1[sn], DORDER_ATTACK, hitStruc)
				end
			end
			
			targetCount[sn] = targetCount[sn] + 1
		end
		--[[OLD SYSTEM
				//check for targets from heavies also!
				temp1 = numStructsButNotWallsInArea(player, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768);
				temp2 = numDroidsInArea(player, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768);
				if ((targetCount[sn] < targetMax) and ((temp1 > 0) or (temp2 > 0)))]]--
		-- new targetting system!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		-- find a target in area
		resetStructTargets()
		if random(100) < 10 then
			setStructTarPref(ST_WALL)
		end
		hitStruc = structTargetInArea(player, enemy2, Strike2[sn].x - 768, Strike2[sn].y - 768, Strike2[sn].x + 768, Strike2[sn].y + 768)
		if (targetCount[sn] < targetMax) and (hitStruc ~= nil) then
			targetX[sn][targetCount[sn]] = Strike2[sn].x
			targetY[sn][targetCount[sn]] = Strike2[sn].y
			-- stay where you are (and hopefully kill stuff)
			orderGroup(Strike2[sn], DORDER_STOP)
			targetCount[sn] = targetCount[sn] + 1
		end
		sn = sn + 1
	end
end
repeatingEvent(flagTargets, 7.7)


function buildDerrick()
	if not (structureBuilt(powerGen, enemy2)) then
		if enemyTruck1 ~= nil then
			if enemyTruck1.order == DORDER_NONE then
				tempx1 = enemyTruck1.x
				tempy1 = enemyTruck1.y
				boolResult, tempx1, tempy1 = pickStructLocation(powerGen, tempx1, tempy1, enemy2)
				if boolResult == true then
					orderDroidStatsLoc(enemyTruck1, DORDER_BUILD, powerGen, tempx1, tempy1)
				end
			end
		end
	end
	
	-- find unoccupied oil resource that's been seen!
	feature = getFeature(enemy2)
	if feature ~= nil then
		if enemyTruck1 ~= nil then
			if enemyTruck1.order == DORDER_NONE then
				if oilFlag == 0 then
					oilX = feature.x
					oilY = feature.y
					-- build a derick
					orderDroidStatsLoc(enemyTruck1, DORDER_BUILD, oilDerrick, oilX, oilY)
					-- number of defences to build nearby
					oilFlag = random(4) + 1
				else
					-- need special guard force to go with truck (later!).
					if oilFlag < 6 then
						tempx1 = oilX + random(1024) - 512
						tempy1 = oilY + random(1024) - 512
						temp1 = random(numDefStructs)
						boolResult, tempx1, tempy1 = pickStructLocation(defStructs[temp1], tempx1, tempy1, enemy2)
						if boolResult == true then
							orderDroidStatsLoc(enemyTruck1, DORDER_BUILD, defStructs[temp1], tempx1, tempy1)
							oilFlag = oilFlag - 1
						end
					end
				end
			end
		end
	else
		initGetFeature(oilRes, enemy2, enemy2)
	end
end
repeatingEvent(buildDerrick, 5.0)


-- Enemy Base Blips
-- update base blips
function baseLoop()
	if basesDead == numBases then
		deactivateEvent(baseLoop)
	else
		count = 0
		while count < numBases do
			if baseFlag[count] == 0 then
				if seenStructInArea(player, basePlayer[count], false, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]]) then
					addMessage(baseMsg[count], PROX_MSG, player, false)
					if baseWav1[count] >= 0 then
						playSoundPos(baseSnd[baseWav1[count]], player, (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2, (regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2, 0)
					end
					baseFlag[count] = 1
				end
			end
			if baseFlag[count] == 1 then
				if numStructsButNotWallsInArea(basePlayer[count], regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]]) == 0 then
					basesDead = basesDead + 1
					baseFlag[count] = 2
					if baseWav2[count] >= 0 then
						playSoundPos(baseSnd[baseWav2[count]], player, (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2, (regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2, 0)
					end
					removeMessage(baseMsg[count], PROX_MSG, player)
					-- remove walls and building features in base
					killStructsInArea(basePlayer[count], REF_WALL, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]], true, true)
					-- remove corner walls in base
					killStructsInArea(basePlayer[count], REF_WALLCORNER, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]], true, false)
				end
			end
			
			count = count + 1
		end
	end
end
repeatingEvent(baseLoop, 1.5)

-- Transports
-- group landed enemy units and get going!
function groupTrans(_enemy2Build, _player)
	if _player ~= enemy2 then return end
	playSoundPos(warnSnd, player, enemyLZX[LZpos], enemyLZY[LZpos], 0)
	pause(10/10.0)
	-- use random to figure out which groups to go into
	temp = random(3)
	if temp == 0 then
		groupAddGroup(Strike1[0], enemy2Build)
		-- start from 1st sector again!
		scoutSector[0] = 0
		sectInc[0] = 1
	else
		if temp == 1 then
			groupAddGroup(Strike1[1], enemy2Build)
			-- start from 1st sector again!
			scoutSector[1] = 0
			sectInc[1] = 1
		else
			if temp == 2 then
				groupAddGroup(Strike2[0], enemy2Build)
			else
				groupAddGroup(Strike2[1], enemy2Build)
			end
		end
	end
end
callbackEvent(groupTrans, CALL_TRANSPORTER_LANDED)

function landTrans()
	if transportDroid ~= nil then
		if not transOnMap then
			temp1 = 1 + random(5)
			-- make rest upto 8
			temp2 = 8 - temp1
			count = 0
			while count < temp1 do
				reinforceTemplate = scout[random(numScout)]
				loadDroid = addDroidToMissionList(reinforceTemplate, enemy2)
				if loadDroid ~= nil then
					addDroidToTransporter(transportDroid, loadDroid)
				end
				count = count + 1
			end
			-- use same selection for all heavies
			reinforceTemplate = heavy[random(numHeavy)]
			count = 0
			while count < temp2 do
				loadDroid = addDroidToMissionList(reinforceTemplate, enemy2)
				if loadDroid ~= nil then
					addDroidToTransporter(transportDroid, loadDroid)
				end
				count = count + 1
			end
			-- call in transport
			setTransporterExit(1, 126, 20 + random(32))
			flyTransporterIn(1, 126, 60 + random(32), false)
			transOnMap = true
			-- 5 mins until next one
			repeatingEvent(landTrans, 300.0)
		end
	end
end

function startTrans1()
	playSound(incomingSnd, player)
	-- used to keep track of where the LZ is for F12
	LZpos = 0
	pause(20/10.0)
	addMessage(MissionBrief4, MISS_MSG, 0, true)
	-- show enemy LZ
	addMessage(obj1Msg, PROX_MSG, player, false)
	setNoGoArea((enemyLZX[0] / 128) - 1, (enemyLZY[0] / 128) - 1, (enemyLZX[0] / 128) + 1, (enemyLZY[0] / 128) + 1, enemy2)
	delayedEvent(landTrans, 10.0)
	deactivateEvent(startTrans1)
end
conditionalEvent(startTrans1, "droidInArea(player, 10560, 6400, 16320, 8256)", 2.5)

function startTrans2()
	playSound(incomingSnd, player)
	-- used to keep track of where the LZ is for F12
	LZpos = 6
	pause(20/10.0)
	addMessage(MissionBrief3, MISS_MSG, 0, true)
	-- show enemy LZ
	addMessage(obj2Msg, PROX_MSG, player, false)
	-- move LZ
	setNoGoArea((enemyLZX[6] / 128) - 1, (enemyLZY[6] / 128) - 1, (enemyLZX[6] / 128) + 1, (enemyLZY[6] / 128) + 1, enemy2)
	delayedEvent(landTrans, 10.0)
	deactivateEvent(startTrans2)
end
conditionalEvent(startTrans2, "droidInArea(player, 7616, 4800, 9408, 5696)", 2.5)

function stopTrans1()
	removeMessage(obj1Msg, PROX_MSG, player)
	deactivateEvent(landTrans)
	deactivateEvent(stopTrans1)
end
conditionalEvent(stopTrans1, "(numStructsButNotWallsInArea(enemy2, 12992, 3904, 14272, 5568) == 0)", 3.5)

function stopTrans2()
	removeMessage(obj2Msg, PROX_MSG, player)
	deactivateEvent(landTrans)
	deactivateEvent(stopTrans2)
end
conditionalEvent(stopTrans2, "(numStructsButNotWallsInArea(enemy2, 8512, 9792, 9664, 10944) == 0)", 3.5)

function transOff(_player)
	if _player ~= enemy2 then return end
	transOnMap = false
end
callbackEvent(transOff, CALL_TRANSPORTER_OFFMAP)


function timeUp()
	deactivateEvent(wonYetEvnt)
	deactivateEvent(lostYetEvnt)
	repeatingEvent(gameLost, 2.0)
	deactivateEvent(timeUp)
end
callbackEvent(timeUp, CALL_MISSION_TIME)


---------- stubs ----------

if orderDroidStatsLoc == nil then orderDroidStatsLoc = function() print("stub: orderDroidStatsLoc"); return 0 end end
if gameOverMessage == nil then gameOverMessage = function() print("stub: gameOverMessage"); return 0 end end
if setGroupRetreatPoint == nil then setGroupRetreatPoint = function() print("stub: setGroupRetreatPoint"); return 0 end end
if centreView == nil then centreView = function() print("stub: centreView"); return 0 end end
if initGetFeature == nil then initGetFeature = function() print("stub: initGetFeature"); return 0 end end
if anyStructButWallsLeft == nil then anyStructButWallsLeft = function() print("stub: anyStructButWallsLeft"); return 0 end end
if enableResearch == nil then enableResearch = function() print("stub: enableResearch"); return 0 end end
if orderGroupObj == nil then orderGroupObj = function() print("stub: orderGroupObj"); return 0 end end
if resetStructTargets == nil then resetStructTargets = function() print("stub: resetStructTargets"); return 0 end end
if droidInArea == nil then droidInArea = function() print("stub: droidInArea"); return 0 end end
if setTransporterExit == nil then setTransporterExit = function() print("stub: setTransporterExit"); return 0 end end
if setMissionTime == nil then setMissionTime = function() print("stub: setMissionTime"); return 0 end end
if addFeature == nil then addFeature = function() print("stub: addFeature"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if pickStructLocation == nil then pickStructLocation = function() print("stub: pickStructLocation"); return 0 end end
if addDroidToTransporter == nil then addDroidToTransporter = function() print("stub: addDroidToTransporter"); return 0 end end
if initAllNoGoAreas == nil then initAllNoGoAreas = function() print("stub: initAllNoGoAreas"); return 0 end end
if structureBuilt == nil then structureBuilt = function() print("stub: structureBuilt"); return 0 end end
if orderGroupLoc == nil then orderGroupLoc = function() print("stub: orderGroupLoc"); return 0 end end
if anyDroidsLeft == nil then anyDroidsLeft = function() print("stub: anyDroidsLeft"); return 0 end end
if droidInRange == nil then droidInRange = function() print("stub: droidInRange"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if getFeature == nil then getFeature = function() print("stub: getFeature"); return 0 end end
if removeMessage == nil then removeMessage = function() print("stub: removeMessage"); return 0 end end
if destroyFeature == nil then destroyFeature = function() print("stub: destroyFeature"); return 0 end end
if setGroupSecondary == nil then setGroupSecondary = function() print("stub: setGroupSecondary"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if destroyed == nil then destroyed = function() print("stub: destroyed"); return 0 end end
if orderGroup == nil then orderGroup = function() print("stub: orderGroup"); return 0 end end
if setReinforcementTime == nil then setReinforcementTime = function() print("stub: setReinforcementTime"); return 0 end end
if setLandingZone == nil then setLandingZone = function() print("stub: setLandingZone"); return 0 end end
if setPowerLevel == nil then setPowerLevel = function() print("stub: setPowerLevel"); return 0 end end
if addDroidToMissionList == nil then addDroidToMissionList = function() print("stub: addDroidToMissionList"); return 0 end end
if setStructureLimits == nil then setStructureLimits = function() print("stub: setStructureLimits"); return 0 end end
if buildingDestroyed == nil then buildingDestroyed = function() print("stub: buildingDestroyed"); return 0 end end
if playSoundPos == nil then playSoundPos = function() print("stub: playSoundPos"); return 0 end end
if killStructsInArea == nil then killStructsInArea = function() print("stub: killStructsInArea"); return 0 end end
if completeResearch == nil then completeResearch = function() print("stub: completeResearch"); return 0 end end
if numDroidsInArea == nil then numDroidsInArea = function() print("stub: numDroidsInArea"); return 0 end end
if startMission == nil then startMission = function() print("stub: startMission"); return 0 end end
if pause == nil then pause = function() print("stub: pause"); return 0 end end
if setNoGoArea == nil then setNoGoArea = function() print("stub: setNoGoArea"); return 0 end end
if numStructsButNotWallsInArea == nil then numStructsButNotWallsInArea = function() print("stub: numStructsButNotWallsInArea"); return 0 end end
if createAlliance == nil then createAlliance = function() print("stub: createAlliance"); return 0 end end
if playSound == nil then playSound = function() print("stub: playSound"); return 0 end end
if setStructTarPref == nil then setStructTarPref = function() print("stub: setStructTarPref"); return 0 end end
if buildDroid == nil then buildDroid = function() print("stub: buildDroid"); return 0 end end
if flyTransporterIn == nil then flyTransporterIn = function() print("stub: flyTransporterIn"); return 0 end end
if seenStructInArea == nil then seenStructInArea = function() print("stub: seenStructInArea"); return 0 end end
if groupAddGroup == nil then groupAddGroup = function() print("stub: groupAddGroup"); return 0 end end
if addMessage == nil then addMessage = function() print("stub: addMessage"); return 0 end end
if structTargetInArea == nil then structTargetInArea = function() print("stub: structTargetInArea"); return 0 end end
if setRadarZoom == nil then setRadarZoom = function() print("stub: setRadarZoom"); return 0 end end
if structureIdle == nil then structureIdle = function() print("stub: structureIdle"); return 0 end end
if groupAddArea == nil then groupAddArea = function() print("stub: groupAddArea"); return 0 end end
if random == nil then random = function() print("stub: random"); return 0 end end
if enableStructure == nil then enableStructure = function() print("stub: enableStructure"); return 0 end end
if centreViewPos == nil then centreViewPos = function() print("stub: centreViewPos"); return 0 end end
if setAssemblyPoint == nil then setAssemblyPoint = function() print("stub: setAssemblyPoint"); return 0 end end
