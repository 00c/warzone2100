-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for
count = 0
group = 0
temp = 0
viewerObj = nil
targetObj = nil
targetObj2 = nil
droid = nil
clusterID = 0

-- VTOL Pads
pad = nil
padX = Array(8)
padY = Array(8)
dontStopFlag = false
pads = Array(8)

-- control whether vtols use rearm pads or appear at the edge of the map
noPads = false

-- VTOL groups and targets
prefDroid = Array(4)
VTOLgroup = Array(4)
attackObj = Array(4)
attackCluster = Array(4)
countTime = Array(4)

-- area within which vtols can be killed
killX1 = 0
killY1 = 0
killX2 = 0
killY2 = 0

-- where the vtols return to and vanish

-- which player is the human player
player = 0

-- whether to use the no visibility target system
noVisTargetting = false


-- declare events

function start()
	count = 0
	while count < numPads do
		pads[count] = addStructure(pad, padPlayer, padX[count], padY[count])
		count = count + 1
	end
	
	-- if there are no rearm pads vtols come from the edge of the map
	noPads = (numPads == 0)
	
	-- eventTraceLevel(1);	//dbWin32 stuff
	
	-- set the target system preferences
	resetStructTargets()
	-- ignore walls
	setStructTarIgnore(ST_WALL)
	count = 0
	while count < numPrefStruc do
		setStructTarPref(prefStruc[count])
		count = count + 1
	end
	resetDroidTargets()
	-- ignore transport
	setDroidTarIgnore(DT_SUPER_HEAVY)
	count = 0
	while count < numPrefDroid do
		setDroidTarPref(prefDroid[count])
		count = count + 1
	end
	
	setVTOLReturnPos(padPlayer, vanishX, vanishY)
	count = 0
	while count < numGroups do
		countTime[count] = startTime[count]
		count = count + 1
	end
	
	-- turn off the visibility targetting system
	if noVisTargetting then
		deactivateEvent(targetFound)
		deactivateEvent(clusterReset)
		deactivateEvent(nextTarget)
		deactivateEvent(resetVis)
		
		-- turn on the no visibility system
		repeatingEvent(nextTargetNoVis, 8.0)
	end
end
callbackEvent(start, CALL_GAMEINIT)

-- do VTOL reinforcements (startTime, everyTime)
-- every 10secs
function addVTOL()
	group = 0
	while group < numGroups do
		countTime[group] = countTime[group] - 1
		if countTime[group] <= 0 then
			countTime[group] = everyTime[group]
			
			temp = groupCountMembers(VTOLgroup[group])
			-- reinforcing a group using rearm pads
			if ((not noPads) and (temp < VTOLsize[group])) or (noPads and (temp == 0) and (attackObj[group] ~= nil)) then
				debugBox(100)
				count = 0
				temp = VTOLsize[group] - groupCountMembers(VTOLgroup[group])
				while count < temp do
					droid = addDroid(templates[group], groupX[group], groupY[group], padPlayer)
					if droid ~= nil then
						groupAddDroid(VTOLgroup[group], droid)
					end
					count = count + 1
				end
				if attackObj[group] ~= nil then
					debugBox(101)
					orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
				end
			end
		end
		group = group + 1
	end
end
repeatingEvent(addVTOL, 10.7)
--[[// only reset this event if using pads
	if (not noPads)
	{
		setEventTrigger (addVTOL, addVTOLTrig);
	}]]--

function vtolOffMap(_droid)
	if _droid.player ~= padPlayer then return end
	droid = _droid -- wz2lua: probably these can be used as function arguments directly
	vanishUnit(droid)
end
callbackEvent(vtolOffMap, CALL_VTOL_OFF_MAP)

-- set up a target for the vtol groups
function targetFound(_targetObj, _viewerObj)
	if _viewerObj.player ~= padPlayer then return end
	targetObj, viewerObj = _targetObj, _viewerObj -- wz2lua: probably these can be used as function arguments directly
	if targetObj ~= nil then
		group = 0
		if targetObj.type == OBJ_DROID then
			if objToDroid(targetObj).droidType == DROID_TRANSPORTER then
				group = numGroups
			end
		end
		while group < numGroups do
			if targetObj.type == targetObjType[group] then
				if (attackObj[group] == nil) and (attackCluster[group] == 0) then
					attackCluster[group] = targetObj.clusterID
					-- clusterID can be 0 for droids - especially near start
					-- when they havn't moved yet
					if attackCluster[group] ~= 0 then
						targetObj2 = targetInCluster(targetObj.clusterID, padPlayer)
					else
						targetObj2 = nil
					end
					
					-- if we've found a target, store it
					if targetObj2 ~= nil then
						attackObj[group] = targetObj2
						attackCluster[group] = targetObj2.clusterID
						debugBox(0)
						debugBox(attackObj[group].id)
						debugBox(attackObj[group].clusterID)
					end
				end
			end
			
			group = group + 1
		end
	end
end
callbackEvent(targetFound, CALL_OBJ_SEEN)

-- remove a cluster from the system if there isn't anything in it
function clusterReset(_clusterID)
	clusterID = _clusterID -- wz2lua: probably these can be used as function arguments directly
	group = 0
	while group < numGroups do
		if attackCluster[group] == clusterID then
			debugBox(200)
			debugBox(clusterID)
			attackObj[group] = nil
			attackCluster[group] = 0
			group = numGroups
		end
		group = group + 1
	end
end
callbackEvent(clusterReset, CALL_CLUSTER_EMPTY)

-- Newer System! Iterates clusters and keeps 5 targets!
function nextTarget()
	group = 0
	while group < numGroups do
		if (attackObj[group] == nil) and (attackCluster[group] ~= 0) then
			debugBox(2)
			attackObj[group] = targetInCluster(attackCluster[group], padPlayer)
			if attackObj[group] == nil then
				attackCluster[group] = 0
			else
				debugBox(attackObj[group].id)
			end
		end
		
		-- order VTOL group to target (if it exists and not already busy)
		if (attackObj[group] ~= nil) and (idleGroup(VTOLgroup[group]) > (groupCountMembers(VTOLgroup[group]) / 2)) then
			debugBox(3)
			debugBox(attackObj[group].id)
			orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
		end
		
		group = group + 1
	end
end
repeatingEvent(nextTarget, 8.0)

-- give targets to vtols without using visibility
function nextTargetNoVis()
	group = 0
	while group < numGroups do
		if targetObjType[group] == OBJ_DROID then
			attackObj[group] = droidTargetOnMap(player, -1)
		else
			attackObj[group] = structTargetOnMap(player, -1)
		end
		
		-- order VTOL group to target (if not already busy)
		if (attackObj[group] ~= nil) and (idleGroup(VTOLgroup[group]) > (groupCountMembers(VTOLgroup[group]) / 2)) then
			debugBox(3)
			debugBox(attackObj[group].id)
			orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
		end
		
		group = group + 1
	end
end

-- reset player visibility if no targets
function resetVis()
	temp = -1
	count = 0
	while count < numGroups do
		if (attackObj[count] == nil) and (attackCluster[count] == 0) then
			temp = count
			count = numGroups
		end
		count = count + 1
	end
	
	if temp ~= -1 then
		debugBox(4)
		resetPlayerVisibility(padPlayer)
	end
end
repeatingEvent(resetVis, 33.3)

function killVTOLS()
	temp = -1
	group = 0
	while group < numGroups do
		if groupCountMembers(VTOLgroup[group]) ~= 0 then
			temp = group
			group = numGroups
		end
		group = group + 1
	end
	
	if temp == -1 then
		count = 0
		while count < numPads do
			if pads[count] ~= nil then
				destroyStructure(pads[count])
			end
			count = count + 1
		end
		deactivateEvent(killVTOLS)
	else
		group = 0
		while group < numGroups do
			initIterateGroup(VTOLgroup[group])
			droid = iterateGroup(VTOLgroup[group])
			while droid ~= nil do
				if (droid.x >= killX1 * 128) and (droid.x <= killX2 * 128) and (droid.y >= killY1 * 128) and (droid.y <= killY2 * 128) then
					vanishUnit(droid)
				end
				droid = iterateGroup(VTOLgroup[group])
			end
			group = group + 1
		end
	end
end

function stopVTOL()
	if not dontStopFlag then
		repeatingEvent(killVTOLS, 4.3)
		deactivateEvent(nextTarget)
		deactivateEvent(targetFound)
		deactivateEvent(addVTOL)
	end
	deactivateEvent(stopVTOL)
end
conditionalEvent(stopVTOL, "destroyed(HQbuilding)", 4.5)

-- cheat button ctrl M
function cheatEvnt()
	count = 0
	while count < numPads do
		if pads[count] ~= nil then
			destroyStructure(pads[count])
		end
		count = count + 1
	end
	group = 0
	while group < numGroups do
		initIterateGroup(VTOLgroup[group])
		droid = iterateGroup(VTOLgroup[group])
		while droid ~= nil do
			vanishUnit(droid)
			droid = iterateGroup(VTOLgroup[group])
		end
		group = group + 1
	end
end
callbackEvent(cheatEvnt, CALL_MISSION_START)


---------- stubs ----------

if destroyStructure == nil then destroyStructure = function() print("stub: destroyStructure"); return 0 end end
if setDroidTarIgnore == nil then setDroidTarIgnore = function() print("stub: setDroidTarIgnore"); return 0 end end
if objToDroid == nil then objToDroid = function() print("stub: objToDroid"); return 0 end end
if setVTOLReturnPos == nil then setVTOLReturnPos = function() print("stub: setVTOLReturnPos"); return 0 end end
if structTargetOnMap == nil then structTargetOnMap = function() print("stub: structTargetOnMap"); return 0 end end
if vanishUnit == nil then vanishUnit = function() print("stub: vanishUnit"); return 0 end end
if resetStructTargets == nil then resetStructTargets = function() print("stub: resetStructTargets"); return 0 end end
if setStructTarPref == nil then setStructTarPref = function() print("stub: setStructTarPref"); return 0 end end
if setStructTarIgnore == nil then setStructTarIgnore = function() print("stub: setStructTarIgnore"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if resetPlayerVisibility == nil then resetPlayerVisibility = function() print("stub: resetPlayerVisibility"); return 0 end end
if debugBox == nil then debugBox = function() print("stub: debugBox"); return 0 end end
if destroyed == nil then destroyed = function() print("stub: destroyed"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if initIterateGroup == nil then initIterateGroup = function() print("stub: initIterateGroup"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if resetDroidTargets == nil then resetDroidTargets = function() print("stub: resetDroidTargets"); return 0 end end
if addStructure == nil then addStructure = function() print("stub: addStructure"); return 0 end end
if addDroid == nil then addDroid = function() print("stub: addDroid"); return 0 end end
if droidTargetOnMap == nil then droidTargetOnMap = function() print("stub: droidTargetOnMap"); return 0 end end
if buildingDestroyed == nil then buildingDestroyed = function() print("stub: buildingDestroyed"); return 0 end end
if orderGroupObj == nil then orderGroupObj = function() print("stub: orderGroupObj"); return 0 end end
if iterateGroup == nil then iterateGroup = function() print("stub: iterateGroup"); return 0 end end
if targetInCluster == nil then targetInCluster = function() print("stub: targetInCluster"); return 0 end end
if setDroidTarPref == nil then setDroidTarPref = function() print("stub: setDroidTarPref"); return 0 end end
