-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for

-- Structure Limits

-- Initialisation
-- done in arrays so don't need to define for non submaps
-- transX[0] = entryX, transX[1] = exitX

-- Briefings

-- Time Limit

-- 'Globals'
-- mission lost

-- General variables
-- for while loops
count = 0
count2 = 0
countBriefs = 0
temp = 0
temp1 = 0
temp2 = 0
tempX = 0
tempY = 0
winFlag = false

-- Starting Tech for Enemy


-- VTOLS
group = 0
viewerObj = nil
targetObj = nil
droid = nil
clusterID = 0


-- VTOL groups and targets
VTOLgroup = Array(2)
attackObj = Array(2)
attackCluster = Array(2)
countTime = Array(2)

-- where the vtols return to and vanish

-- Ground forces
-- Groups
-- these can be for any player!
grpRegionGo = Array(10)
grpWhoGo = Array(10)
grpLeadership = Array(10)
grpRetreatXY = Array(10)
-- keep track of already triggered groups
grpFlagGo = Array(10)
-- the actual groups are stored in this, based on region.
grpGroup = Array(10)
grpReinforce = Array(10)
-- keep track of current waypoint
grpPosCurrent = Array(10)
-- keep track of already ordered
grpBusy = Array(10)
-- keeps track of time since started level, for triggering groups
timeGroup = 0

-- Factories
-- these can be for any player!
factRegionGo = Array(11)
-- stores whether producing or not
factFlagGo = Array(11)
-- store count for next production
factTime = Array(11)
testDroid = nil
newDroid = nil
-- new droid built
newDroidFactory = nil
-- for phantom factories
newDroidFactoryIndex = 0

-- lists

-- transports
-- enemy transport entry, exit
-- enemy transport landing
transportDroid = Array(2)
transOnMap = Array(2)
playerTransOnMap = false
reinfOff = false
transGroup = Group()
-- used for enemy transports landing
transGroupIndex = Array(2)
transGroupPlayer = 0
enemyLZX = 0
enemyLZY = 0

-- ********************

-- Declared Events

-- Initialisation
function start()
	setDroidsToSafetyFlag(true)
	randomiseSeed()
	-- centre view
	centreViewPos(centreX, centreY)
	
	-- set scroll limits
	-- setScrollParams(scrollX1, scrollY1, scrollX2, scrollY2);
	
	-- set radar zoom level
	setRadarZoom(zoomLevel)
	
	-- set Mission time limit
	setMissionTime(timeLimit/10.0)
	
	-- set LZ and no go areas - shouldn't need to do this any more - it is until all NoGoAreas are saved in the save game info
	-- The LZ can now be set up just before FlyTransporterIn()
	initAllNoGoAreas()
	count = 0
	while count < numLZ do
		setNoGoArea(LZX[count] - 1, LZY[count] - 1, LZX[count] + 1, LZY[count] + 1, count)
		count = count + 1
	end
	
	-- set structure limits
	count = 0
	while count < numStrucStats do
		setStructureLimits(strucStat[count], strucLimit[count], player)
		enableStructure(strucStat[count], player)
		count = count + 1
	end
	-- give Enemy Starting Tech
	count = 0
	while count < numTechs do
		completeResearch(startTech[count], enemy[0])
		count = count + 1
	end
	
	-- place transport
	addDroid(transporter, (LZX[0] * 128) + 64, (LZY[0] * 128) + 64, player)
	setTransporterExit(player, transX[1], transY[1])
	
	setReinforcementTime(ReinforceTime/10.0)
	
	-- VTOLS
	setVTOLReturnPos(padPlayer, vanishX, vanishY)
	count = 0
	while count < numVTOL do
		countTime[count] = startTime[count]
		count = count + 1
	end
	
	-- Ground Forces
	-- setup groups
	count = 0
	while count < numGroups do
		grpPosCurrent[count] = grpPosStart[count]
		
		-- set time = 0 groups going
		if grpTimeGo[count] == timeGroup then
			grpFlagGo[count] = true
			-- use coords for patrol/ambush/defence
			if grpType[count] < 2 then
				if grpPosStart[count] >= 0 then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
				end
			end
		end
		count = count + 1
	end
	-- set time = 0 factories going
	count = 0
	while count < numFactories do
		if (factTimeGo[count] == timeGroup) and (not factFlagGo[count]) then
			factFlagGo[count] = true
		end
		count = count + 1
	end
	
	-- play mission brief(s)
	if numBriefs > 0 then
		if briefVal[0] < 2 then
			addMessage(brief[0], MISS_MSG, 0, true)
		else
			addMessage(brief[0], MISS_MSG, 0, false)
			-- last briefing?
			if countBriefs >= numBriefs then
				deactivateEvent(briefings)
			end
		end
		countBriefs = 1
	end
end
callbackEvent(start, CALL_GAMEINIT)


-- need to rework this better!!
function briefings()
	if briefVal[countBriefs - 1] == 0 then
		removeMessage(brief[countBriefs - 1], MISS_MSG, 0)
	end
	
	-- last briefing?
	if countBriefs >= numBriefs then
		deactivateEvent(briefings)
	end
	
	-- add next brief
	if countBriefs < numBriefs then
		if briefVal[countBriefs] < 2 then
			addMessage(brief[countBriefs], MISS_MSG, 0, true)
		else
			addMessage(brief[countBriefs], MISS_MSG, 0, false)
		end
		countBriefs = countBriefs + 1
	end
end
callbackEvent(briefings, CALL_VIDEO_QUIT)

function launched()
	winFlag = true
	deactivateEvent(launched)
end
callbackEvent(launched, CALL_LAUNCH_TRANSPORTER)

-- need an event to check all player stuff isn't dead, once got transport taken off CALLBACK
-- for losing
function gameLost()
	gameOverMessage(endMsg, MISS_MSG, 0, false)
	deactivateEvent(gameLost)
end

function nextLevEvnt()
	if winFlag then
		addMessage(brief[2], MISS_MSG, 0, true)
		-- pause(1);
		startMission(OFF_KEEP, NextLev)
	else
		repeatingEvent(gameLost, 2.0)
	end
	deactivateEvent(nextLevEvnt)
end
callbackEvent(nextLevEvnt, CALL_START_NEXT_LEVEL)

-- out of time?
function timeUp()
	if winFlag then
		addMessage(brief[2], MISS_MSG, 0, true)
		-- pause(1);
		-- go to next mission
		-- setEventTrigger(nextLevEvnt, winLoseTrig);	//this causes it to crash!
		startMission(OFF_KEEP, NextLev)
	else
		repeatingEvent(gameLost, 2.0)
	end
	deactivateEvent(timeUp)
end
callbackEvent(timeUp, CALL_MISSION_TIME)

function lostYetEvnt()
	if not anyDroidsLeft(player) then
		if not anyStructButWallsLeft(player) then
			deactivateEvent(lostYetEvnt)
			if winFlag then
				startMission(OFF_KEEP, NextLev)
			else
				deactivateEvent(launched)
				-- waits 2 seconds before ending
				repeatingEvent(gameLost, 2.0)
			end
		end
	end
end
repeatingEvent(lostYetEvnt, 5.3)




-- VTOLS ATTACK

-- do VTOL reinforcements (startTime, everyTime)
-- every 10secs
function addVTOL()
	group = 0
	while group < numVTOL do
		countTime[group] = countTime[group] - 1
		if countTime[group] <= 0 then
			countTime[group] = everyTime[group]
			
			temp = groupCountMembers(VTOLgroup[group])
			-- creating a group at the edge of the map
			if (temp == 0) and (attackObj[group] ~= nil) then
				debugBox(100)
				count = 0
				temp = VTOLsize[group] - groupCountMembers(VTOLgroup[group])
				-- choose random start coord
				temp1 = random(5)
				while count < temp do
					droid = addDroid(templatesVTOL[group][random(2)], groupX[temp1], groupY[temp1], padPlayer)
					if droid ~= nil then
						groupAddDroid(VTOLgroup[group], droid)
					end
					count = count + 1
				end
				if attackObj[group] ~= nil then
					debugBox(101)
					orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
				end
			end
		end
		group = group + 1
	end
end
repeatingEvent(addVTOL, 10.7)


function vtolOffMap(_droid)
	if _droid.player ~= padPlayer then return end
	droid = _droid -- wz2lua: probably these can be used as function arguments directly
	vanishUnit(droid)
end
callbackEvent(vtolOffMap, CALL_VTOL_OFF_MAP)

function getTargets()
	group = 0
	while group < numVTOL do
		if attackObj[group] == nil then
			if targetObjType[group] == 1 then
				resetStructTargets()
				setStructTarIgnore(ST_WALL)
				setStructTarPref(ST_FACTORY)
				setStructTarPref(ST_CYBORG_FACTORY)
				setStructTarPref(ST_VTOL_FACTORY)
				setStructTarPref(ST_RESEARCH)
				setStructTarPref(ST_POWER_GEN)
				setStructTarPref(ST_HQ)
				attackObj[group] = structTargetInArea(player, padPlayer, baseX1, baseY1, baseX2, baseY2)
			else
				if targetObjType[group] == 0 then
					resetDroidTargets()
					-- ignore transport
					setDroidTarIgnore(DT_SUPER_HEAVY)
					attackObj[group] = droidTargetInArea(player, padPlayer, baseX1, baseY1, baseX2, baseY2)
				end
			end
			if attackObj[group] ~= nil then
				orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
			end
		end
		group = group + 1
	end
end
repeatingEvent(getTargets, 6.7)


-- Ground Force attacks
function wayGroups()
	count = 0
	while count < numGroups do
		if (grpFlagGo[count]) and (grpType[count] < 2) and (grpPosStart[count] >= 0) then
			if (groupCountMembers(grpGroup[count]) > 0) and (idleGroup(grpGroup[count]) >= groupCountMembers(grpGroup[count]) / 2) then
				grpBusy[count] = false
				-- store for checking difference later
				temp = grpPosCurrent[count]
				-- random choice
				if grpPosType[count] == 3 then
					grpPosCurrent[count] = grpPosMin[count] + grpPosStep[count] * random(grpPosMax[count] - grpPosMin[count])
				else
					grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
				end
				if (grpPosCurrent[count] > grpPosMax[count]) or (grpPosCurrent[count] < grpPosMin[count]) then
					grpPosCurrent[count] = grpPosCurrent[count] - grpPosStep[count]
					-- loop
					if grpPosType[count] == 1 then
						if grpPosStep[count] > 0 then
							grpPosCurrent[count] = grpPosMin[count]
						else
							grpPosCurrent[count] = grpPosMax[count]
						end
					end
					-- ping pong
					if grpPosType[count] == 2 then
						grpPosStep[count] = -grpPosStep[count]
						grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
					end
				end
				-- don't order again if already there!
				if grpPosCurrent[count] ~= temp then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]])
				end
			end
		end
		-- orderGroupLoc(grpGroup[count], DORDER_MOVE, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]]);
		count = count + 1
	end
end
repeatingEvent(wayGroups, 10.7)

function factoryProdEvnt()
	count = 0
	while count < numFactories do
		if factFlagGo[count] then
			factTime[count] = factTime[count] + 1
			-- time to do stuff?
			if factTime[count] >= factEvery[count] then
				if factID[count] < 0 then
					newDroidFactoryIndex = count
					newDroid = nil
					-- so as not to confuse with a proper factory!
					newDroidFactory = nil
					delayedEvent(droidBuilt, 0.1)
				end
			end
		end
		
		count = count + 1
	end
end
repeatingEvent(factoryProdEvnt, 9.7)

-- triggered by later callbacks
function droidBuilt()
	temp2 = 0
	-- temp = -1;		//in case not found
	-- in case not found (so doesn't use a droidfactory from another script)
	temp = -2
	
	-- deal with phantom factory
	if newDroidFactoryIndex >= 0 then
		temp = newDroidFactoryIndex
	end
	-- check thru groups to reinforce
	count = 0
	
	while count < numGroups do
		if ((temp == grpFactory[count]) or ((grpFactory[count] == -1) and (temp ~= -2))) and (groupCountMembers(grpGroup[count]) < grpIdealSize[count]) then
			if newDroid ~= nil then
				groupAddDroid(grpReinforce[count], newDroid)
			else
				-- deal with phantom factory
				if newDroidFactoryIndex >= 0 then
					if factID[newDroidFactoryIndex] == -1 then
						factTime[newDroidFactoryIndex] = 0
						count2 = 0
						while count2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
							temp1 = factTempMin[newDroidFactoryIndex] + count2
							-- create more for lower template numbers, less for higher!
							temp2 = count2
							while temp2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
								newDroid = addDroid(templates[temp1], coordsX[factAssXY[newDroidFactoryIndex]], coordsY[factAssXY[newDroidFactoryIndex]], enemy[grpPlayer[count]])
								if newDroid ~= nil then
									groupAddDroid(grpReinforce[count], newDroid)
								end
								temp2 = temp2 + 1
							end
							count2 = count2 + 1
						end
					else
						-- deal with transport if not on map
						if (factID[newDroidFactoryIndex] == -2) and (not transOnMap[grpPlayer[count]]) then
							factTime[newDroidFactoryIndex] = 0
							-- need to check LZ has defences, otherwise turn off this phantom factory
							temp1 = factAssXY[newDroidFactoryIndex]
							if numStructsInArea(enemy[grpPlayer[count]], (LZX[temp1] - 4) * 128, (LZY[temp1] - 4) * 128, (LZX[temp1] + 4) * 128, (LZY[temp1] + 4) * 128) == 0 then
								factFlagGo[newDroidFactoryIndex] = false
								-- make next time very large ~100 hours
								factEvery[newDroidFactoryIndex] = 32767
							else
								setNoGoArea(LZX[factAssXY[newDroidFactoryIndex]] - 1, LZY[factAssXY[newDroidFactoryIndex]] - 1, LZX[factAssXY[newDroidFactoryIndex]] + 1, LZY[factAssXY[newDroidFactoryIndex]] + 1, enemy[grpPlayer[newDroidFactoryIndex]])
								-- make sure got position in world coords of this LZ for playSound
								enemyLZX = LZX[factAssXY[newDroidFactoryIndex]] * 128
								enemyLZY = LZY[factAssXY[newDroidFactoryIndex]] * 128
								count2 = 0
								while count2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
									temp1 = factTempMin[newDroidFactoryIndex] + count2
									-- create more for lower template numbers, less for higher!
									temp2 = count2
									while temp2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
										newDroid = addDroidToMissionList(templates[temp1], enemy[grpPlayer[count]])
										if newDroid ~= nil then
											addDroidToTransporter(transportDroid[grpPlayer[count]], newDroid)
										end
										temp2 = temp2 + 1
									end
									count2 = count2 + 1
								end
								-- call in transport
								setTransporterExit(enemy[grpPlayer[count]], exitX[grpPlayer[count]], exitY[grpPlayer[count]])
								flyTransporterIn(enemy[grpPlayer[count]], entryX[grpPlayer[count]], entryY[grpPlayer[count]], false)
								transOnMap[grpPlayer[count]] = true
								-- store for when transport lands
								transGroupIndex[grpPlayer[count]] = count
								-- may mess up multiple enemies having transports?
								transGroupPlayer = grpPlayer[count]
								callbackEvent(transLanded, CALL_TRANSPORTER_LANDED)
								callbackEvent(transGone1, CALL_TRANSPORTER_OFFMAP)
							end
						end
					end
				end
			end
			-- if group dead, add to group and reset starting sector?
			if groupCountMembers(grpGroup[count]) == 0 then
				groupAddGroup(grpGroup[count], grpReinforce[count])
				-- set back to start sector...?
				-- go back to min sector if starting group from scratch
				grpPosCurrent[count] = grpPosMin[count]
			else
				-- if ideal size, add to main group!
				if (groupCountMembers(grpGroup[count]) + groupCountMembers(grpReinforce[count])) >= grpIdealSize[count] then
					groupAddGroup(grpGroup[count], grpReinforce[count])
				end
			end
			-- grpPosCurrent[count] = grpPosMin[count];		//test for now so can see if added to group
			-- test order only!!!
			-- orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]]);
			-- exit early
			count = numGroups
			temp2 = 1
		end
		count = count + 1
	end
end
-- if temp2 != 0, ie not assigned to a group, put in a special group for that player, and pull out if a group can take from any and
-- needs reinforcing. (another event to check thru pooled group?)
-- still to be done!


function droidBuilt2(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 2 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt2, CALL_NEWDROID)

-- trigger set when transport called
function transLanded(_transGroup, _player)
	if _player ~= enemy[transGroupPlayer] then return end
	temp = transGroupIndex[transGroupPlayer]
	-- test sound for now
	-- playSound(transSnd, player);		//Enemy Transport Landing
	-- need to look at enemy LZ???
	playSoundPos(transSnd, player, enemyLZX, enemyLZY, 0)
	
	groupAddGroup(grpReinforce[temp], transGroup)
	-- might just want to add directly to grpGroup?
	-- if group dead, add to group and reset starting sector?
	if groupCountMembers(grpGroup[temp]) == 0 then
		grpPosCurrent[temp] = grpPosMin[temp]
		-- give first orders unless scouts, since use sectors, or no waypoints defined
		if (grpType[temp] < 2) and (grpPosStart[temp] >= 0) then
			orderGroupLoc(grpReinforce[temp], DORDER_SCOUT, coordsX[grpPosCurrent[temp]], coordsY[grpPosCurrent[temp]])
		end
		groupAddGroup(grpGroup[temp], grpReinforce[temp])
	end
	-- set back to start sector...?
	-- if >= ideal size add to group
	if (groupCountMembers(grpGroup[temp]) + groupCountMembers(grpReinforce[temp])) >= grpIdealSize[temp] then
		if (grpType[temp] < 2) and (grpPosStart[temp] >= 0) then
			orderGroupLoc(grpReinforce[temp], DORDER_SCOUT, coordsX[grpPosCurrent[temp]], coordsY[grpPosCurrent[temp]])
		end
		groupAddGroup(grpGroup[temp], grpReinforce[temp])
	end
	callbackEvent(transLanded, CALL_TRANSPORTER_LANDED)
end

-- allow next transport!!
function transGone1(_player)
	if _player ~= enemy[transGroupPlayer] then return end
	transOnMap[grpPlayer[transGroupPlayer]] = false
end

-- update time count for triggering groups and factories...
function timeGroupsEvnt()
	timeGroup = timeGroup + 1
	count = 0
	-- update groups
	while count < numGroups do
		if (grpTimeGo[count] == timeGroup) and (not grpFlagGo[count]) then
			grpFlagGo[count] = true
			-- scouts don't use coords array, so don't bother with initial order!
			if grpType[count] < 2 then
				orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
			end
		end
		count = count + 1
	end
	-- update factories
	count = 0
	while count < numFactories do
		if (factTimeGo[count] == timeGroup) and (not factFlagGo[count]) and (factTime[count] == 0) then
			factFlagGo[count] = true
			-- allow to produce straight away!
			factTime[count] = factEvery[count]
		end
		count = count + 1
	end
end
repeatingEvent(timeGroupsEvnt, 10.0)


---------- stubs ----------

if gameOverMessage == nil then gameOverMessage = function() print("stub: gameOverMessage"); return 0 end end
if setDroidTarIgnore == nil then setDroidTarIgnore = function() print("stub: setDroidTarIgnore"); return 0 end end
if addDroid == nil then addDroid = function() print("stub: addDroid"); return 0 end end
if setDroidsToSafetyFlag == nil then setDroidsToSafetyFlag = function() print("stub: setDroidsToSafetyFlag"); return 0 end end
if orderGroupObj == nil then orderGroupObj = function() print("stub: orderGroupObj"); return 0 end end
if resetStructTargets == nil then resetStructTargets = function() print("stub: resetStructTargets"); return 0 end end
if setStructTarPref == nil then setStructTarPref = function() print("stub: setStructTarPref"); return 0 end end
if setMissionTime == nil then setMissionTime = function() print("stub: setMissionTime"); return 0 end end
if setStructTarIgnore == nil then setStructTarIgnore = function() print("stub: setStructTarIgnore"); return 0 end end
if anyStructButWallsLeft == nil then anyStructButWallsLeft = function() print("stub: anyStructButWallsLeft"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if addDroidToTransporter == nil then addDroidToTransporter = function() print("stub: addDroidToTransporter"); return 0 end end
if initAllNoGoAreas == nil then initAllNoGoAreas = function() print("stub: initAllNoGoAreas"); return 0 end end
if orderGroupLoc == nil then orderGroupLoc = function() print("stub: orderGroupLoc"); return 0 end end
if anyDroidsLeft == nil then anyDroidsLeft = function() print("stub: anyDroidsLeft"); return 0 end end
if startMission == nil then startMission = function() print("stub: startMission"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if removeMessage == nil then removeMessage = function() print("stub: removeMessage"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if resetDroidTargets == nil then resetDroidTargets = function() print("stub: resetDroidTargets"); return 0 end end
if droidTargetInArea == nil then droidTargetInArea = function() print("stub: droidTargetInArea"); return 0 end end
if setReinforcementTime == nil then setReinforcementTime = function() print("stub: setReinforcementTime"); return 0 end end
if setStructureLimits == nil then setStructureLimits = function() print("stub: setStructureLimits"); return 0 end end
if setVTOLReturnPos == nil then setVTOLReturnPos = function() print("stub: setVTOLReturnPos"); return 0 end end
if addDroidToMissionList == nil then addDroidToMissionList = function() print("stub: addDroidToMissionList"); return 0 end end
if debugBox == nil then debugBox = function() print("stub: debugBox"); return 0 end end
if random == nil then random = function() print("stub: random"); return 0 end end
if numStructsInArea == nil then numStructsInArea = function() print("stub: numStructsInArea"); return 0 end end
if completeResearch == nil then completeResearch = function() print("stub: completeResearch"); return 0 end end
if vanishUnit == nil then vanishUnit = function() print("stub: vanishUnit"); return 0 end end
if setNoGoArea == nil then setNoGoArea = function() print("stub: setNoGoArea"); return 0 end end
if setTransporterExit == nil then setTransporterExit = function() print("stub: setTransporterExit"); return 0 end end
if addMessage == nil then addMessage = function() print("stub: addMessage"); return 0 end end
if flyTransporterIn == nil then flyTransporterIn = function() print("stub: flyTransporterIn"); return 0 end end
if groupAddGroup == nil then groupAddGroup = function() print("stub: groupAddGroup"); return 0 end end
if randomiseSeed == nil then randomiseSeed = function() print("stub: randomiseSeed"); return 0 end end
if playSoundPos == nil then playSoundPos = function() print("stub: playSoundPos"); return 0 end end
if structTargetInArea == nil then structTargetInArea = function() print("stub: structTargetInArea"); return 0 end end
if setRadarZoom == nil then setRadarZoom = function() print("stub: setRadarZoom"); return 0 end end
if enableStructure == nil then enableStructure = function() print("stub: enableStructure"); return 0 end end
if centreViewPos == nil then centreViewPos = function() print("stub: centreViewPos"); return 0 end end
