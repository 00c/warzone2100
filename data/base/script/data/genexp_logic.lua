-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for
lastLev = false

-- Define Players/Enemies
-- MAX targets = 4, need array one bigger!
targetCount = Array(2)
targetX = Array(2, 5)
targetY = Array(2, 5)

-- Starting Enemy Power

-- Starting health retreat setting
healthRetreat = Array(2)
healthRetreatX = Array(2)
healthRetreatY = Array(2)
runOffFlag = false

-- Structure Limits

-- Initialisation

-- Transport Entry/Exit coords
-- done in arrays so don't need to define for non submaps
-- transX[0] = entryX, transX[1] = exitX
timeLimit = 0
-- enemy transport entry, exit
entryX = Array(2)
entryY = Array(2)
exitX = Array(2)
exitY = Array(2)
-- required for enemy transports landing
transportDroid = Array(2)
transOnMap = Array(2)
playerTransOnMap = false
reinfOff = false
transGroup = Group()
-- used for enemy transports landing
transGroupIndex = Array(2)
transGroupPlayer = 0
enemyLZX = 0
enemyLZY = 0

-- Videos - should only be max of two - and that's for the PSX - actually we need 8 (cam1->2)!
numVideos = 0
video = Array(8)
videoText = Array(8)

-- Briefings

-- Victory Conditions
-- extra victories checked in other scripts
linkVictory = false
linkFail = false

-- Failure Conditions
failSnd = nil

-- Time Limit
-- false = time limit fail OK, True = don't use time limit as fail
noTimeLimit = false

-- Objectives
objectiveFlag = Array(4)
objectivesDone = 0

-- Artifacts
-- public		INTMESSAGE	artMsg[6];
artID = Array(6)
artFlag = Array(6)
artCollected = 0

-- Enemy Base Blips
baseFlag = Array(7)
basesDead = 0

-- Return to LZ Stuff
-- must be set to have any affect
-- audio to play
-- LZ blip

-- Groups
-- these can be for any player!
-- keep track of already triggered groups
grpFlagGo = Array(10)
-- the actual groups are stored in this, based on region.
grpGroup = Array(10)
grpReinforce = Array(10)
-- keep track of current waypoint
grpPosCurrent = Array(10)
-- keep track of already ordered
grpBusy = Array(10)
-- keeps track of time since started level, for triggering groups
timeGroup = 0

-- Factories
-- these can be for any player!
-- stores whether producing or not
factFlagGo = Array(11)
-- store count for next production
factTime = Array(11)

-- LISTS OF STUFF (INDEXED BY ARRAY)

features = Array(10)
droids = Array(10)
sectorsX1 = Array(20)
sectorsY1 = Array(20)
sectorsX2 = Array(20)
sectorsY2 = Array(20)

-- 'Globals'
-- artifact pickup/obj blip removal
-- range to waypoints/range for targets
-- maximum number of targets (4)
-- mission lost
-- Base Under Attack Sound
-- base detected/dead
-- enemy transport landing
transSnd = nil
LZRange = 0

-- General variables
-- for while loops
count = 0
count2 = 0
count3 = 0
testDroid = nil
newDroid = nil
-- new droid built
newDroidFactory = nil
-- for phantom factories
newDroidFactoryIndex = 0
countBriefs = 0
temp = 0
temp1 = 0
temp2 = 0
tempX = 0
tempY = 0
countVideos = 0
-- Base Under Attack
hitStruc = nil
-- Base Under Attack
attackerObj = nil
-- Base Under Attack time delay for next warning
t = 0
-- for enemy base attack stuff!
enemyCount = 0
-- for building oil derricks on oil resources
feature = nil

-- Trucks stuff
-- won't work without this set to TRUE!!!
-- defences to build
boolResult = false
truckFlag = false
truckGroup = Array(2)

-- Threat Stuff


-- Initialisation
function start()
	centreViewPos(centreX, centreY)
	
	-- more flexible alliance system
	createAlliance(player, alliancePlayer)
	count = 0
	while count < numEnemies do
		createAlliance(enemy[count], allianceEnemy[count])
		count = count + 1
	end
	
	-- set radar zoom level
	setRadarZoom(zoomLevel)
	-- set LZ and no go areas - HAS to be done BEFORE FlyTransportersIn
	initAllNoGoAreas()
	count = 0
	while count < numLZ do
		setNoGoArea(LZX[count] - 1, LZY[count] - 1, LZX[count] + 1, LZY[count] + 1, count)
		count = count + 1
	end
	-- call in transport
	flyTransporterIn(player, transX[0], transY[0], false)
	setTransporterExit(player, transX[1], transY[1])
	-- set enemy transports if applicable
	count = 0
	while count < numEnemies do
		if entryX[count] ~= 0 then
			transportDroid[count] = addDroidToMissionList(transporter, enemy[count])
		end
		count = count + 1
	end
	-- transGroupPlayer = 1;	//make sure not 0!! since will control player's units
	-- to cope with map expansions after sub maps!!!
	if timeLimit ~= 0 then
		setMissionTime(timeLimit/10.0)
	end
	-- set transport time
	if not reinfOff then
		setReinforcementTime(ReinforceTime/10.0)
	end
	
	-- set structure limits
	count = 0
	while count < numStrucStats do
		setStructureLimits(strucStat[count], strucLimit[count], player)
		enableStructure(strucStat[count], player)
		count = count + 1
	end
	
	-- set power levels
	count = 0
	while count < numEnemies do
		count2 = 0
		while count2 < numTechs[count] do
			completeResearch(startTech[count][count2], enemy[count])
			count2 = count2 + 1
		end
		setPowerLevel(power[count], enemy[count])
		count = count + 1
	end
	
	-- show player start objectives
	count = 0
	while count < numObjectives do
		addMessage(objective[count], PROX_MSG, player, false)
		count = count + 1
	end
	-- disable time fail if desired
	if noTimeLimit then
		deactivateEvent(timeUp)
	end
	-- Setup Artifacts already on map (NOT TESTED YET!)
	-- setting flags incorrectly in VLO could break game!
	count = 0
	while count < numArt do
		if artType[count] >= 4 then
			artFlag[count] = 4
		end
		-- deal with artifact already on map
		if artType[count] == 0 then
			artID[count] = features[artVal[count]]
			artFlag[count] = 1
		end
		count = count + 1
	end
	
	-- setup enemy players health retreat settings
	count = 0
	while count < numEnemies do
		if healthRetreat[count] > 0 then
			setRetreatHealth(enemy[count], healthRetreat[count])
			setRetreatPoint(enemy[count], healthRetreatX[count], healthRetreatY[count])
		end
		count = count + 1
	end
	
	-- setup groups
	count = 0
	while count < numGroups do
		if grpRegion[count] >= 0 then
			groupAddArea(grpGroup[count], enemy[grpPlayer[count]], regionsX1[grpRegion[count]], regionsY1[grpRegion[count]], regionsX2[grpRegion[count]], regionsY2[grpRegion[count]])
		end
		grpPosCurrent[count] = grpPosStart[count]
		-- set morale levels
		if grpMorale[count] >= 0 then
			setGroupRetreatForce(grpGroup[count], grpMorale[count])
			setGroupRetreatLeadership(grpGroup[count], grpLeadership[count])
			-- use coords for patrol/ambush/defence
			if grpType[count] < 2 then
				setGroupRetreatPoint(grpGroup[count], coordsX[grpRetreatXY[count]], coordsY[grpRetreatXY[count]])
			else
				temp = grpRetreatXY[count]
				-- order scout/attack forces to random position in this sector
				tempX = sectorsX1[temp] + random(sectorsX2[temp] - sectorsX1[temp])
				tempY = sectorsY1[temp] + random(sectorsY2[temp] - sectorsY1[temp])
				setGroupRetreatPoint(grpGroup[count], tempX, tempY)
			end
		end
		-- set time = 0 groups going
		if grpTimeGo[count] == timeGroup then
			grpFlagGo[count] = true
			-- use coords for patrol/ambush/defence
			if grpType[count] < 2 then
				if grpPosStart[count] >= 0 then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
				end
			else
				temp = grpPosCurrent[count]
				-- order scout/attack forces to random position in this sector
				tempX = sectorsX1[temp] + random(sectorsX2[temp] - sectorsX1[temp])
				tempY = sectorsY1[temp] + random(sectorsY2[temp] - sectorsY1[temp])
				-- changed to SCOUT 21/01/99
				orderGroupLoc(grpGroup[count], DORDER_SCOUT, tempX, tempY)
			end
		end
		-- link to sensors for IDF groups (same index!)
		if grpType[count] == -1 then
			orderGroupObj(grpGroup[count], DORDER_FIRESUPPORT, droids[count])
		end
		count = count + 1
	end
	-- set time = 0 factories going
	count = 0
	while count < numFactories do
		if (factAssXY[count] ~= -1) and (factID[count] >= 0) then
			setAssemblyPoint(structures[factID[count]], coordsX[factAssXY[count]], coordsY[factAssXY[count]])
		end
		if (factTimeGo[count] == timeGroup) and (not factFlagGo[count]) then
			factFlagGo[count] = true
		end
		count = count + 1
	end
	
	-- NEW! use trucks given as droids for each enemy
	-- Now done after groups set up so can pull them out of existing groups if necessary!
	if trucksOn then
		count = 0
		while count < numEnemies do
			initGetFeature(oilRes, enemy[count], enemy[count])
			count = count + 1
		end
		count = 0
		while droids[count] ~= nil do
			if droids[count].droidType == DROID_CONSTRUCT then
				count2 = 0
				while count2 < numEnemies do
					if droids[count].player == enemy[count2] then
						groupAddDroid(truckGroup[count2], droids[count])
					end
					count2 = count2 + 1
				end
			end
			count = count + 1
		end
		repeatingEvent(checkTrucks, 29.0)
	end
	-- END of find trucks
	
	-- allow win/lose checks
	conditionalEvent(wonYetEvnt, "artCollected >= victoryArt", 2.5)
	repeatingEvent(lostYetEvnt, 2.5)
	-- allow LZ compromised checks;
	if ReinforceTime < 0 then
		deactivateEvent(LZNoGo)
	end
	-- default LZRange
	if LZRange == 0 then
		LZRange = 768
	end
	
	-- play any video requirements before the briefings
	if numVideos > 0 then
		playVideo(video[0], videoText[0])
		countVideos = 1
		-- allow next video or next briefing
		callbackEvent(briefings, CALL_VIDEO_QUIT)
	else
		if numBriefs > 0 then
			if briefVal[0] < 2 then
				addMessage(brief[0], MISS_MSG, 0, true)
				-- allow next one
				callbackEvent(briefings, CALL_VIDEO_QUIT)
			else
				addMessage(brief[0], MISS_MSG, 0, false)
				-- last briefing?
				if countBriefs >= numBriefs then
					deactivateEvent(briefings)
				end
			end
			countBriefs = 1
		end
	end
end
callbackEvent(start, CALL_GAMEINIT)

function briefings()
	if countVideos < numVideos then
		playVideo(video[countVideos], videoText[countVideos])
		countVideos = countVideos + 1
	else
		if countBriefs > 0 then
			if briefVal[countBriefs - 1] == 0 then
				removeMessage(brief[countBriefs - 1], MISS_MSG, 0)
			end
		end
		
		-- last briefing?
		if countBriefs >= numBriefs then
			deactivateEvent(briefings)
		end
		
		-- add next brief
		if countBriefs < numBriefs then
			if briefVal[countBriefs] < 2 then
				addMessage(brief[countBriefs], MISS_MSG, 0, true)
			else
				addMessage(brief[countBriefs], MISS_MSG, 0, false)
			end
			countBriefs = countBriefs + 1
		end
	end
end

-- Base Under Attack
function baseHit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= C.selectedPlayer then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if t >= 20 then
		t = 0
		if hitStruc ~= nil then
			playSoundPos(attackSnd1, C.selectedPlayer, hitStruc.x, hitStruc.y, hitStruc.z)
		else
			playSound(attackSnd1, C.selectedPlayer)
		end
	end
end
callbackEvent(baseHit, CALL_STRUCT_ATTACKED)

-- update time delay before told again (about 20 seconds)
function everySec()
	t = t + 1
end
repeatingEvent(everySec, 2.0)

-- Remove Objective Blips
function removeObjectives()
	if objectivesDone == numObjectives then
		deactivateEvent(removeObjectives)
	else
		count = 0
		while count < numObjectives do
			if (not objectiveFlag[count]) and (droidInRange(player, objectiveX[count], objectiveY[count], objectiveRange)) then
				objectiveFlag[count] = true
				objectivesDone = objectivesDone + 1
				removeMessage(objective[count], PROX_MSG, player)
			end
			count = count + 1
		end
	end
end
repeatingEvent(removeObjectives, 1.5)

-- Artifacts
-- This works for artifacts from STRUCTURES, FEATURES or DROIDS as well as crates already on map!
-- tested for STRUCTURES, FEATURES, DROIDS and starting CRATES
-- update artifact list
function artLoop()
	if artCollected >= numArt then
		deactivateEvent(artLoop)
	else
		count = 0
		while count < numArt do
			if artFlag[count] == 0 then
				temp = 0
				-- might be a better way to do this check?
				if artType[count] == 1 then
					if structures[artVal[count]] == nil then
						temp = 1
					end
				end
				if artType[count] == 2 then
					if features[artVal[count]] == nil then
						temp = 1
					end
				end
				if artType[count] == 3 then
					if droids[artVal[count]] == nil then
						temp = 1
					end
				end
				-- OK to place crate?
				if temp == 1 then
					artID[count] = addFeature(crate, artX[count], artY[count])
					artFlag[count] = 1
				end
			end
			if artFlag[count] == 1 then
				artFlag[count] = 2
			end
			if artFlag[count] == 2 then
				if droidInRange(player, artX[count], artY[count], artRange) then
					artCollected = artCollected + 1
					artFlag[count] = 3
					-- playSound(artSnd2, player);
					playSoundPos(artSnd2, player, artID[count].x, artID[count].y, artID[count].z)
					destroyFeature(artID[count])
					-- removeMessage(artMsg[count], PROX_MSG, player);
					enableResearch(artComp[count], player)
				end
			end
			if artType[count] == 3 then
				if droids[artVal[count]] ~= nil then
					artX[count] = droids[artVal[count]].x
					artY[count] = droids[artVal[count]].y
				end
			end
			count = count + 1
		end
	end
end
repeatingEvent(artLoop, 1.0)


-- Enemy Base Blips
-- update base blips
function baseLoop()
	if basesDead == numBases then
		deactivateEvent(baseLoop)
	else
		count = 0
		while count < numBases do
			if baseFlag[count] == 0 then
				if seenStructInArea(player, enemy[basePlayer[count]], false, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]]) then
					addMessage(baseMsg[count], PROX_MSG, player, false)
					if baseWav1[count] >= 0 then
						playSoundPos(baseSnd[baseWav1[count]], player, (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2, (regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2, 0)
					end
					baseFlag[count] = 1
				end
			end
			if baseFlag[count] == 1 then
				if numStructsButNotWallsInArea(enemy[basePlayer[count]], regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]]) == 0 then
					basesDead = basesDead + 1
					baseFlag[count] = 2
					if baseWav2[count] >= 0 then
						playSoundPos(baseSnd[baseWav2[count]], player, (regionsX1[baseRegion[count]] + regionsX2[baseRegion[count]]) / 2, (regionsY1[baseRegion[count]] + regionsY2[baseRegion[count]]) / 2, 0)
					end
					removeMessage(baseMsg[count], PROX_MSG, player)
					-- remove walls and building features in base
					killStructsInArea(enemy[basePlayer[count]], REF_WALL, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]], true, true)
					-- remove corner walls in base
					killStructsInArea(enemy[basePlayer[count]], REF_WALLCORNER, regionsX1[baseRegion[count]], regionsY1[baseRegion[count]], regionsX2[baseRegion[count]], regionsY2[baseRegion[count]], true, false)
				end
			end
			
			count = count + 1
		end
	end
end
repeatingEvent(baseLoop, 1.7)

-- Events: Win or Lose
-- assumes victory already checked
function nextLevEvnt()
	flushConsoleMessages()
	-- increased to allow all audio before won
	pause(20/10.0)
	-- give all research
	count = 0
	while count < numArt do
		enableResearch(artComp[count], 0)
		count = count + 1
	end
	-- End game or next level
	if lastLev then
		gameOver(true)
	else
		startMission(CAMP_EXPAND, NextLev)
	end
	deactivateEvent(nextLevEvnt)
end

-- skip to end of level
-- cheat button ctrl M
function cheatEvnt()
	repeatingEvent(nextLevEvnt, 1.9)
	deactivateEvent(cheatEvnt)
end
callbackEvent(cheatEvnt, CALL_MISSION_START)

function gameLost()
	gameOverMessage(endMsg, MISS_MSG, 0, false)
	deactivateEvent(gameLost)
end

-- triggered on (every, 25) now, set at end of start event
function lostYetEvnt()
	temp2 = 0
	-- all player stuff dead (ALWAYS LOSE!)
	if (not anyDroidsLeft(player)) and (not anyStructButWallsLeft(player)) then
		temp2 = 1
	end
	
	-- all group index fail[0] at region index fail[1]?
	if (fail[0] ~= -1) and (fail[1] ~= -1) then
		if droids[fail[0]] ~= nil then
			if (droids[fail[0]].x > regionsX1[fail[1]]) and (droids[fail[0]].x < regionsX2[fail[1]]) and (droids[fail[0]].y > regionsY1[fail[1]]) and (droids[fail[0]].y < regionsY2[fail[1]]) then
				playSound(failSnd, player)
				-- text version
				addConsoleText(_("Enemy Escaping"), player)
				temp2 = 1
			end
		end
	end
	
	-- cope with failure set in other scripts
	if linkFail and C.extraFailFlag then
		temp2 = 1
	end
	if temp2 == 1 then
		deactivateEvent(wonYetEvnt)
		deactivateEvent(timeUp)
		-- waits 2 seconds before ending
		repeatingEvent(gameLost, 2.0)
		-- playSound(lostSnd,0);
		deactivateEvent(lostYetEvnt)
	end
end

-- out of time?
function timeUp()
	deactivateEvent(wonYetEvnt)
	deactivateEvent(lostYetEvnt)
	-- may want different sound, eg "Out of Time"
	playSound(lostSnd, 0)
	-- waits 2 seconds before ending
	repeatingEvent(gameLost, 2.0)
	deactivateEvent(timeUp)
end
callbackEvent(timeUp, CALL_MISSION_TIME)

-- triggered on (artCollected >= victoryArt) set at end of start event
function wonYetEvnt()
	if (linkVictory and C.extraVictoryFlag) or (not linkVictory) then
		temp2 = 0
		-- needs to check various victory conditions setup in VLO
		-- check all enemy vehicles and structures destroyed
		if victory[0] ~= -1 then
			count = 0
			temp = 0
			while count < numEnemies do
				if (not anyDroidsLeft(enemy[count])) and (not anyStructButWallsLeft(enemy[count])) then
					temp = temp + 1
				end
				count = count + 1
			end
			if temp == numEnemies then
				temp2 = temp2 + 1
			end
		end
		-- check number of objectives reached
		if victory[2] ~= -1 then
			count = 0
			temp = 0
			-- check from objective 0 to #
			while count < victory[2] do
				if objectiveFlag[count] then
					temp = temp + 1
				end
				count = count + 1
			end
			if temp >= victory[2] then
				temp2 = temp2 + 1
			end
		end
		-- check number of bases destroyed
		if victory[3] ~= -1 then
			count = 0
			temp = 0
			-- check from base 0 to #
			while count < victory[3] do
				if baseFlag[count] == 2 then
					temp = temp + 1
				end
				count = count + 1
			end
			if temp >= victory[3] then
				temp2 = temp2 + 1
			end
		end
		-- check ALL player vehicles in specific REGION (eg LZ)
		if victory[1] ~= -1 then
			temp = 1 + (9 * getDroidCount(player) / 10)
			if temp <= numDroidsInArea(player, regionsX1[victory[1]], regionsY1[victory[1]], regionsX2[victory[1]], regionsY2[victory[1]]) then
				if temp ~= 0 then
					temp2 = temp2 + 1
				end
			else
				-- if getting to region is last victory, give sound and blip
				if (retLZFlag) and (temp2 == numVictory - 1) then
					retLZFlag = false
					-- playSound(retLZSnd, player);	//tell player to return
					-- give LZ blip
					addMessage(retLZBlip, PROX_MSG, player, false)
					-- addConsoleText(_("Return to LZ"), player);
					delayedEvent(periodicRTLZ, 0.0)
				end
			end
		end
		
		-- next check goes here!
		-- now check if number of victory conditions met
		-- victory reached?
		if temp2 == numVictory then
			deactivateEvent(lostYetEvnt)
			deactivateEvent(timeUp)
			repeatingEvent(nextLevEvnt, 1.9)
			deactivateEvent(wonYetEvnt)
		end
	end
end

function periodicRTLZ()
	playSound(retLZSnd, player)
	showConsoleText(_("Return to LZ"), player)
	repeatingEvent(periodicRTLZ, 30.0)
end

-- Enemy AI

function wayGroups()
	count = 0
	while count < numGroups do
		if (grpFlagGo[count]) and (grpType[count] < 2) and (grpPosStart[count] >= 0) then
			if (groupCountMembers(grpGroup[count]) > 0) and ((grpGroup[count].health * groupCountMembers(grpGroup[count]) >= healthRetreat[grpPlayer[count]] + ((groupCountMembers(grpGroup[count]) - 1) * 100)) or (healthRetreat[grpPlayer[count]] == 0)) and (idleGroup(grpGroup[count]) >= groupCountMembers(grpGroup[count]) / 2) then
				grpBusy[count] = false
				-- store for checking difference later
				temp = grpPosCurrent[count]
				-- random choice
				if grpPosType[count] == 3 then
					grpPosCurrent[count] = grpPosMin[count] + grpPosStep[count] * random(grpPosMax[count] - grpPosMin[count])
				else
					grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
				end
				if (grpPosCurrent[count] > grpPosMax[count]) or (grpPosCurrent[count] < grpPosMin[count]) then
					grpPosCurrent[count] = grpPosCurrent[count] - grpPosStep[count]
					-- loop
					if grpPosType[count] == 1 then
						if grpPosStep[count] > 0 then
							grpPosCurrent[count] = grpPosMin[count]
						else
							grpPosCurrent[count] = grpPosMax[count]
						end
					end
					-- ping pong
					if grpPosType[count] == 2 then
						grpPosStep[count] = -grpPosStep[count]
						grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
					end
				end
				-- don't order again if already there!
				if grpPosCurrent[count] ~= temp then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]])
				end
			end
		end
		-- orderGroupLoc(grpGroup[count], DORDER_MOVE, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]]);
		count = count + 1
	end
end
repeatingEvent(wayGroups, 10.7)

-- THREAT ANALYSIS
function threatGroups()
	count = 0
	while count < numGroups do
		if grpMorale[count] > 0 then
			temp1 = getThreatInArea(enemy[grpPlayer[count]], player, grpGroup[count].x - threatRange, grpGroup[count].y - threatRange, grpGroup[count].x + threatRange, grpGroup[count].y + threatRange, threatLight, threatMedium, threatHeavy, true)
			temp2 = getThreatInArea(player, enemy[grpPlayer[count]], grpGroup[count].x - threatRange, grpGroup[count].y - threatRange, grpGroup[count].x + threatRange, grpGroup[count].y + threatRange, threatLight, threatMedium, threatHeavy, false)
			-- does player have bigger looking force than me?
			if temp1 > temp2 then
				initIterateGroup(grpGroup[count])
				testDroid = iterateGroup(grpGroup[count])
				-- must check to see if group not empty!
				if testDroid ~= nil then
					orderDroid(testDroid, DORDER_RUN)
				end
			end
		end
		count = count + 1
	end
end
repeatingEvent(threatGroups, 9.7)
-- traceOff();

-- SCOUTS AND TARGET FINDING
function checkGroups()
	count = 0
	while count < numGroups do
		initIterateGroup(grpGroup[count])
		count2 = 0
		while count2 < groupCountMembers(grpGroup[count]) do
			testDroid = iterateGroup(grpGroup[count])
			if (testDroid.order == DORDER_RUN) and (not runOffFlag) then
				if grpType[count] >= 2 then
					grpPosCurrent[count] = grpRetreatXY[count]
					temp = grpRetreatXY[count]
					-- order scout forces to random position in this sector
					tempX = sectorsX1[temp] + random(sectorsX2[temp] - sectorsX1[temp])
					tempY = sectorsY1[temp] + random(sectorsY2[temp] - sectorsY1[temp])
					orderGroupLoc(grpGroup[count], DORDER_MOVE, tempX, tempY)
				else
					orderGroupLoc(grpGroup[count], DORDER_MOVE, coordsX[grpRetreatXY[count]], coordsY[grpRetreatXY[count]])
				end
				--[[No longer allow groups that STOP at last waypoint to continue once retreated
									if ((grpPosType[count] == 0))	// and (grpPosStart[count] != grpPosCurrent[count]))	//stop and not 1st waypoint
									{
										//need to mark that current waypoint not yet reached for STOP type
										grpPosCurrent[count] = grpPosCurrent[count] - grpPosStep[count];	//back to last one
									}]]--
				
				-- mark busy (will become idle when at retreat point)
				grpBusy[count] = true
				-- exit loop
				count2 = groupCountMembers(grpGroup[count])
			end
			count2 = count2 + 1
		end
		count = count + 1
	end
end
repeatingEvent(checkGroups, 3.5)

-- not finished yet! Now includes attack groups as well as scout groups
function sectorGroups()
	count = 0
	while count < numGroups do
		if (grpFlagGo[count]) and (grpType[count] >= 2) and (groupCountMembers(grpGroup[count]) > 0) and ((grpGroup[count].health * groupCountMembers(grpGroup[count]) >= healthRetreat[grpPlayer[count]] + ((groupCountMembers(grpGroup[count]) - 1) * 100)) or (healthRetreat[grpPlayer[count]] == 0)) and (idleGroup(grpGroup[count]) >= (groupCountMembers(grpGroup[count]) / 2)) then
			grpBusy[count] = false
			-- attack group stuff
			-- just in case don't find an enemy match
			temp1 = 0
			-- and (random(numEnemies + 1) < 1))
			if (allianceFlag) then
				temp1 = random(numEnemies)
			else
				temp1 = grpPlayer[count]
			end
			-- any targets for attack groups
			if (grpType[count] == 3) and (targetCount[temp1] > 0) then
				resetStructTargets()
				if random(100) < 10 then
					setStructTarPref(ST_WALL)
				end
				hitStruc = structTargetInArea(player, grpPlayer[count], grpGroup[count].x - targetRange, grpGroup[count].y - targetRange, grpGroup[count].x + targetRange, grpGroup[count].y + targetRange)
				if hitStruc ~= nil then
					orderGroupObj(grpGroup[count], DORDER_ATTACK, hitStruc)
				else
					temp2 = random(targetCount[temp1])
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, targetX[temp1][temp2], targetY[temp1][temp2])
				end
			else
				temp = grpPosCurrent[count]
				-- 10% chance of scouting past an occupied sector (even if valid targets exist there!)
				-- put in temp1 and temp2 for legibility!
				temp1 = numStructsButNotWallsInArea(player, sectorsX1[temp], sectorsY1[temp], sectorsX2[temp], sectorsY2[temp])
				temp2 = numDroidsInArea(player, sectorsX1[temp], sectorsY1[temp], sectorsX2[temp], sectorsY2[temp])
				-- next sector if clear of droids and structures or 10% chance
				if (random(100) < 10) or ((temp1 == 0) and (temp2 == 0)) then
					if random(100) < 50 then
						grpRetreatXY[count] = grpPosCurrent[count]
					end
					-- get new sector (like wayGroups above!)
					-- random choice
					if grpPosType[count] == 3 then
						grpPosCurrent[count] = grpPosMin[count] + grpPosStep[count] * random(grpPosMax[count] - grpPosMin[count])
					else
						grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
					end
					if (grpPosCurrent[count] > grpPosMax[count]) or (grpPosCurrent[count] < grpPosMin[count]) then
						grpPosCurrent[count] = grpPosCurrent[count] - grpPosStep[count]
						-- loop
						if grpPosType[count] == 1 then
							if grpPosStep[count] > 0 then
								grpPosCurrent[count] = grpPosMin[count]
							else
								grpPosCurrent[count] = grpPosMax[count]
							end
						end
						-- ping pong
						if grpPosType[count] == 2 then
							grpPosStep[count] = -grpPosStep[count]
							grpPosCurrent[count] = grpPosCurrent[count] + grpPosStep[count]
						end
					end
					-- playSound(lostSnd,0);		//test
					-- now order to new sector
					temp = grpPosCurrent[count]
					-- order scout forces to random position in this sector
					tempX = sectorsX1[temp] + random(sectorsX2[temp] - sectorsX1[temp])
					tempY = sectorsY1[temp] + random(sectorsY2[temp] - sectorsY1[temp])
					-- why was this on DORDER_MOVE?
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, tempX, tempY)
				end
			end
		end
		count = count + 1
	end
end
repeatingEvent(sectorGroups, 4.1)

-- not finished yet!
function targetGroups()
	count = 0
	while count < numEnemies do
		if targetCount[count] > 0 then
			temp = 0
			while temp < targetCount[count] do
				resetStructTargets()
				-- include walls always
				setStructTarPref(ST_WALL)
				hitStruc = structTargetInArea(player, grpPlayer[count], targetX[count][temp] - targetRange, targetY[count][temp] - targetRange, targetX[count][temp] + targetRange, targetY[count][temp] + targetRange)
				if hitStruc == nil then
					count2 = temp
					while count2 < targetCount[count] do
						targetX[count][count2] = targetX[count][count2 + 1]
						targetY[count][count2] = targetY[count][count2 + 1]
						count2 = count2 + 1
					end
					-- reduce total for this enemy
					targetCount[count] = targetCount[count] - 1
				end
				temp = temp + 1
			end
		end
		
		-- flag new targets, if any (structures and droids but not walls!), at the moment for any group (not just scouts)
		count2 = 0
		while count2 < numGroups do
			temp1 = numStructsButNotWallsInArea(player, grpGroup[count2].x - targetRange, grpGroup[count2].y - targetRange, grpGroup[count2].x + targetRange, grpGroup[count2].y + targetRange)
			temp2 = numDroidsInArea(player, grpGroup[count2].x - targetRange, grpGroup[count2].y - targetRange, grpGroup[count2].x + targetRange, grpGroup[count2].y + targetRange)
			--[[OLD SYSTEM
						//make sure correct player, and targets exist before logging a new one
						if ((grpPlayer[count2] == count) and (targetCount[count] < targetMax) and ((temp1 > 0) or (temp2 > 0)))
								//(objectInRange(player, grpGroup[count2].x, grpGroup[count2].y, targetRange)))]]--
			-- New System
			-- find a target in area
			resetStructTargets()
			if random(100) < 10 then
				setStructTarPref(ST_WALL)
			end
			hitStruc = structTargetInArea(player, grpPlayer[count2], grpGroup[count2].x - targetRange, grpGroup[count2].y - targetRange, grpGroup[count2].x + targetRange, grpGroup[count2].y + targetRange)
			if (targetCount[count] < targetMax) and (hitStruc ~= nil) then
				targetX[count][targetCount[count]] = grpGroup[count2].x
				targetY[count][targetCount[count]] = grpGroup[count2].y
				-- order group to attack! (should be following heavies)
				-- orderGroupLoc(grpGroup[count2], DORDER_SCOUT, targetX[count][targetCount[count]], targetY[count][targetCount[count]]);
				
				-- if more objects than scouts, run away!!!
				-- if ((grpGroup[count2].members <= temp1 + temp2) and (grpType[count2] == 2))
				
				-- new way of running away (should be checking threat, but not yet)
				temp = numDroidsInArea(enemy[grpPlayer[count2]], grpGroup[count2].x - targetRange, grpGroup[count2].y - targetRange, grpGroup[count2].x + targetRange, grpGroup[count2].y + targetRange)
				if (temp <= temp1 + temp2) and (grpType[count2] == 2) and (grpMorale[count2] > 0) then
					orderGroup(grpGroup[count2], DORDER_RUN)
				else
					-- only if not busy or small chance
					if (grpType[count2] == 2) and ((idleGroup(grpGroup[count2]) >= groupCountMembers(grpGroup[count2]) / 2) or (random(100) < 5)) then
						orderGroupObj(grpGroup[count2], DORDER_ATTACK, hitStruc)
					end
				end
				
				targetCount[count] = targetCount[count] + 1
			end
			count2 = count2 + 1
		end
		count = count + 1
	end
end
repeatingEvent(targetGroups, 4.3)

function factoryProdEvnt()
	count = 0
	while count < numFactories do
		if factFlagGo[count] then
			factTime[count] = factTime[count] + 1
			-- time to do stuff?
			if factTime[count] >= factEvery[count] then
				if factID[count] >= 0 then
					if structures[factID[count]] == nil then
						factFlagGo[count] = false
						-- make next time very large ~100 hours
						factEvery[count] = 32767
					else
						-- not producing anything?
						if structureIdle(structures[factID[count]]) then
							temp = random(factTempMax[count] - factTempMin[count]) + factTempMin[count]
							-- build random number (less for better stuff)
							temp2 = random(factTempMax[count] - temp) + 1
							buildDroid(templates[temp], structures[factID[count]], structures[factID[count]].player, temp2)
							-- reset time count
							factTime[count] = 0
						end
					end
				else
					-- phantom factory (including transports)
					if factID[count] < 0 then
						newDroidFactoryIndex = count
						newDroid = nil
						-- so as not to confuse with a proper factory!
						newDroidFactory = nil
						delayedEvent(droidBuilt, 0.1)
					end
				end
			end
		end
		
		count = count + 1
	end
end
repeatingEvent(factoryProdEvnt, 9.7)

-- triggered by later callbacks
function droidBuilt()
	temp2 = 0
	-- temp = -1;		//in case not found
	-- in case not found (so doesn't use a droidfactory from another script)
	temp = -2
	if newDroidFactory ~= nil then
		newDroidFactoryIndex = -1
		count = 0
		while count < numFactories do
			if factID[count] >= 0 then
				if newDroidFactory == structures[factID[count]] then
					temp = count
				end
			end
			count = count + 1
		end
	else
		-- deal with phantom factory
		if newDroidFactoryIndex >= 0 then
			temp = newDroidFactoryIndex
		end
	end
	-- check thru groups to reinforce
	count = 0
	
	-- cope with trucks being built
	-- don't bother if phantom factory
	if newDroid ~= nil then
		if newDroid.droidType == DROID_CONSTRUCT then
			count2 = 0
			while count2 < numEnemies do
				if newDroid.player == enemy[count2] then
					groupAddDroid(truckGroup[count2], newDroid)
				end
				count2 = count2 + 1
			end
			-- skip next bit!
			count = numGroups
		else
			-- cope with sensors being built and IDF groups existing
			if newDroid.droidType == DROID_SENSOR then
				count2 = 0
				while count2 < numGroups do
					if grpType[count2] == -1 then
						if droids[count2] == nil then
							droids[count2] = newDroid
							orderGroupObj(grpGroup[count2], DORDER_FIRESUPPORT, droids[count2])
							-- end search
							count2 = numGroups
						end
					end
					count2 = count2 + 1
				end
			end
		end
	end
	-- count = numGroups;	//Don't skip next bit! (needs to go into a group, unlike Trucks!)
	-- end of trucks bit
	
	while count < numGroups do
		if ((temp == grpFactory[count]) or ((grpFactory[count] == -1) and (temp ~= -2))) and (groupCountMembers(grpGroup[count]) < grpIdealSize[count]) then
			if newDroid ~= nil then
				groupAddDroid(grpReinforce[count], newDroid)
			else
				-- deal with phantom factory
				if newDroidFactoryIndex >= 0 then
					if factID[newDroidFactoryIndex] == -1 then
						factTime[newDroidFactoryIndex] = 0
						count2 = 0
						while count2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
							temp1 = factTempMin[newDroidFactoryIndex] + count2
							-- create more for lower template numbers, less for higher!
							temp2 = count2
							while temp2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
								newDroid = addDroid(templates[temp1], coordsX[factAssXY[newDroidFactoryIndex]], coordsY[factAssXY[newDroidFactoryIndex]], enemy[grpPlayer[count]])
								if newDroid ~= nil then
									if newDroid.droidType == DROID_CONSTRUCT then
										groupAddDroid(truckGroup[grpPlayer[count]], newDroid)
									else
										-- cope with sensors
										if newDroid.droidType == DROID_SENSOR then
											count3 = 0
											while count3 < numGroups do
												if grpType[count3] == -1 then
													if droids[count3] == nil then
														droids[count3] = newDroid
														orderGroupObj(grpGroup[count3], DORDER_FIRESUPPORT, droids[count3])
														-- end search
														count3 = numGroups
													end
												end
												count3 = count3 + 1
											end
											groupAddDroid(grpReinforce[count], newDroid)
										else
											groupAddDroid(grpReinforce[count], newDroid)
										end
									end
								end
								temp2 = temp2 + 1
							end
							count2 = count2 + 1
						end
					else
						-- deal with transport if not on map
						if (factID[newDroidFactoryIndex] == -2) and (not transOnMap[grpPlayer[count]]) then
							factTime[newDroidFactoryIndex] = 0
							-- need to check LZ has defences, otherwise turn off this phantom factory
							temp1 = factAssXY[newDroidFactoryIndex]
							if numStructsInArea(enemy[grpPlayer[count]], (LZX[temp1] - 4) * 128, (LZY[temp1] - 4) * 128, (LZX[temp1] + 4) * 128, (LZY[temp1] + 4) * 128) == 0 then
								factFlagGo[newDroidFactoryIndex] = false
								-- make next time very large ~100 hours
								factEvery[newDroidFactoryIndex] = 32767
							else
								setNoGoArea(LZX[factAssXY[newDroidFactoryIndex]] - 1, LZY[factAssXY[newDroidFactoryIndex]] - 1, LZX[factAssXY[newDroidFactoryIndex]] + 1, LZY[factAssXY[newDroidFactoryIndex]] + 1, enemy[grpPlayer[newDroidFactoryIndex]])
								-- make sure got position in world coords of this LZ for playSound
								enemyLZX = LZX[factAssXY[newDroidFactoryIndex]] * 128
								enemyLZY = LZY[factAssXY[newDroidFactoryIndex]] * 128
								count2 = 0
								while count2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
									temp1 = factTempMin[newDroidFactoryIndex] + count2
									-- create more for lower template numbers, less for higher!
									temp2 = count2
									while temp2 < 1 + factTempMax[newDroidFactoryIndex] - factTempMin[newDroidFactoryIndex] do
										newDroid = addDroidToMissionList(templates[temp1], enemy[grpPlayer[count]])
										if newDroid ~= nil and transportDroid[grpPlayer[count]] ~= nil then
											addDroidToTransporter(transportDroid[grpPlayer[count]], newDroid)
										end
										temp2 = temp2 + 1
									end
									count2 = count2 + 1
								end
								-- call in transport
								setTransporterExit(enemy[grpPlayer[count]], exitX[grpPlayer[count]], exitY[grpPlayer[count]])
								flyTransporterIn(enemy[grpPlayer[count]], entryX[grpPlayer[count]], entryY[grpPlayer[count]], false)
								transOnMap[grpPlayer[count]] = true
								-- store for when transport lands
								transGroupIndex[grpPlayer[count]] = count
								-- may mess up multiple enemies having transports?
								transGroupPlayer = grpPlayer[count]
								callbackEvent(transLanded, CALL_TRANSPORTER_LANDED)
								callbackEvent(transGone1, CALL_TRANSPORTER_OFFMAP)
							end
						end
					end
				end
			end
			-- if group dead, add to group and reset starting sector?
			if groupCountMembers(grpGroup[count]) == 0 then
				groupAddGroup(grpGroup[count], grpReinforce[count])
				-- set back to start sector...?
				-- go back to min sector if starting group from scratch
				grpPosCurrent[count] = grpPosMin[count]
				
				-- NEW to handle zero size groups at start with morale settings
				-- set morale again so recalculates size!
				if grpMorale[count] >= 0 then
					setGroupRetreatForce(grpGroup[count], grpMorale[count])
				end
			else
				-- END of NEW
				
				-- if ideal size, add to main group!
				if ((groupCountMembers(grpGroup[count]) + groupCountMembers(grpReinforce[count])) >= grpIdealSize[count]) or ((groupCountMembers(grpReinforce[count])) >= 8) then
					groupAddGroup(grpGroup[count], grpReinforce[count])
				end
			end
			-- grpPosCurrent[count] = grpPosMin[count];		//test for now so can see if added to group
			-- test order only!!!
			-- orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosCurrent[count]], coordsY[grpPosCurrent[count]]);
			-- exit early
			count = numGroups
			temp2 = 1
		end
		count = count + 1
	end
end
-- if temp2 != 0, ie not assigned to a group, put in a special group for that player, and pull out if a group can take from any and
-- needs reinforcing. (another event to check thru pooled group?)
-- still to be done!


-- hack to allow CALL_NEWDROID to work with unspecified enemy players!!!!
function droidBuilt1(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 1 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt1, CALL_NEWDROID)

function droidBuilt2(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 2 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt2, CALL_NEWDROID)

function droidBuilt3(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 3 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt3, CALL_NEWDROID)

function droidBuilt4(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 4 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt4, CALL_NEWDROID)

function droidBuilt5(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 5 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt5, CALL_NEWDROID)

function droidBuilt6(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 6 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt6, CALL_NEWDROID)

function droidBuilt7(_newDroid, _newDroidFactory)
	if _newDroid.player ~= 7 then return end
	newDroid, newDroidFactory = _newDroid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	newDroidFactoryIndex = -1
	delayedEvent(droidBuilt, 0.1)
end
callbackEvent(droidBuilt7, CALL_NEWDROID)

-- trigger set when transport called
function transLanded(_transGroup, _player)
	if _player ~= enemy[transGroupPlayer] then return end
	temp = transGroupIndex[transGroupPlayer]
	-- test sound for now
	-- playSound(transSnd, player);		//Enemy Transport Landing
	-- need to look at enemy LZ???
	playSoundPos(transSnd, player, enemyLZX, enemyLZY, 0)
	
	-- check for trucks in transGroup
	initIterateGroup(transGroup)
	newDroid = iterateGroup(transGroup)
	while newDroid ~= nil do
		if newDroid.droidType == DROID_CONSTRUCT then
			groupAddDroid(truckGroup[transGroupPlayer], newDroid)
		else
			-- check for sensors as well
			if newDroid.droidType == DROID_SENSOR then
				count2 = 0
				while count2 < numGroups do
					if grpType[count2] == -1 then
						if droids[count2] == nil then
							droids[count2] = newDroid
							orderGroupObj(grpGroup[count2], DORDER_FIRESUPPORT, droids[count2])
							-- end search
							count2 = numGroups
						end
					end
					count2 = count2 + 1
				end
			end
		end
		-- point to next one
		newDroid = iterateGroup(transGroup)
	end
	-- end of truck/sensor check
	
	groupAddGroup(grpReinforce[temp], transGroup)
	-- might just want to add directly to grpGroup?
	-- if group dead, add to group and reset starting sector?
	if groupCountMembers(grpGroup[temp]) == 0 then
		grpPosCurrent[temp] = grpPosMin[temp]
		-- give first orders unless scouts, since use sectors, or no waypoints defined
		if (grpType[temp] < 2) and (grpPosStart[temp] >= 0) then
			orderGroupLoc(grpReinforce[temp], DORDER_SCOUT, coordsX[grpPosCurrent[temp]], coordsY[grpPosCurrent[temp]])
		end
		groupAddGroup(grpGroup[temp], grpReinforce[temp])
		-- set back to start sector...?
		
		-- NEW to handle zero size groups at start with morale settings
		-- set morale again so recalculates size!
		if grpMorale[temp] >= 0 then
			setGroupRetreatForce(grpGroup[temp], grpMorale[temp])
		end
	end
	-- END of NEW
	
	-- if >= ideal size add to group
	if (groupCountMembers(grpGroup[temp]) + groupCountMembers(grpReinforce[temp])) >= grpIdealSize[temp] then
		if (grpType[temp] < 2) and (grpPosStart[temp] >= 0) then
			orderGroupLoc(grpReinforce[temp], DORDER_SCOUT, coordsX[grpPosCurrent[temp]], coordsY[grpPosCurrent[temp]])
		end
		groupAddGroup(grpGroup[temp], grpReinforce[temp])
	end
	callbackEvent(transLanded, CALL_TRANSPORTER_LANDED)
end

-- allow next transport!!
function transGone1(_player)
	if _player ~= enemy[transGroupPlayer] then return end
	transOnMap[grpPlayer[transGroupPlayer]] = false
end

function regionGroupsEvnt()
	count = 0
	while count < numGroups do
		if (not grpFlagGo[count]) and (grpType[count] ~= 1) and (grpRegionGo[count] >= 0) then
			if droidInArea(grpWhoGo[count], regionsX1[grpRegionGo[count]], regionsY1[grpRegionGo[count]], regionsX2[grpRegionGo[count]], regionsY2[grpRegionGo[count]]) then
				grpFlagGo[count] = true
				-- scouts and attack forces don't use coords array, so don't bother with initial order!
				if grpType[count] < 2 then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
				end
			end
		end
		count = count + 1
	end
	-- check for factories
	count = 0
	while count < numFactories do
		if (not factFlagGo[count]) and (factRegionGo[count] >= 0) and (factTime[count] == 0) then
			if droidInArea(player, regionsX1[factRegionGo[count]], regionsY1[factRegionGo[count]], regionsX2[factRegionGo[count]], regionsY2[factRegionGo[count]]) then
				factFlagGo[count] = true
				-- allow to produce straight away!
				factTime[count] = factEvery[count]
			end
		end
		count = count + 1
	end
end
repeatingEvent(regionGroupsEvnt, 1.1)

-- update time count for triggering groups and factories...
function timeGroupsEvnt()
	timeGroup = timeGroup + 1
	count = 0
	-- update groups
	while count < numGroups do
		if (grpTimeGo[count] == timeGroup) and (not grpFlagGo[count]) then
			grpFlagGo[count] = true
			-- scouts don't use coords array, so don't bother with initial order!
			if grpType[count] < 2 then
				orderGroupLoc(grpGroup[count], DORDER_SCOUT, coordsX[grpPosStart[count]], coordsY[grpPosStart[count]])
			end
		end
		count = count + 1
	end
	-- update factories
	count = 0
	while count < numFactories do
		if (factTimeGo[count] == timeGroup) and (not factFlagGo[count]) and (factTime[count] == 0) then
			factFlagGo[count] = true
			-- allow to produce straight away!
			factTime[count] = factEvery[count]
		end
		count = count + 1
	end
end
repeatingEvent(timeGroupsEvnt, 10.0)

function enemyBaseHit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= enemy[enemyCount] then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if (attackerObj ~= nil) and (hitStruc ~= nil) then
		count = 0
		while count < numGroups do
			if (grpType[count] == 1) and (grpPlayer[count] == enemyCount) and (not grpBusy[count]) then
				if grpRegionGo[count] < 0 then
					orderGroupLoc(grpGroup[count], DORDER_SCOUT, attackerObj.x, attackerObj.y)
					grpBusy[count] = true
					-- break out of loop, since found
					count = numGroups
				else
					if (hitStruc.x >= regionsX1[grpRegionGo[count]]) and (hitStruc.x <= regionsX2[grpRegionGo[count]]) and (hitStruc.y >= regionsY1[grpRegionGo[count]]) and (hitStruc.y <= regionsY2[grpRegionGo[count]]) then
						orderGroupLoc(grpGroup[count], DORDER_SCOUT, attackerObj.x, attackerObj.y)
						grpBusy[count] = true
						-- break out of loop, since found
						count = numGroups
					end
				end
			end
			count = count + 1
		end
	end
end
callbackEvent(enemyBaseHit, CALL_STRUCT_ATTACKED)


-- Updates enemyCount for enemyBaseHit event.
function updateEnemy()
	if enemyCount < numEnemies - 1 then
		enemyCount = enemyCount + 1
	else
		enemyCount = 0
	end
end
repeatingEvent(updateEnemy, 2.1)

-- NEW
-- Make specified trucks (defined as droids[]) build derricks on visible oil resources
-- only used if trucks found!
function buildDerrick()
	count = 0
	while count < numEnemies do
		feature = getFeature(enemy[count])
		if feature ~= nil then
			initIterateGroup(truckGroup[count])
			testDroid = iterateGroup(truckGroup[count])
			while testDroid ~= nil do
				if (testDroid.order == DORDER_NONE) or (testDroid.order == DORDER_RTB) then
					tempX = feature.x
					tempY = feature.y
					-- build a derick
					orderDroidStatsLoc(testDroid, DORDER_BUILD, strucStat[1], tempX, tempY)
					testDroid = nil
				else
					testDroid = iterateGroup(truckGroup[count])
				end
			end
		else
			initGetFeature(oilRes, enemy[count], enemy[count])
		end
		count = count + 1
	end
end

-- build defences around nearby defenceless structures
-- only used if trucks found!
function buildDefences()
	count = 0
	while count < numEnemies do
		initIterateGroup(truckGroup[count])
		testDroid = iterateGroup(truckGroup[count])
		-- NB: need to be careful don't end up in endless loop!
		while testDroid ~= nil do
			if (testDroid.order == DORDER_NONE) or (testDroid.order == DORDER_RTB) then
				count2 = 0
				-- list of structurestats to defend
				while count2 < numToDefend do
					hitStruc = structureBuiltInRange(toDefend[count2], testDroid.x, testDroid.y, truckRange, enemy[count])
					if hitStruc ~= nil then
						if (numStructsByTypeInArea(enemy[count], REF_DEFENSE, hitStruc.x - defRange, hitStruc.y - defRange, hitStruc.x + defRange, hitStruc.y + defRange) < maxDefence) and (numDefences > 0) then
							tempX = hitStruc.x
							tempY = hitStruc.y
							temp = random(numDefences)
							boolResult, tempX, tempY = pickStructLocation(defences[temp], tempX, tempY, enemy[count])
							if boolResult then
								orderDroidStatsLoc(testDroid, DORDER_BUILD, defences[temp], tempX, tempY)
								testDroid = nil
								-- break loops early
								count2 = numToDefend
							end
						end
					end
					count2 = count2 + 1
				end
				
				-- go back to base if couldn't build
				if (testDroid ~= nil) and (random(100) < 50) then
					orderDroid(testDroid, DORDER_RTB)
				end
			end
			-- get next if haven't broken out of loop
			if testDroid ~= nil then
				testDroid = iterateGroup(truckGroup[count])
			end
		end
		count = count + 1
	end
end

-- can be whatever time necessary now!
function checkTrucks()
	if not truckFlag then
		count = 0
		while count < numEnemies do
			if groupCountMembers(truckGroup[count]) > 0 then
				truckFlag = true
			end
			count = count + 1
		end
		if truckFlag then
			repeatingEvent(buildDerrick, 20.0)
			repeatingEvent(buildDefences, 20.5)
		end
	else
		count = 0
		temp = 0
		while count < numEnemies do
			if groupCountMembers(truckGroup[count]) == 0 then
				temp = temp + 1
			end
			count = count + 1
		end
		if temp == numEnemies then
			truckFlag = false
			deactivateEvent(buildDerrick)
			deactivateEvent(buildDefences)
		end
	end
end

-- Better way of doing this (will attack allsorts of things!
function sensorTarget()
	count = 0
	while droids[count] ~= nil do
		if droids[count].droidType == DROID_SENSOR then
			if (droids[count].order == DORDER_NONE) or (droids[count].order == DORDER_SCOUT) then
				resetStructTargets()
				if random(100) < 10 then
					setStructTarPref(ST_WALL)
				end
				hitStruc = structTargetInArea(player, droids[count].player, droids[count].x - 768, droids[count].y - 768, droids[count].x + 768, droids[count].y + 768)
				if hitStruc ~= nil then
					orderDroidObj(droids[count], DORDER_OBSERVE, hitStruc)
				end
			end
		end
		count = count + 1
	end
end
repeatingEvent(sensorTarget, 6.7)


-- LZ compromised stuff
function LZNoGo()
	temp = 0
	-- check for compromised
	count = 0
	while count < numEnemies do
		if droidInRange(enemy[count], (LZX[player] * 128), (LZY[player] * 128), LZRange) then
			temp = temp + 1
		end
		count = count + 1
	end
	-- make sure transport not already landing!
	if (not playerTransOnMap) and (temp > 0) then
		playSoundPos(LZComp, player, LZX[player] * 128, LZY[player] * 128, 0)
		-- disable transport landing
		-- MAGIC NUMBER IN HERE!!!
		setReinforcementTime(LZ_COMPROMISED_TIME/10.0)
		-- allow check for clear!
		repeatingEvent(LZ_OK, 3.5)
		deactivateEvent(LZNoGo)
	end
end
repeatingEvent(LZNoGo, 3.5)

function LZ_OK()
	temp = 0
	-- check LZ area clear of enemy structures and/or vehicles (not in Trigger)
	count = 0
	while count < numEnemies do
		if droidInRange(enemy[count], (LZX[player] * 128), (LZY[player] * 128), LZRange) then
			temp = temp + 1
		end
		count = count + 1
	end
	-- clear so do message
	if temp == 0 then
		playSoundPos(LZClear, player, LZX[player] * 128, LZY[player] * 128, 0)
		-- allow reinforcements now LZ clear
		-- (set back to normal)
		setReinforcementTime(ReinforceTime/10.0)
		repeatingEvent(LZNoGo, 3.5)
		deactivateEvent(LZ_OK)
	end
end

function playerTransOn()
	playerTransOnMap = true
end
callbackEvent(playerTransOn, CALL_TRANSPORTER_REINFORCE)

function playerTransOff(_player)
	if _player ~= player then return end
	playerTransOnMap = false
end
callbackEvent(playerTransOff, CALL_TRANSPORTER_OFFMAP)


---------- stubs ----------

if anyStructButWallsLeft == nil then anyStructButWallsLeft = function() print("stub: anyStructButWallsLeft"); return 0 end end
if orderDroidStatsLoc == nil then orderDroidStatsLoc = function() print("stub: orderDroidStatsLoc"); return 0 end end
if gameOverMessage == nil then gameOverMessage = function() print("stub: gameOverMessage"); return 0 end end
if setStructureLimits == nil then setStructureLimits = function() print("stub: setStructureLimits"); return 0 end end
if initGetFeature == nil then initGetFeature = function() print("stub: initGetFeature"); return 0 end end
if random == nil then random = function() print("stub: random"); return 0 end end
if enableResearch == nil then enableResearch = function() print("stub: enableResearch"); return 0 end end
if orderGroupObj == nil then orderGroupObj = function() print("stub: orderGroupObj"); return 0 end end
if resetStructTargets == nil then resetStructTargets = function() print("stub: resetStructTargets"); return 0 end end
if setStructTarPref == nil then setStructTarPref = function() print("stub: setStructTarPref"); return 0 end end
if numStructsButNotWallsInArea == nil then numStructsButNotWallsInArea = function() print("stub: numStructsButNotWallsInArea"); return 0 end end
if setMissionTime == nil then setMissionTime = function() print("stub: setMissionTime"); return 0 end end
if addFeature == nil then addFeature = function() print("stub: addFeature"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if pickStructLocation == nil then pickStructLocation = function() print("stub: pickStructLocation"); return 0 end end
if addDroidToTransporter == nil then addDroidToTransporter = function() print("stub: addDroidToTransporter"); return 0 end end
if setRetreatPoint == nil then setRetreatPoint = function() print("stub: setRetreatPoint"); return 0 end end
if orderGroupLoc == nil then orderGroupLoc = function() print("stub: orderGroupLoc"); return 0 end end
if anyDroidsLeft == nil then anyDroidsLeft = function() print("stub: anyDroidsLeft"); return 0 end end
if droidInRange == nil then droidInRange = function() print("stub: droidInRange"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if getFeature == nil then getFeature = function() print("stub: getFeature"); return 0 end end
if initIterateGroup == nil then initIterateGroup = function() print("stub: initIterateGroup"); return 0 end end
if removeMessage == nil then removeMessage = function() print("stub: removeMessage"); return 0 end end
if buildDroid == nil then buildDroid = function() print("stub: buildDroid"); return 0 end end
if destroyFeature == nil then destroyFeature = function() print("stub: destroyFeature"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if setRetreatHealth == nil then setRetreatHealth = function() print("stub: setRetreatHealth"); return 0 end end
if setGroupRetreatPoint == nil then setGroupRetreatPoint = function() print("stub: setGroupRetreatPoint"); return 0 end end
if getDroidCount == nil then getDroidCount = function() print("stub: getDroidCount"); return 0 end end
if orderGroup == nil then orderGroup = function() print("stub: orderGroup"); return 0 end end
if setReinforcementTime == nil then setReinforcementTime = function() print("stub: setReinforcementTime"); return 0 end end
if initAllNoGoAreas == nil then initAllNoGoAreas = function() print("stub: initAllNoGoAreas"); return 0 end end
if setPowerLevel == nil then setPowerLevel = function() print("stub: setPowerLevel"); return 0 end end
if addDroid == nil then addDroid = function() print("stub: addDroid"); return 0 end end
if droidInArea == nil then droidInArea = function() print("stub: droidInArea"); return 0 end end
if groupAddArea == nil then groupAddArea = function() print("stub: groupAddArea"); return 0 end end
if setGroupRetreatForce == nil then setGroupRetreatForce = function() print("stub: setGroupRetreatForce"); return 0 end end
if showConsoleText == nil then showConsoleText = function() print("stub: showConsoleText"); return 0 end end
if playSoundPos == nil then playSoundPos = function() print("stub: playSoundPos"); return 0 end end
if orderDroid == nil then orderDroid = function() print("stub: orderDroid"); return 0 end end
if numStructsByTypeInArea == nil then numStructsByTypeInArea = function() print("stub: numStructsByTypeInArea"); return 0 end end
if numStructsInArea == nil then numStructsInArea = function() print("stub: numStructsInArea"); return 0 end end
if killStructsInArea == nil then killStructsInArea = function() print("stub: killStructsInArea"); return 0 end end
if completeResearch == nil then completeResearch = function() print("stub: completeResearch"); return 0 end end
if numDroidsInArea == nil then numDroidsInArea = function() print("stub: numDroidsInArea"); return 0 end end
if startMission == nil then startMission = function() print("stub: startMission"); return 0 end end
if getThreatInArea == nil then getThreatInArea = function() print("stub: getThreatInArea"); return 0 end end
if pause == nil then pause = function() print("stub: pause"); return 0 end end
if structureBuiltInRange == nil then structureBuiltInRange = function() print("stub: structureBuiltInRange"); return 0 end end
if setNoGoArea == nil then setNoGoArea = function() print("stub: setNoGoArea"); return 0 end end
if setTransporterExit == nil then setTransporterExit = function() print("stub: setTransporterExit"); return 0 end end
if createAlliance == nil then createAlliance = function() print("stub: createAlliance"); return 0 end end
if playSound == nil then playSound = function() print("stub: playSound"); return 0 end end
if addConsoleText == nil then addConsoleText = function() print("stub: addConsoleText"); return 0 end end
if _ == nil then _ = function() print("stub: _"); return 0 end end
if flyTransporterIn == nil then flyTransporterIn = function() print("stub: flyTransporterIn"); return 0 end end
if seenStructInArea == nil then seenStructInArea = function() print("stub: seenStructInArea"); return 0 end end
if groupAddGroup == nil then groupAddGroup = function() print("stub: groupAddGroup"); return 0 end end
if addMessage == nil then addMessage = function() print("stub: addMessage"); return 0 end end
if iterateGroup == nil then iterateGroup = function() print("stub: iterateGroup"); return 0 end end
if structTargetInArea == nil then structTargetInArea = function() print("stub: structTargetInArea"); return 0 end end
if setRadarZoom == nil then setRadarZoom = function() print("stub: setRadarZoom"); return 0 end end
if playVideo == nil then playVideo = function() print("stub: playVideo"); return 0 end end
if structureIdle == nil then structureIdle = function() print("stub: structureIdle"); return 0 end end
if addDroidToMissionList == nil then addDroidToMissionList = function() print("stub: addDroidToMissionList"); return 0 end end
if enableStructure == nil then enableStructure = function() print("stub: enableStructure"); return 0 end end
if orderDroidObj == nil then orderDroidObj = function() print("stub: orderDroidObj"); return 0 end end
if setAssemblyPoint == nil then setAssemblyPoint = function() print("stub: setAssemblyPoint"); return 0 end end
if flushConsoleMessages == nil then flushConsoleMessages = function() print("stub: flushConsoleMessages"); return 0 end end
if gameOver == nil then gameOver = function() print("stub: gameOver"); return 0 end end
if centreViewPos == nil then centreViewPos = function() print("stub: centreViewPos"); return 0 end end
if setGroupRetreatLeadership == nil then setGroupRetreatLeadership = function() print("stub: setGroupRetreatLeadership"); return 0 end end
