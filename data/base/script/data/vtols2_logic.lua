-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for
prefDroid = Array(4)
VTOLgroup = Array(4)
attackObj = Array(4)
attackCluster = Array(4)
countTime = Array(4)
count = 0
group = 0
temp = 0
viewerObj = nil
targetObj = nil
targetObj2 = nil
droid = nil
clusterID = 0
newDroidFactory = nil

-- which player is the human player
player = 0

-- whether to use the no visibility target system
noVisTargetting = false


-- declare events

function start()
	count = 0
	while count < numGroups do
		groupAddArea(VTOLgroup[count], padPlayer, groupX1[count], groupY1[count], groupX2[count], groupY2[count])
		count = count + 1
	end
	
	-- set the target system preferences
	resetStructTargets()
	-- ignore walls
	setStructTarIgnore(ST_WALL)
	count = 0
	while count < numPrefStruc do
		setStructTarPref(prefStruc[count])
		count = count + 1
	end
	resetDroidTargets()
	-- ignore transport
	setDroidTarIgnore(DT_SUPER_HEAVY)
	count = 0
	while count < numPrefDroid do
		setDroidTarPref(prefDroid[count])
		count = count + 1
	end
	
	count = 0
	while count < numGroups do
		countTime[count] = startTime[count]
		count = count + 1
	end
	
	-- turn off the visibility targetting system
	if noVisTargetting then
		deactivateEvent(targetFound)
		deactivateEvent(clusterReset)
		deactivateEvent(nextTarget)
		deactivateEvent(resetVis)
		
		-- turn on the no visibility system
		repeatingEvent(nextTargetNoVis, 8.0)
	end
end
callbackEvent(start, CALL_GAMEINIT)

-- do VTOL reinforcements (startTime, everyTime)
-- every 10secs
function addVTOL()
	group = 0
	while group < numGroups do
		countTime[group] = countTime[group] - 1
		if (countTime[group] <= 0) and (groupFactory[group] ~= nil) then
			countTime[group] = everyTime[group]
			
			temp = groupCountMembers(VTOLgroup[group])
			if (temp < VTOLsize[group]) and (structureIdle(groupFactory[group])) then
				buildDroid(templates[group], groupFactory[group], padPlayer, 1)
			end
		end
		group = group + 1
	end
end
repeatingEvent(addVTOL, 10.7)

-- add droid to correct group
function droidBuilt(_droid, _newDroidFactory)
	if _droid.player ~= padPlayer then return end
	droid, newDroidFactory = _droid, _newDroidFactory -- wz2lua: probably these can be used as function arguments directly
	group = 0
	while group < numGroups do
		if newDroidFactory == groupFactory[group] then
			groupAddDroid(VTOLgroup[group], droid)
			if attackObj[group] ~= nil then
				orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
			end
		end
		group = group + 1
	end
end
callbackEvent(droidBuilt, CALL_NEWDROID)

-- set up a target for the vtol groups
function targetFound(_targetObj, _viewerObj)
	if _viewerObj.player ~= padPlayer then return end
	targetObj, viewerObj = _targetObj, _viewerObj -- wz2lua: probably these can be used as function arguments directly
	if targetObj ~= nil then
		group = 0
		if targetObj.type == OBJ_DROID then
			if objToDroid(targetObj).droidType == DROID_TRANSPORTER then
				group = numGroups
			end
		end
		while group < numGroups do
			if targetObj.type == targetObjType[group] then
				if (attackObj[group] == nil) and (attackCluster[group] == 0) then
					attackCluster[group] = targetObj.clusterID
					-- clusterID can be 0 for droids - especially near start
					-- when they havn't moved yet
					if attackCluster[group] ~= 0 then
						targetObj2 = targetInCluster(targetObj.clusterID, padPlayer)
					else
						targetObj2 = nil
					end
					
					-- if we've found a target, store it
					if targetObj2 ~= nil then
						attackObj[group] = targetObj2
						attackCluster[group] = targetObj2.clusterID
					end
				end
			end
			
			group = group + 1
		end
	end
end
callbackEvent(targetFound, CALL_OBJ_SEEN)

-- remove a cluster from the system if there isn't anything in it
function clusterReset(_clusterID)
	clusterID = _clusterID -- wz2lua: probably these can be used as function arguments directly
	group = 0
	while group < numGroups do
		if attackCluster[group] == clusterID then
			attackObj[group] = nil
			attackCluster[group] = 0
			group = numGroups
		end
		group = group + 1
	end
end
callbackEvent(clusterReset, CALL_CLUSTER_EMPTY)

-- Newer System! Iterates clusters and keeps 5 targets!
function nextTarget()
	group = 0
	while group < numGroups do
		if (attackObj[group] == nil) and (attackCluster[group] ~= 0) then
			attackObj[group] = targetInCluster(attackCluster[group], padPlayer)
			if attackObj[group] == nil then
				attackCluster[group] = 0
			end
		end
		
		-- order VTOL group to target (if it exists and not already busy)
		if (attackObj[group] ~= nil) and (idleGroup(VTOLgroup[group]) > (groupCountMembers(VTOLgroup[group]) / 2)) then
			orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
		end
		
		group = group + 1
	end
end
repeatingEvent(nextTarget, 8.0)

-- give targets to vtols without using visibility
function nextTargetNoVis()
	group = 0
	while group < numGroups do
		if targetObjType[group] == OBJ_DROID then
			attackObj[group] = droidTargetOnMap(player, -1)
		else
			attackObj[group] = structTargetOnMap(player, -1)
		end
		
		-- order VTOL group to target (if not already busy)
		if (attackObj[group] ~= nil) and (idleGroup(VTOLgroup[group]) > (groupCountMembers(VTOLgroup[group]) / 2)) then
			debugBox(3)
			debugBox(attackObj[group].id)
			orderGroupObj(VTOLgroup[group], DORDER_ATTACK, attackObj[group])
		end
		
		group = group + 1
	end
end

-- reset player visibility if no targets
function resetVis()
	temp = -1
	count = 0
	while count < numGroups do
		if (attackObj[count] == nil) and (attackCluster[count] == 0) then
			temp = count
			count = numGroups
		end
		count = count + 1
	end
	
	if temp ~= -1 then
		resetPlayerVisibility(padPlayer)
	end
end
repeatingEvent(resetVis, 33.3)


---------- stubs ----------

if debugBox == nil then debugBox = function() print("stub: debugBox"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if setDroidTarIgnore == nil then setDroidTarIgnore = function() print("stub: setDroidTarIgnore"); return 0 end end
if objToDroid == nil then objToDroid = function() print("stub: objToDroid"); return 0 end end
if structTargetOnMap == nil then structTargetOnMap = function() print("stub: structTargetOnMap"); return 0 end end
if targetInCluster == nil then targetInCluster = function() print("stub: targetInCluster"); return 0 end end
if structureIdle == nil then structureIdle = function() print("stub: structureIdle"); return 0 end end
if orderGroupObj == nil then orderGroupObj = function() print("stub: orderGroupObj"); return 0 end end
if resetStructTargets == nil then resetStructTargets = function() print("stub: resetStructTargets"); return 0 end end
if setStructTarPref == nil then setStructTarPref = function() print("stub: setStructTarPref"); return 0 end end
if resetDroidTargets == nil then resetDroidTargets = function() print("stub: resetDroidTargets"); return 0 end end
if setStructTarIgnore == nil then setStructTarIgnore = function() print("stub: setStructTarIgnore"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if droidTargetOnMap == nil then droidTargetOnMap = function() print("stub: droidTargetOnMap"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if setDroidTarPref == nil then setDroidTarPref = function() print("stub: setDroidTarPref"); return 0 end end
if buildDroid == nil then buildDroid = function() print("stub: buildDroid"); return 0 end end
if groupAddArea == nil then groupAddArea = function() print("stub: groupAddArea"); return 0 end end
if resetPlayerVisibility == nil then resetPlayerVisibility = function() print("stub: resetPlayerVisibility"); return 0 end end
