-- Generated by wz2lua (implementation file)
version(0) --- version of the script API this script is written for
numart = 0

-- structure limit stuff
-- public	STRUCTURESTAT		powerModuleHack;

-- Briefing stuff
-- , winMsg;

-- required for enemy transports landing
transportDroid = nil
loadDroid = nil
transOnMap = false

-- Win or lose

-- public		INTMESSAGE		obj1;

-- Base Under Attack Stuff
hitStruc = nil
attackerObj = nil
t = 0

-- player Bonus Research topics given at end of mission
-- need to be declared with value >= numResP0, numResP1, etc.
count = 0

-- Reinforcement Lists for New Paradigm
reinforceType = 0
reinforceCount = 0
sortieTot = 0
sortieCount = 0
temp1 = 0
LZ = 0
LZMess = 0
numTries = 0
reinforceTemplate = nil
-- needs to be (numLZ * numTargets) for array
transTemp = Group()
NPgroup = Array(15)
newDroid = nil

-- ground troops reinforcement lists
n1 = 0
n2 = 0
m1 = 0
m2 = 0
reinfGroup = Array(2)

-- templates
-- Enemy Tactics

-- Map Targets/Waypoints for New Paradigm
-- need (numLZ * numTargets) for array
-- for checking near target
n = 0
targetXoff = Array(15)
targetYoff = Array(15)
targetChoice = 0
targetType = 0
temp = 0

-- Starting Technology


function start2Evnt()
	removeMessage(MissionBrief, MISS_MSG, 0)
	deactivateEvent(start2Evnt)
	-- test how close to edge can go!
	-- addDroid(scorpRkt, reinfPosX2, reinfPosY2, enemy2);
	
	addMessage(MissionBrief2, MISS_MSG, 0, true)
end
callbackEvent(start2Evnt, CALL_VIDEO_QUIT)

function startEvnt()
	centreViewPos(11 * 128, 52 * 128)
	-- setScrollParams(0, 0, 128, 128);			//limit scroll
	-- set zoom Level 128x128
	setRadarZoom(0)
	-- stop player building on LZ
	setLandingZone(10, 51, 12, 53)
	addMessage(MissionBrief, MISS_MSG, 0, true)
	-- createAlliance(enemy1, enemy2);
	setPowerLevel(pow1, enemy1)
	setPowerLevel(pow2, enemy2)
	deactivateEvent(startEvnt)
	-- Blip Given at start
	-- addMessage(obj1, PROX_MSG, player, false);
	-- allow to build stuff
	setStructureLimits(powerGen, numPow, 0)
	setStructureLimits(oilDerrick, numExt, 0)
	setStructureLimits(research, numRes, 0)
	setStructureLimits(factory, numFac, 0)
	setStructureLimits(command, 1, player)
	setStructureLimits(comRelay, 1, player)
	enableStructure(command, player)
	enableStructure(powerGen, 0)
	enableStructure(oilDerrick, 0)
	enableStructure(research, 0)
	enableStructure(factory, 0)
	-- enableStructure(powerModuleHack, 0);
	
	-- set no time limits (can carry over from previous missions if not set!)
	setReinforcementTime(-1/10.0)
	-- set Mission time limit
	setMissionTime(timeLimit/10.0)
	
	-- player specific technology startups
	count = 0
	while count < numtecE2 do
		completeResearch(tecE2[count], enemy2)
		count = count + 1
	end
	
	-- force to recalc
	LZMess = numLZ + 1
	--[[//also don't allow building on 1CA's enemy LZs!
		count = 0;
		while (count < numLZ)
		{
			setNoGoArea((enemyLZX[count]/128) - 1, (enemyLZY[count]/128) - 1, (enemyLZX[count]/128) + 1, (enemyLZY[count]/128) + 1, count + 2);	//count+2 so doesn't set NP's LZ (since changes later!)
			count = count + 1;
		}]]--
	-- add enemy transport (once!)
	setNoGoArea((enemyLZX[0] / 128) - 1, (enemyLZY[0] / 128) - 1, (enemyLZX[0] / 128) + 1, (enemyLZY[0] / 128) + 1, enemy2)
	transportDroid = addDroidToMissionList(transporter, enemy2)
end
callbackEvent(startEvnt, CALL_GAMEINIT)

-- Events: Win or Lose

-- assumes victory already checked
function nextLevEvnt()
	pause(20/10.0)
	-- give bonus research (if req'd)
	count = 0
	while count < numResP0 do
		enableResearch(resP0[count], 0)
		count = count + 1
	end
	
	-- flag next part of map
	C.gameLevel = C.gameLevel + 1
	
	-- removeMessage(MissionBrief2, MISS_MSG, player);
	-- SUB1-4A next so BETWEEN rather than OFF_KEEP
	startMission(BETWEEN, NextLev)
	
	-- End game here for now! (don't try next mission)
	-- gameOver(true);
	
	deactivateEvent(nextLevEvnt)
end

function gameLost()
	gameOverMessage(endMsg, MISS_MSG, 0, false)
	deactivateEvent(gameLost)
end

function lostYetEvnt()
	if not anyDroidsLeft(player) then
		if not anyStructButWallsLeft(player) then
			deactivateEvent(wonYetEvnt)
			-- waits 2 seconds before ending
			repeatingEvent(gameLost, 2.0)
			deactivateEvent(lostYetEvnt)
			deactivateEvent(timeUp)
		end
	end
end
repeatingEvent(lostYetEvnt, 0.5)


-- have all enemies lost yet?
function wonYetEvnt()
	if not anyDroidsLeft(enemy2) then
		if not anyStructButWallsLeft(enemy2) then
			deactivateEvent(lostYetEvnt)
			repeatingEvent(nextLevEvnt, 0.5)
			deactivateEvent(wonYetEvnt)
			deactivateEvent(timeUp)
		end
	end
end

-- cheat button ctrl M
function cheatEvnt()
	repeatingEvent(nextLevEvnt, 0.5)
	deactivateEvent(cheatEvnt)
end
callbackEvent(cheatEvnt, CALL_MISSION_START)

-- Base Under Attack
function baseHit(_hitStruc, _attackerObj)
	if _hitStruc.player ~= C.selectedPlayer then return end
	hitStruc, attackerObj = _hitStruc, _attackerObj -- wz2lua: probably these can be used as function arguments directly
	if t >= 20 then
		t = 0
		if hitStruc ~= nil then
			playSoundPos(attackSnd1, C.selectedPlayer, hitStruc.x, hitStruc.y, hitStruc.z)
		else
			playSound(attackSnd1, C.selectedPlayer)
		end
	end
end
callbackEvent(baseHit, CALL_STRUCT_ATTACKED)

function everySec()
	t = t + 1
end
repeatingEvent(everySec, 1.0)

function seeBaseHit()
	if hitStruc ~= nil then
		centreView(hitStruc)
		-- flag known about!
		t = 0
	end
end
callbackEvent(seeBaseHit, CALL_MISSION_END)


-- make NP Transport "land"
function NPTransEvnt()
	if transportDroid ~= nil then
		if not transOnMap then
			if LZ < numLZ then
				if (not droidInArea(player, enemyLZX[LZ] - 512, enemyLZY[LZ] - 512, enemyLZX[LZ] + 512, enemyLZY[LZ] + 512)) and (not structInArea(player, enemyLZX[LZ] - 512, enemyLZY[LZ] - 512, enemyLZX[LZ] + 512, enemyLZY[LZ] + 512)) and (not droidInArea(enemy2, enemyLZX[LZ] - 200, enemyLZY[LZ] - 200, enemyLZX[LZ] + 200, enemyLZY[LZ] + 200)) then
					if LZMess < numLZ then
						removeMessage(enemyLZM[LZMess], PROX_MSG, player)
					end
					-- numTries = 0;		//reset number of tries
					-- warn player!!
					addMessage(enemyLZM[LZ], PROX_MSG, player, false)
					-- store so can remove later
					LZMess = LZ
					
					-- set landing zone first
					setNoGoArea((enemyLZX[LZ] / 128) - 1, (enemyLZY[LZ] / 128) - 1, (enemyLZX[LZ] / 128) + 1, (enemyLZY[LZ] / 128) + 1, enemy2)
					
					-- place paratroops
					-- addDroid(template3[0], enemyLZX[LZ] - 128, enemyLZY[LZ] - 128, enemy2);
					-- addDroid(template3[0], enemyLZX[LZ], enemyLZY[LZ] - 128, enemy2);
					-- addDroid(template3[1], enemyLZX[LZ] + 128, enemyLZY[LZ] - 128, enemy2);
					-- addDroid(template3[1], enemyLZX[LZ] + 128, enemyLZY[LZ], enemy2);
					-- addDroid(template3[2], enemyLZX[LZ] - 128, enemyLZY[LZ] + 128, enemy2);
					-- addDroid(template3[2], enemyLZX[LZ], enemyLZY[LZ] + 128, enemy2);
					loadDroid = addDroidToMissionList(template3[0], enemy2)
					if loadDroid ~= nil then
						numTries = 0
						addDroidToTransporter(transportDroid, loadDroid)
						transOnMap = true
					else
						numTries = numTries + 10
					end
					loadDroid = addDroidToMissionList(template3[0], enemy2)
					if loadDroid ~= nil then
						addDroidToTransporter(transportDroid, loadDroid)
					end
					loadDroid = addDroidToMissionList(template3[1], enemy2)
					if loadDroid ~= nil then
						addDroidToTransporter(transportDroid, loadDroid)
					end
					loadDroid = addDroidToMissionList(template3[1], enemy2)
					if loadDroid ~= nil then
						addDroidToTransporter(transportDroid, loadDroid)
					end
					loadDroid = addDroidToMissionList(template3[2], enemy2)
					if loadDroid ~= nil then
						addDroidToTransporter(transportDroid, loadDroid)
					end
					loadDroid = addDroidToMissionList(template3[2], enemy2)
					if loadDroid ~= nil then
						addDroidToTransporter(transportDroid, loadDroid)
					end
					
					-- call in transport, using random-ish positions
					setTransporterExit(enemy2, 126, 50 + random(32))
					flyTransporterIn(enemy2, 126, 50 + random(32), false)
					-- transOnMap = TRUE;
					
					-- not sure about this, but moved proper check to groupTrans event
					-- check for next LZ
					if targetChoice < 3 then
						repeatingEvent(NPTransEvnt, 45.0)
					end
				else
					repeatingEvent(NPTransEvnt, 2.0)
					numTries = numTries + 1
				end
				-- try 5 times before moving on to next LZ!
				if numTries > 5 then
					numTries = 0
					LZ = LZ + 1
				end
			else
				removeMessage(enemyLZM[LZMess], PROX_MSG, player)
				-- don't allow any more!
				deactivateEvent(NPTransEvnt)
				-- allow victory conditions
				repeatingEvent(wonYetEvnt, 0.5)
			end
		end
	else
		repeatingEvent(wonYetEvnt, 0.5)
	end
end
repeatingEvent(NPTransEvnt, 10.0)

function groupTrans(_NPgroup[(LZ * numTargets) + targetChoice], _player)
	if _player ~= enemy2 then return end
	playSoundPos(warnSnd, player, enemyLZX[LZMess] * 128, enemyLZY[LZMess] * 128, 0)
	pause(10/10.0)
	-- now get going!
	-- groupAddArea(NPgroup[(LZ * numTargets) + targetChoice], enemy2, enemyLZX[LZ] - 128, enemyLZY[LZ] - 128, enemyLZX[LZ] + 256, enemyLZY[LZ] + 256);
	-- keep track of total in this sortie
	sortieTot = sortieTot + groupCountMembers(NPgroup[(LZ * numTargets) + targetChoice])
	orderGroupLoc(NPgroup[(LZ * numTargets) + targetChoice], DORDER_SCOUT, targetX[(LZ * numTargets) + targetChoice], targetY[(LZ * numTargets) + targetChoice])
	
	targetChoice = targetChoice + 1
	-- check for next LZ
	if targetChoice >= 3 then
		LZ = LZ + 1
		targetChoice = 0
		-- longer delay before next attack
		-- playSound(wonSnd,0);
		deactivateEvent(NPTransEvnt)
		delayedEvent(sortieDelay, 60.0)
	else
		repeatingEvent(NPTransEvnt, 45.0)
	end
	-- do checks here so can trigger forces from edge of map...
	if LZ == 1 then
		conditionalEvent(checkSector1, "(numObjectsInArea(player, enemyLZX[0] - 1280, enemyLZY[0] - 1280, enemyLZX[0] + 1280, enemyLZY[0] + 1280) > 0)", 30.0)
		conditionalEvent(clearedSector1, "(numObjectsInArea(player, enemyLZX[0] - 1280, enemyLZY[0] - 1280, enemyLZX[0] + 1280, enemyLZY[0] + 1280) == 0)", 10.0)
		conditionalEvent(reinfSector1, "((numObjectsInArea(player, reinfPosX1 - 64, reinfPosY1 - 64, reinfPosX1 + 64, reinfPosY1 + 64) == 0) and (numObjectsInArea(enemy2, reinfPosX1 - 64, reinfPosY1 - 64, reinfPosX1 + 64, reinfPosY1 + 64) == 0))", 3.0)
	end
	if LZ == 2 then
		conditionalEvent(checkSector2, "(numObjectsInArea(player, enemyLZX[1] - 1280, enemyLZY[1] - 1280, enemyLZX[1] + 1280, enemyLZY[1] + 1280) > 0)", 30.0)
		conditionalEvent(clearedSector2, "(numObjectsInArea(player, enemyLZX[1] - 1280, enemyLZY[1] - 1280, enemyLZX[1] + 1280, enemyLZY[1] + 1280) == 0)", 10.0)
		conditionalEvent(reinfSector2, "((numObjectsInArea(player, reinfPosX2 - 64, reinfPosY2 - 64, reinfPosX2 + 64, reinfPosY2 + 64) == 0) and (numObjectsInArea(enemy2, reinfPosX2 - 64, reinfPosY2 - 64, reinfPosX2 + 64, reinfPosY2 + 64) == 0))", 3.0)
	end
	if LZ == 3 then
		conditionalEvent(checkSector3, "(numObjectsInArea(player, enemyLZX[2] - 1280, enemyLZY[2] - 1280, enemyLZX[2] + 1280, enemyLZY[2] + 1280) > 0)", 30.0)
		conditionalEvent(clearedSector3, "(numObjectsInArea(player, enemyLZX[2] - 1280, enemyLZY[2] - 1280, enemyLZX[2] + 1280, enemyLZY[2] + 1280) == 0)", 10.0)
	end
	-- setEventTrigger(reinfSector3, reinfSector3Trig);
	if LZ == 4 then
		conditionalEvent(checkSector4, "(numObjectsInArea(player, enemyLZX[3] - 1280, enemyLZY[3] - 1280, enemyLZX[3] + 1280, enemyLZY[3] + 1280) > 0)", 30.0)
		conditionalEvent(clearedSector4, "(numObjectsInArea(player, enemyLZX[3] - 1280, enemyLZY[3] - 1280, enemyLZX[3] + 1280, enemyLZY[3] + 1280) == 0)", 10.0)
	end
	-- setEventTrigger(reinfSector4, reinfSector4Trig);
	if LZ >= 5 then
		conditionalEvent(checkSector5, "(numObjectsInArea(player, enemyLZX[4] - 1280, enemyLZY[4] - 1280, enemyLZX[4] + 1280, enemyLZY[4] + 1280) > 0)", 30.0)
		conditionalEvent(clearedSector5, "(numObjectsInArea(player, enemyLZX[4] - 1280, enemyLZY[4] - 1280, enemyLZX[4] + 1280, enemyLZY[4] + 1280) == 0)", 10.0)
	end
end
callbackEvent(groupTrans, CALL_TRANSPORTER_LANDED)
-- setEventTrigger(reinfSector5, reinfSector5Trig);


function nextSortie()
	temp1 = (groupCountMembers(NPgroup[LZ - 1]) + groupCountMembers(NPgroup[LZ]) + groupCountMembers(NPgroup[LZ + 1]))
	-- keep track of number of tries
	sortieCount = sortieCount + 1
	-- wait another 2 minutes before forcing the next one
	if sortieCount > 12 then
		temp1 = 0
	end
	if temp1 <= sortieTot / 2 then
		sortieTot = 0
		repeatingEvent(NPTransEvnt, 10.0)
		deactivateEvent(nextSortie)
	end
end

function sortieDelay()
	repeatingEvent(nextSortie, 10.0)
	deactivateEvent(sortieDelay)
end


function clearedSector1()
	n = 0
	while n < 3 do
		enemyLZX[0] = enemyLZX[0] + random(128 * 20) - (128 * 10)
		enemyLZY[0] = enemyLZY[0] + random(128 * 30) - (128 * 20)
		if enemyLZX[0] < 1000 then
			enemyLZX[0] = random(128 * 20) + 1000
		end
		if enemyLZX[0] > 16000 then
			enemyLZX[0] = 16000 - random(128 * 20)
		end
		if enemyLZY[0] < 1000 then
			enemyLZY[0] = random(128 * 20) + 1000
		end
		if enemyLZY[0] > 16000 then
			enemyLZY[0] = 16000 - random(128 * 20)
		end
		orderGroupLoc(NPgroup[n], DORDER_SCOUT, enemyLZX[0], enemyLZY[0])
		targetX[n] = enemyLZX[0]
		targetY[n] = enemyLZY[0]
		n = n + 1
	end
end

function checkSector1()
	n = 0
	orderGroupLoc(reinfGroup[0], DORDER_SCOUT, targetX[n], targetY[n])
	while n < 3 do
		if idleGroup(NPgroup[n]) >= (groupCountMembers(NPgroup[n]) / 2) then
			targetX[n] = enemyLZX[0] + random(128 * 20) - (128 * 10)
			targetY[n] = enemyLZY[0] + random(128 * 20) - (128 * 10)
			if enemyLZX[0] + targetX[n] < 1000 then
				targetX[n] = enemyLZX[0] + 1000
			end
			if enemyLZX[0] + targetX[n] > 16000 then
				targetX[n] = 16000 - enemyLZX[0]
			end
			if enemyLZY[0] + targetY[n] < 1000 then
				targetY[n] = enemyLZY[0] + 1000
			end
			if enemyLZY[0] + targetY[n] > 16000 then
				targetY[n] = 16000 - enemyLZY[0]
			end
			orderGroupLoc(NPgroup[n], DORDER_SCOUT, targetX[n], targetY[n])
		end
		n = n + 1
	end
end

function clearedSector2()
	n = 3
	while n < 6 do
		enemyLZX[1] = enemyLZX[1] + random(128 * 30) - (128 * 20)
		enemyLZY[1] = enemyLZY[1] + random(128 * 30) - (128 * 15)
		if enemyLZX[1] < 1000 then
			enemyLZX[1] = random(128 * 20) + 1000
		end
		if enemyLZX[1] > 16000 then
			enemyLZX[1] = 16000 - random(128 * 20)
		end
		if enemyLZY[1] < 1000 then
			enemyLZY[1] = random(128 * 20) + 1000
		end
		if enemyLZY[1] > 16000 then
			enemyLZY[1] = 16000 - random(128 * 20)
		end
		orderGroupLoc(NPgroup[n], DORDER_SCOUT, enemyLZX[1], enemyLZY[1])
		targetX[n] = enemyLZX[1]
		targetY[n] = enemyLZY[1]
		n = n + 1
	end
end

function checkSector2()
	n = 3
	orderGroupLoc(reinfGroup[1], DORDER_SCOUT, targetX[n], targetY[n])
	while n < 6 do
		if idleGroup(NPgroup[n]) >= (groupCountMembers(NPgroup[n]) / 2) then
			targetX[n] = enemyLZX[1] + random(128 * 20) - (128 * 10)
			targetY[n] = enemyLZY[1] + random(128 * 20) - (128 * 10)
			if enemyLZX[1] + targetX[n] < 1000 then
				targetX[n] = enemyLZX[1] + 1000
			end
			if enemyLZX[1] + targetX[n] > 16000 then
				targetX[n] = 16000 - enemyLZX[1]
			end
			if enemyLZY[1] + targetY[n] < 1000 then
				targetY[n] = enemyLZY[1] + 1000
			end
			if enemyLZY[1] + targetY[n] > 16000 then
				targetY[n] = 16000 - enemyLZY[1]
			end
			orderGroupLoc(NPgroup[n], DORDER_SCOUT, targetX[n], targetY[n])
		end
		n = n + 1
	end
end


function clearedSector3()
	n = 6
	while n < 9 do
		enemyLZX[2] = enemyLZX[2] + random(128 * 30) - (128 * 15)
		enemyLZY[2] = enemyLZY[2] + random(128 * 30) - (128 * 15)
		if enemyLZX[2] < 1000 then
			enemyLZX[2] = random(128 * 20) + 1000
		end
		if enemyLZX[2] > 16000 then
			enemyLZX[2] = 16000 - random(128 * 20)
		end
		if enemyLZY[2] < 1000 then
			enemyLZY[2] = random(128 * 20) + 1000
		end
		if enemyLZY[2] > 16000 then
			enemyLZY[2] = 16000 - random(128 * 20)
		end
		orderGroupLoc(NPgroup[n], DORDER_SCOUT, enemyLZX[2], enemyLZY[2])
		targetX[n] = enemyLZX[2]
		targetY[n] = enemyLZY[2]
		n = n + 1
	end
end

function checkSector3()
	n = 6
	-- orderGroupLoc(reinfGroup[0], DORDER_SCOUT, targetX[n], targetY[n]);
	while n < 9 do
		if idleGroup(NPgroup[n]) >= (groupCountMembers(NPgroup[n]) / 2) then
			targetX[n] = enemyLZX[2] + random(128 * 20) - (128 * 10)
			targetY[n] = enemyLZY[2] + random(128 * 20) - (128 * 10)
			if enemyLZX[2] + targetX[n] < 1000 then
				targetX[n] = enemyLZX[2] + 1000
			end
			if enemyLZX[2] + targetX[n] > 16000 then
				targetX[n] = 16000 - enemyLZX[2]
			end
			if enemyLZY[2] + targetY[n] < 1000 then
				targetY[n] = enemyLZY[2] + 1000
			end
			if enemyLZY[2] + targetY[n] > 16000 then
				targetY[n] = 16000 - enemyLZY[2]
			end
			orderGroupLoc(NPgroup[n], DORDER_SCOUT, targetX[n], targetY[n])
		end
		n = n + 1
	end
end

function clearedSector4()
	n = 9
	while n < 12 do
		enemyLZX[3] = enemyLZX[3] + random(128 * 10) - (128 * 5)
		-- bias South
		enemyLZY[3] = enemyLZY[3] + random(128 * 30) - (128 * 15)
		if enemyLZX[3] < 1000 then
			enemyLZX[3] = random(128 * 20) + 1000
		end
		if enemyLZX[3] > 16000 then
			enemyLZX[3] = 16000 - random(128 * 20)
		end
		if enemyLZY[3] < 1000 then
			enemyLZY[3] = random(128 * 20) + 1000
		end
		if enemyLZY[3] > 16000 then
			enemyLZY[3] = 16000 - random(128 * 20)
		end
		orderGroupLoc(NPgroup[n], DORDER_SCOUT, enemyLZX[3], enemyLZY[3])
		targetX[n] = enemyLZX[3]
		targetY[n] = enemyLZY[3]
		n = n + 1
	end
end

function checkSector4()
	n = 9
	-- orderGroupLoc(reinfGroup[0], DORDER_SCOUT, targetX[n], targetY[n]);
	while n < 12 do
		if idleGroup(NPgroup[n]) >= (groupCountMembers(NPgroup[n]) / 2) then
			targetX[n] = enemyLZX[3] + random(128 * 20) - (128 * 10)
			targetY[n] = enemyLZY[3] + random(128 * 20) - (128 * 10)
			if enemyLZX[3] + targetX[n] < 1000 then
				targetX[n] = enemyLZX[3] + 1000
			end
			if enemyLZX[3] + targetX[n] > 16000 then
				targetX[n] = 16000 - enemyLZX[3]
			end
			if enemyLZY[3] + targetY[n] < 1000 then
				targetY[n] = enemyLZY[3] + 1000
			end
			if enemyLZY[3] + targetY[n] > 16000 then
				targetY[n] = 16000 - enemyLZY[3]
			end
			orderGroupLoc(NPgroup[n], DORDER_SCOUT, targetX[n], targetY[n])
		end
		n = n + 1
	end
end

function clearedSector5()
	n = 12
	while n < 15 do
		enemyLZX[4] = enemyLZX[4] + random(128 * 20) - (128 * 20)
		enemyLZY[4] = enemyLZY[4] + random(128 * 30) - (128 * 12)
		if enemyLZX[4] < 1000 then
			enemyLZX[4] = random(128 * 20) + 1000
		end
		if enemyLZX[4] > 16000 then
			enemyLZX[4] = 16000 - random(128 * 20)
		end
		if enemyLZY[4] < 1000 then
			enemyLZY[4] = random(128 * 20) + 1000
		end
		if enemyLZY[4] > 16000 then
			enemyLZY[4] = 16000 - random(128 * 20)
		end
		orderGroupLoc(NPgroup[n], DORDER_SCOUT, enemyLZX[4], enemyLZY[4])
		targetX[n] = enemyLZX[4]
		targetY[n] = enemyLZY[4]
		n = n + 1
	end
end

function checkSector5()
	n = 12
	-- orderGroupLoc(reinfGroup[0], DORDER_SCOUT, targetX[n], targetY[n]);
	while n < 15 do
		if idleGroup(NPgroup[n]) >= (groupCountMembers(NPgroup[n]) / 2) then
			targetX[n] = enemyLZX[4] + random(128 * 20) - (128 * 10)
			targetY[n] = enemyLZY[4] + random(128 * 20) - (128 * 10)
			if enemyLZX[4] + targetX[n] < 1000 then
				targetX[n] = enemyLZX[4] + 1000
			end
			if enemyLZX[4] + targetX[n] > 16000 then
				targetX[n] = 16000 - enemyLZX[4]
			end
			if enemyLZY[4] + targetY[n] < 1000 then
				targetY[n] = enemyLZY[4] + 1000
			end
			if enemyLZY[4] + targetY[n] > 16000 then
				targetY[n] = 16000 - enemyLZY[4]
			end
			orderGroupLoc(NPgroup[n], DORDER_SCOUT, targetX[n], targetY[n])
		end
		n = n + 1
	end
end

-- keep reinforcements moving
function reinfMove()
	if (groupCountMembers(reinfGroup[0]) > 0) and (idleGroup(reinfGroup[0]) >= groupCountMembers(reinfGroup[0]) / 2) then
		temp = random(numTargets)
		orderGroupLoc(reinfGroup[0], DORDER_SCOUT, targetX[temp], targetY[temp])
	end
	if (groupCountMembers(reinfGroup[1]) > 0) and (idleGroup(reinfGroup[1]) >= groupCountMembers(reinfGroup[1]) / 2) then
		temp = 14
		orderGroupLoc(reinfGroup[1], DORDER_SCOUT, targetX[temp], targetY[temp])
	end
end
repeatingEvent(reinfMove, 5.5)

function reinfSector1()
	if n1 < numReinf then
		if m1 < reinfNum[n1] then
			newDroid = addDroid(reinfTemp[n1], reinfPosX1, reinfPosY1, enemy2)
			if newDroid ~= nil then
				orderDroidLoc(newDroid, DORDER_SCOUT, targetX[14], targetY[14])
				groupAddDroid(reinfGroup[0], newDroid)
			end
			-- increment count even if we don't get a droid otherwise we'll sit in an infinite loop!
			-- keep track of number required for this template
			m1 = m1 + 1
		else
			m1 = 0
			-- update template for next pass
			n1 = n1 + 1
		end
	else
		deactivateEvent(reinfSector1)
	end
end

function reinfSector2()
	if n2 < numReinf then
		if m2 < reinfNum[n2] then
			newDroid = addDroid(reinfTemp[n2], reinfPosX2, reinfPosY2, enemy2)
			if newDroid ~= nil then
				orderDroidLoc(newDroid, DORDER_SCOUT, targetX[14], targetY[14])
				groupAddDroid(reinfGroup[1], newDroid)
			end
			
			-- increment count even if we don't get a droid otherwise we'll sit in an infinite loop!
			-- keep track of number required for this template
			m2 = m2 + 1
		else
			m2 = 0
			-- update template for next pass
			n2 = n2 + 1
		end
	else
		deactivateEvent(reinfSector2)
	end
end

function transOff(_player)
	if _player ~= enemy2 then return end
	transOnMap = false
end
callbackEvent(transOff, CALL_TRANSPORTER_OFFMAP)

function timeUp()
	deactivateEvent(wonYetEvnt)
	deactivateEvent(lostYetEvnt)
	repeatingEvent(gameLost, 2.0)
	deactivateEvent(timeUp)
end
callbackEvent(timeUp, CALL_MISSION_TIME)


---------- stubs ----------

if gameOverMessage == nil then gameOverMessage = function() print("stub: gameOverMessage"); return 0 end end
if centreView == nil then centreView = function() print("stub: centreView"); return 0 end end
if addDroid == nil then addDroid = function() print("stub: addDroid"); return 0 end end
if random == nil then random = function() print("stub: random"); return 0 end end
if enableResearch == nil then enableResearch = function() print("stub: enableResearch"); return 0 end end
if droidInArea == nil then droidInArea = function() print("stub: droidInArea"); return 0 end end
if setMissionTime == nil then setMissionTime = function() print("stub: setMissionTime"); return 0 end end
if anyStructButWallsLeft == nil then anyStructButWallsLeft = function() print("stub: anyStructButWallsLeft"); return 0 end end
if groupAddDroid == nil then groupAddDroid = function() print("stub: groupAddDroid"); return 0 end end
if numObjectsInArea == nil then numObjectsInArea = function() print("stub: numObjectsInArea"); return 0 end end
if addDroidToTransporter == nil then addDroidToTransporter = function() print("stub: addDroidToTransporter"); return 0 end end
if orderGroupLoc == nil then orderGroupLoc = function() print("stub: orderGroupLoc"); return 0 end end
if anyDroidsLeft == nil then anyDroidsLeft = function() print("stub: anyDroidsLeft"); return 0 end end
if startMission == nil then startMission = function() print("stub: startMission"); return 0 end end
if pause == nil then pause = function() print("stub: pause"); return 0 end end
if removeMessage == nil then removeMessage = function() print("stub: removeMessage"); return 0 end end
if idleGroup == nil then idleGroup = function() print("stub: idleGroup"); return 0 end end
if setReinforcementTime == nil then setReinforcementTime = function() print("stub: setReinforcementTime"); return 0 end end
if setLandingZone == nil then setLandingZone = function() print("stub: setLandingZone"); return 0 end end
if setPowerLevel == nil then setPowerLevel = function() print("stub: setPowerLevel"); return 0 end end
if addDroidToMissionList == nil then addDroidToMissionList = function() print("stub: addDroidToMissionList"); return 0 end end
if setStructureLimits == nil then setStructureLimits = function() print("stub: setStructureLimits"); return 0 end end
if playSoundPos == nil then playSoundPos = function() print("stub: playSoundPos"); return 0 end end
if numStructsInArea == nil then numStructsInArea = function() print("stub: numStructsInArea"); return 0 end end
if completeResearch == nil then completeResearch = function() print("stub: completeResearch"); return 0 end end
if setEventTrigger == nil then setEventTrigger = function() print("stub: setEventTrigger"); return 0 end end
if setNoGoArea == nil then setNoGoArea = function() print("stub: setNoGoArea"); return 0 end end
if setTransporterExit == nil then setTransporterExit = function() print("stub: setTransporterExit"); return 0 end end
if structInArea == nil then structInArea = function() print("stub: structInArea"); return 0 end end
if playSound == nil then playSound = function() print("stub: playSound"); return 0 end end
if flyTransporterIn == nil then flyTransporterIn = function() print("stub: flyTransporterIn"); return 0 end end
if addMessage == nil then addMessage = function() print("stub: addMessage"); return 0 end end
if setRadarZoom == nil then setRadarZoom = function() print("stub: setRadarZoom"); return 0 end end
if orderDroidLoc == nil then orderDroidLoc = function() print("stub: orderDroidLoc"); return 0 end end
if enableStructure == nil then enableStructure = function() print("stub: enableStructure"); return 0 end end
if centreViewPos == nil then centreViewPos = function() print("stub: centreViewPos"); return 0 end end
